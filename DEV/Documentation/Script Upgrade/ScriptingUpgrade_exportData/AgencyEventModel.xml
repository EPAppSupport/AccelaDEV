<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<list  version="7.3.0" minorVersion="35" exportUser="CHAVEZJ1" exportDateTime="02/02/2016 02:30 PM" description="ScriptingUpgrade"><agencyEvent><eventName>ApplicationSpecificInfoUpdateAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:49:30.617-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>ApplicationSpecificInfoUpdateAfter</name><auditModel><auditDate>2002-12-08T23:40:54-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after an Application Specific Information is updated.</description></event><scriptName>ApplicationSpecificInfoUpdateAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>ApplicationStatusUpdateAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:50:10.813-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>ApplicationStatusUpdateAfter</name><auditModel><auditDate>2004-05-03T17:52:51-06:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>Add a history record after updating the app status.</description></event><script><name>APPLICATIONSTATUSUPDATEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2010-09-20T10:18:29.453-06:00</auditDate><auditID>CAMPOSRG</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: ApplicationStatusUpdateAfter.js 3600 2008-10-27 21:36:24Z dane.quatacker $&#xD;
| Program : ApplicationStatusUpdateAfterV1.5.js&#xD;
| Event   : ApplicationStatusUpdateAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = false;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;ApplicationStatusUpdateAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup;&#xD;
var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var appStatus = aa.env.getValue(&quot;ApplicationStatus&quot;); logDebug(&quot;appStatus = &quot; + appStatus);&#xD;
var statusComment = aa.env.getValue(&quot;StatusComment&quot;);  logDebug(&quot;statusComment = &quot; + statusComment);&#xD;
var statusDate = aa.env.getValue(&quot;StatusDate&quot;);   logDebug(&quot;statusDate = &quot; + statusDate);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Internal Functions and Classes (Used by this script)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent)&#xD;
	{&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	var lastEvalTrue = false;&#xD;
	logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);&#xD;
	for (xx in pairObjArray)&#xD;
		{&#xD;
		doObj = pairObjArray[xx];&#xD;
		if (doExecution)&#xD;
			{&#xD;
			if (doObj.enabled)&#xD;
				if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation))&#xD;
					{&#xD;
					eval(token(doObj.act));&#xD;
					lastEvalTrue = true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					if (doObj.elseact)&#xD;
						eval(token(doObj.elseact));&#xD;
					lastEvalTrue = false;&#xD;
					}&#xD;
			}&#xD;
		else // just document&#xD;
			{&#xD;
			docWrite(&quot;|  &quot;,false,docIndent);&#xD;
			var disableString = &quot;&quot;;&#xD;
			if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
			if (doObj.elseact)&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact ,false,docIndent);&#xD;
			else&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act,false,docIndent);&#xD;
&#xD;
			for (yy in doObj.branch)&#xD;
				{&#xD;
				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);&#xD;
				}&#xD;
			}&#xD;
		} // next sAction&#xD;
	if (!doExecution) docWrite(null,true,docIndent);&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
&#xD;
function logDebug(dstr)&#xD;
	{&#xD;
	debug+=dstr + br;&#xD;
	}&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
 &#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
 &#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValueArray is an array of associative array values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
&#xD;
	for (thisrow in tableValueArray)&#xD;
		{&#xD;
		var col = tsm.getColumns()&#xD;
		var coli = col.iterator();&#xD;
&#xD;
		while (coli.hasNext())&#xD;
			{&#xD;
			var colname = coli.next();&#xD;
			fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			logDebug(&quot;Table: &quot; + tableName + &quot; Row:&quot; + thisrow + &quot; Column: &quot; + colname.getColumnName() + &quot; Value: &quot; + tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			}&#xD;
&#xD;
		tsm.setTableField(fld);&#xD;
&#xD;
		if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
		}&#xD;
&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
&#xD;
	// Even when this works it gives an index out of range error&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
 &#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
	        	if (addCapCondResult.getSuccess())&#xD;
	        		{&#xD;
				logMessage(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
	var col = tsm.getColumns()&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
		fld.add(tableValues[colname.getColumnName()]);&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
&#xD;
	if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
 &#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
 &#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
 &#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
 &#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
 &#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	} &#xD;
function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	} &#xD;
function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	} &#xD;
function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	} &#xD;
function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	 &#xD;
function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
 &#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
} &#xD;
function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
 &#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	//check if target CAP has primary address	&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
		&#xD;
	//get addresses from originating CAP	&#xD;
	var capAddressResult = aa.address.getAddressByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddress(newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional fields to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
 &#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
 &#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
 &#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
 &#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	 &#xD;
function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
 &#xD;
function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
 &#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
 &#xD;
function deactivateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logMessage(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
		{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
		}&#xD;
   	&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
			{&#xD;
				while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
				{&#xD;
					if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
					{&#xD;
						appspecObj[i].setChecklistComment(itemValue);&#xD;
						var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
						if (actionResult.getSuccess()) {&#xD;
							logMessage(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
							logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
						} else {&#xD;
							logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
						}&#xD;
						updated = true;&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
					}&#xD;
					i++;&#xD;
				} // while loop&#xD;
			} // item name blank&#xD;
		} // got app specific object	&#xD;
		else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
} &#xD;
function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	} &#xD;
function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
 &#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
	&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
   	&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = Contacts[yy].getEmail();&#xD;
		}	&#xD;
&#xD;
	if (emailAddress.length) &#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no email address&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	} &#xD;
&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
 &#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0]; &#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var capContactArray = capContactResult.getOutput();&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;			&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;			&#xD;
			aArray[&quot;email&quot;] = capContactArray[yy].getPeople().email;&#xD;
			aArray[&quot;addressLine1&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine1();&#xD;
			aArray[&quot;addressLine2&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine2();&#xD;
			aArray[&quot;city&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCity();&#xD;
			aArray[&quot;state&quot;] = capContactArray[yy].getPeople().getCompactAddress().getState();&#xD;
			aArray[&quot;zip&quot;] = capContactArray[yy].getPeople().getCompactAddress().getZip();&#xD;
			aArray[&quot;fax&quot;] = capContactArray[yy].getPeople().fax;&#xD;
			aArray[&quot;notes&quot;] = capContactArray[yy].getPeople().notes;&#xD;
			aArray[&quot;country&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCountry();&#xD;
			aArray[&quot;fullName&quot;] = capContactArray[yy].getPeople().fullName;&#xD;
&#xD;
&#xD;
			var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);                &#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}	&#xD;
&#xD;
 &#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
 &#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
   &#xD;
function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
 &#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
 &#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	} &#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
 &#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
 &#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))  &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    } &#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
 &#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	} &#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
&#xD;
function licenseObject(licnumber)&#xD;
	{&#xD;
	// available statuses (from various R1_SERVER_CONSTANT values&#xD;
	var licenseStatus = new Array(&quot;&quot;,&quot;Active&quot;,&quot;About To Expire&quot;,&quot;Delinquent&quot;,&quot;Expired&quot;,&quot;Invalid&quot;,&quot;Pending&quot;);&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
   	// The only way to pull up a renewal is to supply a status.  I don't understand since it has a 1 to 1 relationship with b1permit, but oh well.&#xD;
   	// the silly thing returns a blank record, so have to check the B1expirationModel to see if it's valid&#xD;
&#xD;
   	for (myStatus in licenseStatus)&#xD;
   		{&#xD;
   		b1ExpResult = aa.expiration.getLicensesByCapID(capId,licenseStatus[myStatus]);&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
   			exptest = this.b1Exp.getB1Expiration();&#xD;
    			if (exptest)&#xD;
    				{&#xD;
    				tmpDate = this.b1Exp.getExpDate();&#xD;
    				if (tmpDate)&#xD;
    					this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
    				this.b1Status = this.b1Exp.getExpStatus();&#xD;
    				logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
    				break&#xD;
    				}&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
		}&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	} &#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
 &#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
 &#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr); &#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
  	&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + fTask.getStatusDate().getMonth() + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}			&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}	&#xD;
 &#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
 &#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
 &#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
 &#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
 &#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	} &#xD;
  function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
	&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
		&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	&#xD;
	tsm.getColumns().clear();&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	&#xD;
	// Even when this works it gives an error of &quot;0&quot;&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error removing all rows from ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
 &#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID. &#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm &#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
	&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
		        &#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
 &#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    &#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
		}&#xD;
	} &#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
	{&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap,&quot;APPLICATION&quot;,stat, sysDate, cmt ,systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq) &#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
        &#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)        &#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
        &#xD;
    var invFeeFound=false;    &#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = fqty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) ) &#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
			&#xD;
	return feeSeq;&#xD;
	} &#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
	&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
	&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel() &#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
	&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
		&#xD;
	}	&#xD;
 &#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	 &#xD;
function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}&#xD;
function ProcessPendingEMSETasks(URL, SecurityToken, CAP)&#xD;
{&#xD;
	// There is a syntactic ambiguity in JavaScript that will cause that to fail. Failure can be avoided by wrapping the string in parens, so that it will be interpreted as an expression rather than a block.&#xD;
	var WFTasks = eval('(' + ExecWebService(URL, 'http://www.projectdox.com/', 'GetEMSEEntries', 'CAP=' + CAP + '|' + 'RemoveEntries=true' + '|' + 'SecurityToken='+ SecurityToken) + ')');&#xD;
	var ParamList='', ParamValue, OperationValue;&#xD;
	var ParamCount=10;&#xD;
	&#xD;
	for(var i=0; i&lt;WFTasks.Entries.Entry.length; i++)&#xD;
	{&#xD;
		if(WFTasks.Entries.Entry[i].Operation.length &gt; 0) // only process if we have an operation to do on it&#xD;
		{&#xD;
			aa.print(WFTasks.Entries.Entry[i].CAP);&#xD;
			aa.print(WFTasks.Entries.Entry[i].Operation);&#xD;
			&#xD;
			// we must override the variables in the master script so that we can explicitly set which user is updating	IF the user is specified	&#xD;
			if(WFTasks.Entries.Entry[i].AccelaUserID.length &gt; 0)&#xD;
			{&#xD;
				currentUserID = WFTasks.Entries.Entry[i].AccelaUserID; 		// Current User&#xD;
				systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
				&#xD;
				aa.print('User has been changed: ' + currentUserID);&#xD;
			}&#xD;
			&#xD;
			// build param list dynamically depending on what has been passed&#xD;
			for(var j=1; j&lt;=ParamCount; j++)&#xD;
			{&#xD;
				ParamValue='WFTasks.Entries.Entry[' + i + '].Param' + j;				&#xD;
				&#xD;
				if(eval(ParamValue + '.length') &gt; 0)&#xD;
				{&#xD;
					if(ParamList.length &gt; 0)&#xD;
						ParamList+=',';&#xD;
					&#xD;
					ParamList+=&quot;'&quot; + eval(ParamValue) + &quot;'&quot;;&#xD;
				}&#xD;
			}&#xD;
			&#xD;
			// execute the operation with the list of params sent in&#xD;
			OperationValue=WFTasks.Entries.Entry[i].Operation + '(' + ParamList + ')';&#xD;
&#xD;
			aa.print('Operation to execute: ' + OperationValue);&#xD;
						&#xD;
			eval(OperationValue);&#xD;
		}&#xD;
	}&#xD;
}&#xD;
&#xD;
// executes a web service with provided param list and returns string&#xD;
function ExecWebService(URL, SOAPNamespace, SOAPAction, ParamKeyValueList)&#xD;
{&#xD;
	var SoapActionURL=SOAPNamespace + SOAPAction;&#xD;
	var wsUser='';&#xD;
	var wsPassword='';&#xD;
&#xD;
	var wsDoc = aa.util.newStringBuffer();&#xD;
	&#xD;
	wsDoc.append(GetXMLHeader(URL,SOAPAction,SOAPNamespace));&#xD;
	&#xD;
	// loop over all key/values&#xD;
	var arrPairs=ParamKeyValueList.split('|');&#xD;
	var arrKeyValue;&#xD;
	&#xD;
	for(var i=0; i&lt;arrPairs.length; i++)&#xD;
	{&#xD;
		arrKeyValue=arrPairs[i].split('=');&#xD;
		&#xD;
		wsDoc.append(CreateXMLElement(wsDoc, arrKeyValue[0], arrKeyValue[1]));&#xD;
	}&#xD;
		&#xD;
	wsDoc.append(GetXMLFooter(SOAPAction));&#xD;
	&#xD;
	aa.print(&quot;WebService Request = &quot;+wsDoc+&quot;\n&quot;);&#xD;
	&#xD;
	var returnObj = aa.util.httpPostToSoapWebService(URL, wsDoc, wsUser, wsPassword, SoapActionURL);&#xD;
&#xD;
&#xD;
	aa.print(&quot;WebService Result = &quot;+returnObj.getSuccess()+&quot;\n&quot;);&#xD;
		&#xD;
	var Result='';&#xD;
	&#xD;
	if(returnObj.getSuccess())&#xD;
	{&#xD;
		Result = returnObj.getOutput();		&#xD;
		&#xD;
		aa.print(&quot;WebService Result = &quot;+Result+&quot;\n&quot;);&#xD;
	}&#xD;
	&#xD;
	&#xD;
	return Result;&#xD;
}&#xD;
&#xD;
// returns a string buffer&#xD;
function GetXMLHeader(sURL, SOAPAction, SOAPNamespace)&#xD;
{&#xD;
	var sb = aa.util.newStringBuffer();&#xD;
	sb.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);&#xD;
	sb.append(&quot;&lt;soap:Envelope&quot;);&#xD;
	sb.append(&quot;	xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot; &quot;);&#xD;
	sb.append(&quot;	xmlns:xsd=\&quot;http://www.w3.org/2001/XMLSchema\&quot; &quot;);&#xD;
	sb.append(&quot;	xmlns:soap=\&quot;http://schemas.xmlsoap.org/soap/envelope/\&quot;&gt;&quot;);&#xD;
	sb.append(&quot;	&lt;soap:Body&gt;&quot;);&#xD;
	sb.append(&quot;&lt;&quot; + SOAPAction + &quot; xmlns=\&quot;&quot;);&#xD;
	sb.append(SOAPNamespace);&#xD;
	sb.append(&quot;\&quot;&gt;&quot;);&#xD;
	return sb;&#xD;
}&#xD;
&#xD;
// returns a string buffer&#xD;
function GetXMLFooter(SOAPAction)&#xD;
{&#xD;
	var sb = aa.util.newStringBuffer();&#xD;
	sb.append(&quot;&lt;/&quot; + SOAPAction + &quot;&gt;&quot;);&#xD;
	sb.append(&quot;	&lt;/soap:Body&gt;&quot;);&#xD;
	sb.append(&quot;&lt;/soap:Envelope&gt;&quot;);&#xD;
	return sb;&#xD;
}&#xD;
&#xD;
// returns a string buffer&#xD;
function CreateXMLElement(sb, sTag, sChildren)&#xD;
{&#xD;
	var sb = aa.util.newStringBuffer();&#xD;
	// Future Enh: hash table of attribute key value pairs.&#xD;
	// sChildren is assumed to already be well-formed XML data in String or StringBuffer format.&#xD;
	if (sb == null)&#xD;
	{&#xD;
		sb = aa.util.newStringBuffer();&#xD;
	}&#xD;
	sb.append(&quot;&lt;&quot;);&#xD;
	sb.append(sTag);&#xD;
	sb.append(&quot;&gt;&quot;);&#xD;
	sb.append(sChildren);&#xD;
	sb.append(&quot;&lt;/&quot;);&#xD;
	sb.append(sTag);&#xD;
	sb.append(&quot;&gt;&quot;);&#xD;
	return sb;&#xD;
}</content><initializer></initializer><title>ApplicationStatusUpdateAfter</title></script><scriptName>ApplicationStatusUpdateAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>ApplicationSubmitAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:49:46.790-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>ApplicationSubmitAfter</name><auditModel><auditDate>2002-03-15T14:09:19-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after an application is created.</description></event><script><name>APPLICATIONSUBMITAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2009-11-10T14:06:00-07:00</auditDate><auditID>MJOHNSON</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: ApplicationSubmitAfter.js 3600 2008-10-27 21:36:24Z dane.quatacker $&#xD;
| Program : ApplicationSubmitAfterV1.5.js&#xD;
| Event   : ApplicationSubmitAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;ApplicationSubmitAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = true;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup;&#xD;
var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Internal Functions and Classes (Used by this script)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent)&#xD;
	{&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	var lastEvalTrue = false;&#xD;
	logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);&#xD;
	for (xx in pairObjArray)&#xD;
		{&#xD;
		doObj = pairObjArray[xx];&#xD;
		if (doExecution)&#xD;
			{&#xD;
			if (doObj.enabled)&#xD;
				if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation))&#xD;
					{&#xD;
					eval(token(doObj.act));&#xD;
					lastEvalTrue = true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					if (doObj.elseact)&#xD;
						eval(token(doObj.elseact));&#xD;
					lastEvalTrue = false;&#xD;
					}&#xD;
			}&#xD;
		else // just document&#xD;
			{&#xD;
			docWrite(&quot;|  &quot;,false,docIndent);&#xD;
			var disableString = &quot;&quot;;&#xD;
			if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
			if (doObj.elseact)&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact ,false,docIndent);&#xD;
			else&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act,false,docIndent);&#xD;
&#xD;
			for (yy in doObj.branch)&#xD;
				{&#xD;
				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);&#xD;
				}&#xD;
			}&#xD;
		} // next sAction&#xD;
	if (!doExecution) docWrite(null,true,docIndent);&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
&#xD;
function logDebug(dstr)&#xD;
	{&#xD;
	debug+=dstr + br;&#xD;
	}&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
 &#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
 &#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValueArray is an array of associative array values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
&#xD;
	for (thisrow in tableValueArray)&#xD;
		{&#xD;
		var col = tsm.getColumns()&#xD;
		var coli = col.iterator();&#xD;
&#xD;
		while (coli.hasNext())&#xD;
			{&#xD;
			var colname = coli.next();&#xD;
			fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			logDebug(&quot;Table: &quot; + tableName + &quot; Row:&quot; + thisrow + &quot; Column: &quot; + colname.getColumnName() + &quot; Value: &quot; + tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			}&#xD;
&#xD;
		tsm.setTableField(fld);&#xD;
&#xD;
		if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
		}&#xD;
&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
&#xD;
	// Even when this works it gives an index out of range error&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
 &#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
	        	if (addCapCondResult.getSuccess())&#xD;
	        		{&#xD;
				logMessage(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
	var col = tsm.getColumns()&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
		fld.add(tableValues[colname.getColumnName()]);&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
&#xD;
	if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
 &#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
 &#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
 &#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
 &#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
 &#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	} &#xD;
function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	} &#xD;
function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	} &#xD;
function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	} &#xD;
function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	 &#xD;
function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
 &#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
} &#xD;
function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
 &#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	//check if target CAP has primary address	&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
		&#xD;
	//get addresses from originating CAP	&#xD;
	var capAddressResult = aa.address.getAddressByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddress(newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional fields to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
 &#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
 &#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
 &#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
 &#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	 &#xD;
function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
 &#xD;
function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
 &#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
 &#xD;
function deactivateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logMessage(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
		{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
		}&#xD;
   	&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
			{&#xD;
				while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
				{&#xD;
					if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
					{&#xD;
						appspecObj[i].setChecklistComment(itemValue);&#xD;
						var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
						if (actionResult.getSuccess()) {&#xD;
							logMessage(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
							logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
						} else {&#xD;
							logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
						}&#xD;
						updated = true;&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
					}&#xD;
					i++;&#xD;
				} // while loop&#xD;
			} // item name blank&#xD;
		} // got app specific object	&#xD;
		else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
} &#xD;
function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	} &#xD;
function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
 &#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
	&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
   	&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = Contacts[yy].getEmail();&#xD;
		}	&#xD;
&#xD;
	if (emailAddress.length) &#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no email address&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	} &#xD;
&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
 &#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0]; &#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var capContactArray = capContactResult.getOutput();&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;			&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;			&#xD;
			aArray[&quot;email&quot;] = capContactArray[yy].getPeople().email;&#xD;
			aArray[&quot;addressLine1&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine1();&#xD;
			aArray[&quot;addressLine2&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine2();&#xD;
			aArray[&quot;city&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCity();&#xD;
			aArray[&quot;state&quot;] = capContactArray[yy].getPeople().getCompactAddress().getState();&#xD;
			aArray[&quot;zip&quot;] = capContactArray[yy].getPeople().getCompactAddress().getZip();&#xD;
			aArray[&quot;fax&quot;] = capContactArray[yy].getPeople().fax;&#xD;
			aArray[&quot;notes&quot;] = capContactArray[yy].getPeople().notes;&#xD;
			aArray[&quot;country&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCountry();&#xD;
			aArray[&quot;fullName&quot;] = capContactArray[yy].getPeople().fullName;&#xD;
&#xD;
&#xD;
			var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);                &#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}	&#xD;
&#xD;
 &#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
 &#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
   &#xD;
function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
 &#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
 &#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	} &#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
 &#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
 &#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))  &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    } &#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
 &#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	} &#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
&#xD;
function licenseObject(licnumber)&#xD;
	{&#xD;
	// available statuses (from various R1_SERVER_CONSTANT values&#xD;
	var licenseStatus = new Array(&quot;&quot;,&quot;Active&quot;,&quot;About To Expire&quot;,&quot;Delinquent&quot;,&quot;Expired&quot;,&quot;Invalid&quot;,&quot;Pending&quot;);&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
   	// The only way to pull up a renewal is to supply a status.  I don't understand since it has a 1 to 1 relationship with b1permit, but oh well.&#xD;
   	// the silly thing returns a blank record, so have to check the B1expirationModel to see if it's valid&#xD;
&#xD;
   	for (myStatus in licenseStatus)&#xD;
   		{&#xD;
   		b1ExpResult = aa.expiration.getLicensesByCapID(capId,licenseStatus[myStatus]);&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
   			exptest = this.b1Exp.getB1Expiration();&#xD;
    			if (exptest)&#xD;
    				{&#xD;
    				tmpDate = this.b1Exp.getExpDate();&#xD;
    				if (tmpDate)&#xD;
    					this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
    				this.b1Status = this.b1Exp.getExpStatus();&#xD;
    				logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
    				break&#xD;
    				}&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
		}&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	} &#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
 &#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
 &#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr); &#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
  	&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + fTask.getStatusDate().getMonth() + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}			&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}	&#xD;
 &#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
 &#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
 &#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
 &#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;SCRIPT LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
 &#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	} &#xD;
  function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
	&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
		&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	&#xD;
	tsm.getColumns().clear();&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	&#xD;
	// Even when this works it gives an error of &quot;0&quot;&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error removing all rows from ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
 &#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID. &#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm &#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
	&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
		        &#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
 &#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    &#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
		}&#xD;
	} &#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
	{&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap,&quot;APPLICATION&quot;,stat, sysDate, cmt ,systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq) &#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
        &#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)        &#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
        &#xD;
    var invFeeFound=false;    &#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = fqty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) ) &#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
			&#xD;
	return feeSeq;&#xD;
	} &#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
	&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
	&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel() &#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
	&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
		&#xD;
	}	&#xD;
 &#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	 &#xD;
function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><title>ApplicationSubmitAfter</title></script><scriptName>ApplicationSubmitAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>ApplicationSubmitBefore</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:50:28.393-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>ApplicationSubmitBefore</name><auditModel><auditDate>2002-03-15T14:09:20-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs before an application is created.</description></event><script><name>APPLICATIONSUBMITBEFORE</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2012-04-03T17:08:54.210-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: ApplicationSubmitBefore.js 3600 2008-10-27 21:36:24Z dane.quatacker $&#xD;
| Program : ApplicationSubmitBeforeV1.5.js&#xD;
| Event   : ApplicationSubmitBefore&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;			// Set to true to see results in popup window&#xD;
var showDebug = true;				// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;ApplicationSubmitBefore&quot;; 	// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForBeforeEvents&quot;&#xD;
var cancel = false ; 				// Setting cancel to true in standard choices will cancel the event&#xD;
var documentOnly = false;			// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;			// turn off tokenizing of App Specific and Parcel Attributes&#xD;
var useAppSpecificGroupName = false;		// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;		// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;				// Maximum number of std choice entries.  Must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;					// Message String&#xD;
var debug = &quot;&quot;;&#xD;
var br = &quot;&lt;BR&gt;&quot;;					// Break Tag&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results&lt;/B&gt;&quot;);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var AdditionalInfoBuildingCount 	= aa.env.getValue(&quot;AdditionalInfoBuildingCount&quot;);&#xD;
var AdditionalInfoConstructionTypeCode 	= aa.env.getValue(&quot;AdditionalInfoConstructionTypeCode&quot;);&#xD;
var AdditionalInfoHouseCount 		= aa.env.getValue(&quot;AdditionalInfoHouseCount&quot;);&#xD;
var AdditionalInfoPublicOwnedFlag 	= aa.env.getValue(&quot;AdditionalInfoPublicOwnedFlag&quot;);&#xD;
var AdditionalInfoValuation 		= aa.env.getValue(&quot;AdditionalInfoValuation&quot;);&#xD;
var AdditionalInfoWorkDescription 	= aa.env.getValue(&quot;AdditionalInfoWorkDescription&quot;);&#xD;
var AddressCity 			= aa.env.getValue(&quot;AddressCity&quot;);&#xD;
var AddressHouseFraction 		= aa.env.getValue(&quot;AddressHouseFraction&quot;);&#xD;
var AddressHouseNumber 			= aa.env.getValue(&quot;AddressHouseNumber&quot;);&#xD;
var AddressPrimaryFlag 			= aa.env.getValue(&quot;AddressPrimaryFlag&quot;);&#xD;
var AddressState 			= aa.env.getValue(&quot;AddressState&quot;);&#xD;
var AddressStreetDirection 		= aa.env.getValue(&quot;AddressStreetDirection&quot;);&#xD;
var AddressStreetName 			= aa.env.getValue(&quot;AddressStreetName&quot;);&#xD;
var AddressStreetSuffix 		= aa.env.getValue(&quot;AddressStreetSuffix&quot;);&#xD;
var AddressUnitNumber 			= aa.env.getValue(&quot;AddressUnitNumber&quot;);&#xD;
var AddressUnitType 			= aa.env.getValue(&quot;AddressUnitType&quot;);&#xD;
var AddressValidatedNumber 		= aa.env.getValue(&quot;AddressValidatedNumber&quot;);&#xD;
var AddressZip 				= aa.env.getValue(&quot;AddressZip&quot;);&#xD;
var AppSpecificInfoModels 		= aa.env.getValue(&quot;AppSpecificInfoModels&quot;);&#xD;
var ApplicantAddressLine1 		= aa.env.getValue(&quot;ApplicantAddressLine1&quot;);&#xD;
var ApplicantAddressLine2 		= aa.env.getValue(&quot;ApplicantAddressLine2&quot;);&#xD;
var ApplicantAddressLine3 		= aa.env.getValue(&quot;ApplicantAddressLine3&quot;);&#xD;
var ApplicantBusinessName 		= aa.env.getValue(&quot;ApplicantBusinessName&quot;);&#xD;
var ApplicantCity 			= aa.env.getValue(&quot;ApplicantCity&quot;);&#xD;
var ApplicantContactType 		= aa.env.getValue(&quot;ApplicantContactType&quot;);&#xD;
var ApplicantCountry 			= aa.env.getValue(&quot;ApplicantCountry&quot;);&#xD;
var ApplicantEmail 			= aa.env.getValue(&quot;ApplicantEmail&quot;);&#xD;
var ApplicantFirstName 			= aa.env.getValue(&quot;ApplicantFirstName&quot;);&#xD;
var ApplicantId 			= aa.env.getValue(&quot;ApplicantId&quot;);&#xD;
var ApplicantLastName 			= aa.env.getValue(&quot;ApplicantLastName&quot;);&#xD;
var ApplicantMiddleName 		= aa.env.getValue(&quot;ApplicantMiddleName&quot;);&#xD;
var ApplicantPhone1 			= aa.env.getValue(&quot;ApplicantPhone1&quot;);&#xD;
var ApplicantPhone2 			= aa.env.getValue(&quot;ApplicantPhone2&quot;);&#xD;
var ApplicantRelation 			= aa.env.getValue(&quot;ApplicantRelation&quot;);&#xD;
var ApplicantState 			= aa.env.getValue(&quot;ApplicantState&quot;);&#xD;
var ApplicantZip 			= aa.env.getValue(&quot;ApplicantZip&quot;);&#xD;
var ApplicationSubmitMode 		= aa.env.getValue(&quot;ApplicationSubmitMode&quot;);&#xD;
var ApplicationName 			= aa.env.getValue(&quot;AppSpecialText&quot;);&#xD;
var ApplicationTypeLevel1 		= aa.env.getValue(&quot;ApplicationTypeLevel1&quot;);&#xD;
var ApplicationTypeLevel2 		= aa.env.getValue(&quot;ApplicationTypeLevel2&quot;);&#xD;
var ApplicationTypeLevel3 		= aa.env.getValue(&quot;ApplicationTypeLevel3&quot;);&#xD;
var ApplicationTypeLevel4 		= aa.env.getValue(&quot;ApplicationTypeLevel4&quot;);&#xD;
var CAEAddressLine1 			= aa.env.getValue(&quot;CAEAddressLine1&quot;);&#xD;
var CAEAddressLine2 			= aa.env.getValue(&quot;CAEAddressLine2&quot;);&#xD;
var CAEAddressLine3 			= aa.env.getValue(&quot;CAEAddressLine3&quot;);&#xD;
var CAEBusinessName 			= aa.env.getValue(&quot;CAEBusinessName&quot;);&#xD;
var CAECity 				= aa.env.getValue(&quot;CAECity&quot;);&#xD;
var CAEEmail 				= aa.env.getValue(&quot;CAEEmail&quot;);&#xD;
var CAEFirstName 			= aa.env.getValue(&quot;CAEFirstName&quot;);&#xD;
var CAELastName 			= aa.env.getValue(&quot;CAELastName&quot;);&#xD;
var CAELienseNumber 			= aa.env.getValue(&quot;CAELienseNumber&quot;);&#xD;
var CAELienseType 			= aa.env.getValue(&quot;CAELienseType&quot;);&#xD;
var CAEMiddleName 			= aa.env.getValue(&quot;CAEMiddleName&quot;);&#xD;
var CAEPhone1 				= aa.env.getValue(&quot;CAEPhone1&quot;);&#xD;
var CAEPhone2 				= aa.env.getValue(&quot;CAEPhone2&quot;);&#xD;
var CAEState 				= aa.env.getValue(&quot;CAEState&quot;);&#xD;
var CAEValidatedNumber 			= aa.env.getValue(&quot;CAEValidatedNumber&quot;);&#xD;
var CAEZip 				= aa.env.getValue(&quot;CAEZip&quot;);&#xD;
var ComplainantAddressLine1 		= aa.env.getValue(&quot;ComplainantAddressLine1&quot;);&#xD;
var ComplainantAddressLine2 		= aa.env.getValue(&quot;ComplainantAddressLine2&quot;);&#xD;
var ComplainantAddressLine3 		= aa.env.getValue(&quot;ComplainantAddressLine3&quot;);&#xD;
var ComplainantBusinessName 		= aa.env.getValue(&quot;ComplainantBusinessName&quot;);&#xD;
var ComplainantCity 			= aa.env.getValue(&quot;ComplainantCity&quot;);&#xD;
var ComplainantContactType 		= aa.env.getValue(&quot;ComplainantContactType&quot;);&#xD;
var ComplainantCountry 			= aa.env.getValue(&quot;ComplainantCountry&quot;);&#xD;
var ComplainantEmail 			= aa.env.getValue(&quot;ComplainantEmail&quot;);&#xD;
var ComplainantFax 			= aa.env.getValue(&quot;ComplainantFax&quot;);&#xD;
var ComplainantFirstName 		= aa.env.getValue(&quot;ComplainantFirstName&quot;);&#xD;
var ComplainantId 			= aa.env.getValue(&quot;ComplainantId&quot;);&#xD;
var ComplainantLastName 		= aa.env.getValue(&quot;ComplainantLastName&quot;);&#xD;
var ComplainantMiddleName 		= aa.env.getValue(&quot;ComplainantMiddleName&quot;);&#xD;
var ComplainantPhone1 			= aa.env.getValue(&quot;ComplainantPhone1&quot;);&#xD;
var ComplainantRelation 		= aa.env.getValue(&quot;ComplainantRelation&quot;);&#xD;
var ComplainantState 			= aa.env.getValue(&quot;ComplainantState&quot;);&#xD;
var ComplainantZip 			= aa.env.getValue(&quot;ComplainantZip&quot;);&#xD;
var ComplaintDate 			= aa.env.getValue(&quot;ComplaintDate&quot;);&#xD;
var ComplaintReferenceId1 		= aa.env.getValue(&quot;ComplaintReferenceId1&quot;);&#xD;
var ComplaintReferenceId2 		= aa.env.getValue(&quot;ComplaintReferenceId2&quot;);&#xD;
var ComplaintReferenceId3 		= aa.env.getValue(&quot;ComplaintReferenceId3&quot;);&#xD;
var ComplaintReferenceSource 		= aa.env.getValue(&quot;ComplaintReferenceSource&quot;);&#xD;
var ComplaintReferenceType 		= aa.env.getValue(&quot;ComplaintReferenceType&quot;);&#xD;
var CurrentUserID 			= aa.env.getValue(&quot;CurrentUserID&quot;);&#xD;
var OwnerFirstName 			= aa.env.getValue(&quot;OwnerFirstName&quot;);&#xD;
var OwnerFullName 			= aa.env.getValue(&quot;OwnerFullName&quot;);&#xD;
var OwnerLastName 			= aa.env.getValue(&quot;OwnerLastName&quot;);&#xD;
var OwnerMailAddressLine1 		= aa.env.getValue(&quot;OwnerMailAddressLine1&quot;);&#xD;
var OwnerMailAddressLine2 		= aa.env.getValue(&quot;OwnerMailAddressLine2&quot;);&#xD;
var OwnerMailAddressLine3 		= aa.env.getValue(&quot;OwnerMailAddressLine3&quot;);&#xD;
var OwnerMailCity 			= aa.env.getValue(&quot;OwnerMailCity&quot;);&#xD;
var OwnerMailState 			= aa.env.getValue(&quot;OwnerMailState&quot;);&#xD;
var OwnerMailZip 			= aa.env.getValue(&quot;OwnerMailZip&quot;);&#xD;
var OwnerMiddleName 			= aa.env.getValue(&quot;OwnerMiddleName&quot;);&#xD;
var OwnerPhone 				= aa.env.getValue(&quot;OwnerPhone&quot;);&#xD;
var OwnerPrimaryFlag 			= aa.env.getValue(&quot;OwnerPrimaryFlag&quot;);&#xD;
var OwnerValidatedNumber 		= aa.env.getValue(&quot;OwnerValidatedNumber&quot;);&#xD;
var ParcelArea 				= aa.env.getValue(&quot;ParcelArea&quot;);&#xD;
var ParcelBlock 			= aa.env.getValue(&quot;ParcelBlock&quot;);&#xD;
var ParcelBook 				= aa.env.getValue(&quot;ParcelBook&quot;);&#xD;
var ParcelExcemptValue 			= aa.env.getValue(&quot;ParcelExcemptValue&quot;);&#xD;
var ParcelImprovedValue 		= aa.env.getValue(&quot;ParcelImprovedValue&quot;);&#xD;
var ParcelLandValue 			= aa.env.getValue(&quot;ParcelLandValue&quot;);&#xD;
var ParcelLegalDescription 		= aa.env.getValue(&quot;ParcelLegalDescription&quot;);&#xD;
var ParcelLot 				= aa.env.getValue(&quot;ParcelLot&quot;);&#xD;
var ParcelPage 				= aa.env.getValue(&quot;ParcelPage&quot;);&#xD;
var ParcelParcel 			= aa.env.getValue(&quot;ParcelParcel&quot;);&#xD;
var ParcelTract 			= aa.env.getValue(&quot;ParcelTract&quot;);&#xD;
var ParcelValidatedNumber 		= aa.env.getValue(&quot;ParcelValidatedNumber&quot;);&#xD;
var ViolationAddressLine1 		= aa.env.getValue(&quot;ViolationAddressLine1&quot;);&#xD;
var ViolationAddressLine2 		= aa.env.getValue(&quot;ViolationAddressLine2&quot;);&#xD;
var ViolationCity 			= aa.env.getValue(&quot;ViolationCity&quot;);&#xD;
var ViolationComment 			= aa.env.getValue(&quot;ViolationComment&quot;);&#xD;
var ViolationLocation 			= aa.env.getValue(&quot;ViolationLocation&quot;);&#xD;
var ViolationState 			= aa.env.getValue(&quot;ViolationState&quot;);&#xD;
var ViolationZip  			= aa.env.getValue(&quot;ViolationZip&quot;);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var appTypeString = ApplicationTypeLevel1 + &quot;/&quot; + ApplicationTypeLevel2 + &quot;/&quot; + ApplicationTypeLevel3 + &quot;/&quot; + ApplicationTypeLevel4;&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);		// Array of application type string&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   // Current USer&#xD;
var AppSpecificInfoModels = aa.env.getValue(&quot;AppSpecificInfoModels&quot;);&#xD;
var servProvCode = aa.getServiceProviderCode();&#xD;
var CAENumber = parseInt(CAEValidatedNumber);&#xD;
var CAE;&#xD;
var CAEAtt;&#xD;
&#xD;
var AInfo = new Array()					// Associative array of appspecifc info&#xD;
loadAppSpecificBefore(AInfo);&#xD;
&#xD;
// Get CAE Attributes&#xD;
&#xD;
&#xD;
if (CAENumber &gt; 0)&#xD;
	{&#xD;
	var CAEResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,CAENumber)&#xD;
	if (CAEResult.getSuccess())&#xD;
		{ CAE=CAEResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting CAE : &quot; + CAEResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
if (CAE)&#xD;
	CAEAtt = CAE.getLicenseModel().getAttributes();&#xD;
&#xD;
if (CAEAtt)&#xD;
	{&#xD;
	itr = CAEAtt.values().iterator();&#xD;
	while(itr.hasNext())&#xD;
		{&#xD;
		y = itr.next()&#xD;
		itr2 = y.iterator();&#xD;
		while (itr2.hasNext())&#xD;
			{&#xD;
			pam = itr2.next();&#xD;
			AInfo[&quot;CAEAttribute.&quot; + pam.getAttributeName()] = pam.getAttributeValue();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  // Current User Object&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	if (cancel)&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + debug);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Internal Functions and Classes (Used by this script)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
function loadAppSpecificBefore(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of App Specific Info&#xD;
	//&#xD;
	for (loopk in AppSpecificInfoModels)&#xD;
		{&#xD;
		if (useAppSpecificGroupName)&#xD;
			{&#xD;
			thisArr[AppSpecificInfoModels[loopk].getCheckboxType() + &quot;.&quot; + AppSpecificInfoModels[loopk].checkboxDesc] = AppSpecificInfoModels[loopk].checklistComment;&#xD;
			logDebug(&quot;{&quot; + AppSpecificInfoModels[loopk].getCheckboxType() + &quot;.&quot; + AppSpecificInfoModels[loopk].checkboxDesc + &quot;} = &quot; + AppSpecificInfoModels[loopk].checklistComment);&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
			thisArr[AppSpecificInfoModels[loopk].checkboxDesc] = AppSpecificInfoModels[loopk].checklistComment;&#xD;
			logDebug(&quot;{&quot; + AppSpecificInfoModels[loopk].checkboxDesc + &quot;} = &quot; + AppSpecificInfoModels[loopk].checklistComment);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function loadAppSpecific(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
		{&#xD;
		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
		var parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
		}&#xD;
	}&#xD;
&#xD;
function loadTaskSpecific(thisArr)&#xD;
	{&#xD;
 	//&#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent)&#xD;
	{&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	var lastEvalTrue = false;&#xD;
	logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);&#xD;
	for (xx in pairObjArray)&#xD;
		{&#xD;
		doObj = pairObjArray[xx];&#xD;
		if (doExecution)&#xD;
			{&#xD;
			if (doObj.enabled)&#xD;
				if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation))&#xD;
					{&#xD;
					eval(token(doObj.act));&#xD;
					lastEvalTrue = true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					if (doObj.elseact)&#xD;
						eval(token(doObj.elseact));&#xD;
					lastEvalTrue = false;&#xD;
					}&#xD;
			}&#xD;
		else // just document&#xD;
			{&#xD;
			docWrite(&quot;|  &quot;,false,docIndent);&#xD;
			var disableString = &quot;&quot;;&#xD;
			if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
			if (doObj.elseact)&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact ,false,docIndent);&#xD;
			else&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act,false,docIndent);&#xD;
&#xD;
			for (yy in doObj.branch)&#xD;
				{&#xD;
				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);&#xD;
				}&#xD;
			}&#xD;
		} // next sAction&#xD;
	if (!doExecution) docWrite(null,true,docIndent);&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
&#xD;
function logDebug(dstr)&#xD;
	{&#xD;
	debug+=dstr + br;&#xD;
	}&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2)&#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}&#xD;
&#xD;
&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + fTask.getStatusDate().getMonth() + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
&#xD;
function lookup(stdChoice,stdValue)&#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfo(svc,layer,attributename)&#xD;
{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	// to be used with ApplicationSubmitBefore only&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
	{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
	}&#xD;
	else&#xD;
	{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Parcel.  We'll only send the last value&#xD;
	{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
		{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
			{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
	return retString&#xD;
} &#xD;
function getRelatedCapsByAddressBefore(ats) &#xD;
//&#xD;
// returns the capId object of the parent.  Assumes only one parent!&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	&#xD;
	if (AddressValidatedNumber &gt; 0) // get the address info from lookup table&#xD;
	  {&#xD;
	  addObj = aa.address.getRefAddressByPK(parseInt(AddressValidatedNumber)).getOutput();&#xD;
	  AddressStreetName = addObj.getStreetName();&#xD;
	  AddressHouseNumber = addObj.getHouseNumberStart();&#xD;
	  AddressStreetSuffix = addObj.getStreetSuffix();&#xD;
	  AddressZip = addObj.getZip();&#xD;
	  AddressStreetDirection = addObj.getStreetDirection();&#xD;
	  }&#xD;
&#xD;
	 if (AddressStreetDirection == &quot;&quot;) AddressStreetDirection = null;&#xD;
	 if (AddressHouseNumber == &quot;&quot;) AddressHouseNumber = 0;&#xD;
	 if (AddressStreetSuffix == &quot;&quot;) AddressStreetSuffix = null;&#xD;
	 if (AddressZip == &quot;&quot;) AddressZip = null;&#xD;
 &#xD;
 	// get caps with same address&#xD;
 	capAddResult = aa.cap.getCapListByDetailAddress(AddressStreetName,parseInt(AddressHouseNumber),AddressStreetSuffix,AddressZip,AddressStreetDirection,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
		{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
		// get cap type&#xD;
&#xD;
		reltype = relcap.getCapType().toString();&#xD;
&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
	 &#xD;
function getRelatedCapsByParcelBefore(ats) &#xD;
//&#xD;
// appsubmitBefore script only.  Returns an array of capids that match the parcelValidatedNumber&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
&#xD;
	// get caps with same parcel&#xD;
	var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
		{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		// get cap type&#xD;
&#xD;
		var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
 &#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	} &#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// to be used with ApplicationSubmitBefore only&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
   	&#xD;
	bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	&#xD;
	var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length) &#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014&#xD;
	//&#xD;
	if (pDateType==null || pDateType.length==0)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else &#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;		&#xD;
		}&#xD;
		&#xD;
	if (pLicNum==null || pLicNum.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
		&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),pLicNum);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR retrieving reference license professional: &quot; + refLicenseResult.getErrorMessage());&#xD;
		return false; &#xD;
		}&#xD;
		&#xD;
	var newLicArray = refLicenseResult.getOutput();&#xD;
	if (newLicArray)&#xD;
		{&#xD;
		newLic = newLicArray[0];&#xD;
		var jsExpDate = new Date();&#xD;
		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
</content><initializer></initializer><title>APPLICATIONSUBMITBEFORE</title></script><scriptName>ApplicationSubmitBefore</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>CommunicationReceivingEmailAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2014-09-16T10:48:37.147-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>CommunicationReceivingEmailAfter</name><auditModel><auditDate>2013-12-05T19:34:11.540-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after receiving emails for an account.</description><udf1></udf1><udf2></udf2><udf3></udf3><udf4></udf4><udf5></udf5></event><script><name>COMMUNICATIONRECEIVINGEMAILAFTERV3.0</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2014-09-22T10:40:30.740-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| Program : CommunicationReceivingEmailAfterV3.0.js&#xD;
| Event   : CommunicationReceivingEmailAfter&#xD;
|&#xD;
| Usage   : CommunicationReceivingEmailAfter master script&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
// only enable sendDebugEmail when debugging this script&#xD;
// when sendDebugEmail = true, the debug log will be emailed to the debugEmailAddress&#xD;
sendDebugEmail = true;&#xD;
debugEmailAddress = &quot;gutierrezma@elpasotexas.gov&quot;;&#xD;
&#xD;
// set the bounceback subject and body&#xD;
bouncebackSubject = &quot;Your message could not be accepted: &quot;;&#xD;
bouncebackBody = &quot;Please make sure the Record ID #XXXXXX is in the subject line when replying to a message. &quot;;&#xD;
&#xD;
var controlString = &quot;CommunicationReceivingEmailAfter&quot;; 				// Standard choice for control&#xD;
var showMessage = false;		// Set to true to see results in popup window&#xD;
var showDebug = false;			// Set to true to see debug messages in popup window&#xD;
var disableTokens = false;		// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;	// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;	// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = true;	// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;			// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var SCRIPT_VERSION = 3.0;&#xD;
var useSA = false;&#xD;
var SA = null;&#xD;
var SAScript = null;&#xD;
var bzr = aa.bizDomain.getBizDomainByValue(&quot;MULTI_SERVICE_SETTINGS&quot;,&quot;SUPER_AGENCY_FOR_EMSE&quot;); &#xD;
if (bzr.getSuccess() &amp;&amp; bzr.getOutput().getAuditStatus() != &quot;I&quot;) { &#xD;
	useSA = true; 	&#xD;
	SA = bzr.getOutput().getDescription();&#xD;
	bzr = aa.bizDomain.getBizDomainByValue(&quot;MULTI_SERVICE_SETTINGS&quot;,&quot;SUPER_AGENCY_INCLUDE_SCRIPT&quot;); &#xD;
	if (bzr.getSuccess()) { SAScript = bzr.getOutput().getDescription(); }&#xD;
	}&#xD;
	&#xD;
if (SA) {&#xD;
	eval(getScriptText(&quot;INCLUDES_ACCELA_FUNCTIONS&quot;,SA));&#xD;
	eval(getScriptText(SAScript,SA));&#xD;
	}&#xD;
else {&#xD;
	eval(getScriptText(&quot;INCLUDES_ACCELA_FUNCTIONS&quot;));&#xD;
	}&#xD;
	&#xD;
//eval(getScriptText(&quot;INCLUDES_CUSTOM&quot;));&#xD;
&#xD;
&#xD;
&#xD;
//manually load globals specifically for this event&#xD;
&#xD;
var cancel = false;&#xD;
&#xD;
var vScriptName = aa.env.getValue(&quot;ScriptCode&quot;);&#xD;
var vEventName = aa.env.getValue(&quot;EventName&quot;);&#xD;
&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;									// Message String&#xD;
if (typeof debug === 'undefined') {&#xD;
	var debug = &quot;&quot;;										// Debug String, do not re-define if calling multiple&#xD;
	}&#xD;
var br = &quot;&lt;BR&gt;&quot;;									// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();				// invoicing pay periods&#xD;
&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;); // Current User&#xD;
var systemUserObj = null;  							// Current User Object&#xD;
var currentUserGroup = null;						// Current User Group&#xD;
var publicUserID = null;&#xD;
var publicUser = false;&#xD;
&#xD;
if (currentUserID.indexOf(&quot;PUBLICUSER&quot;) == 0){&#xD;
	publicUserID = currentUserID; &#xD;
	currentUserID = &quot;ADMIN&quot;; &#xD;
	publicUser = true;&#xD;
}&#xD;
if(currentUserID != null) {&#xD;
	systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
}&#xD;
&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var servProvCode = aa.getServiceProviderCode();&#xD;
&#xD;
logDebug(&quot;EMSE Script Framework Versions&quot;);&#xD;
logDebug(&quot;EVENT TRIGGERED: &quot; + vEventName);&#xD;
logDebug(&quot;SCRIPT EXECUTED: &quot; + vScriptName);&#xD;
//logDebug(&quot;INCLUDE VERSION: &quot; + INCLUDE_VERSION);&#xD;
logDebug(&quot;SCRIPT VERSION : &quot; + SCRIPT_VERSION);&#xD;
&#xD;
&#xD;
var prefix = lookup(&quot;EMSE_VARIABLE_BRANCH_PREFIX&quot;,vEventName);&#xD;
&#xD;
var controlFlagStdChoice = &quot;EMSE_EXECUTE_OPTIONS&quot;;&#xD;
var doStdChoices = true;  // compatibility default&#xD;
var doScripts = false;&#xD;
var bzr = aa.bizDomain.getBizDomain(controlFlagStdChoice ).getOutput().size() &gt; 0;&#xD;
if (bzr) {&#xD;
	var bvr1 = aa.bizDomain.getBizDomainByValue(controlFlagStdChoice ,&quot;STD_CHOICE&quot;);&#xD;
	doStdChoices = bvr1.getSuccess() &amp;&amp; bvr1.getOutput().getAuditStatus() != &quot;I&quot;;&#xD;
	var bvr1 = aa.bizDomain.getBizDomainByValue(controlFlagStdChoice ,&quot;SCRIPT&quot;);&#xD;
	doScripts = bvr1.getSuccess() &amp;&amp; bvr1.getOutput().getAuditStatus() != &quot;I&quot;;&#xD;
	}&#xD;
&#xD;
	&#xD;
function getScriptText(vScriptName){&#xD;
	var servProvCode = aa.getServiceProviderCode();&#xD;
	if (arguments.length &gt; 1) servProvCode = arguments[1]; // use different serv prov code&#xD;
	vScriptName = vScriptName.toUpperCase();	&#xD;
	var emseBiz = aa.proxyInvoker.newInstance(&quot;com.accela.aa.emse.emse.EMSEBusiness&quot;).getOutput();&#xD;
	try {&#xD;
		var emseScript = emseBiz.getScriptByPK(servProvCode,vScriptName,&quot;ADMIN&quot;);&#xD;
		return emseScript.getScriptText() + &quot;&quot;;	&#xD;
		} catch(err) {&#xD;
		return &quot;&quot;;&#xD;
	}&#xD;
}&#xD;
&#xD;
/*&#xD;
Functions to attach incoming email messages to a record&#xD;
*/&#xD;
function associateMessagesToRecords(messages)&#xD;
{&#xD;
	if(messages){&#xD;
		var i = 0;  var len = messages.length; &#xD;
		while(i &lt; len)&#xD;
		{&#xD;
			var message = messages[i];&#xD;
			var content = message.getTitle();&#xD;
			var cmId = message.getCmId();&#xD;
			var altId = parseAltIdFromContent(content);&#xD;
			var messageBody = message.getContent();&#xD;
			var messageModel = message.getModel();&#xD;
			var messageFrom = messageModel.getFromString();&#xD;
			var messageTo = messageModel.getToString();&#xD;
			&#xD;
			var altIdResult= new String(parseAltIdFromContent(content));&#xD;
			var altIdMatch = altIdResult.split(',');&#xD;
			logDebug(&quot;Subject: &quot; + content);&#xD;
			logDebug(&quot;Record ID from the Subject Line: &quot; + altIdMatch);&#xD;
			&#xD;
			var altId = altIdMatch[1];&#xD;
			if (altId)&#xD;
			{&#xD;
				aa.communication.associateEnities(cmId, altId, 'RECORD');&#xD;
				logDebug(&quot;Successfully associated message with Record: &quot; + altId);&#xD;
				return true;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug(&quot;Record ID not found, sending bounce back email.&quot;);&#xD;
				email(messageFrom, messageTo, bouncebackSubject + &quot;: &quot; + content, bouncebackBody + &quot;: &lt;br&gt;&lt;br&gt;&quot; + messageBody);&#xD;
				&#xD;
				if (sendDebugEmail)&#xD;
				{&#xD;
					email(debugEmailAddress, messageTo, &quot;Debug log from CommunicationReceivingEmailAfter Event Script&quot;, debug);&#xD;
				}&#xD;
						&#xD;
				return false;&#xD;
			}&#xD;
			i++;						&#xD;
		}&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function parseAltIdFromContent(content)&#xD;
{       &#xD;
		//This is just a sample.&#xD;
		//Note, please customize the RegExp for actual AlternateID.&#xD;
        var altIdFormat = /Record ID #(.*\w)+/; 		&#xD;
		var result = altIdFormat.exec(content);&#xD;
		if(result){&#xD;
			return result;&#xD;
		}&#xD;
		aa.print('No record id has been parsed from content.');&#xD;
}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
&#xD;
function logDebug(dstr) {&#xD;
	vLevel = 1&#xD;
	if (arguments.length &gt; 1)&#xD;
		vLevel = arguments[1];&#xD;
	if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
		debug += dstr + br;&#xD;
	if ((showDebug &amp; vLevel) == vLevel)&#xD;
		aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr);&#xD;
}&#xD;
&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
// Uses free-form alphanumeric indexing.   All enabled script controls will execute.   See getScriptAction_v_1_6 to revert back to sequential numbering scheme&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
	&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomain(strControl);&#xD;
	&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bizDomScriptArray = bizDomScriptResult.getOutput().toArray()&#xD;
		&#xD;
		for (var i in bizDomScriptArray)&#xD;
			{&#xD;
			// this list is sorted the same as the UI, no reason to re-sort&#xD;
			&#xD;
			var myObj= new pairObj(bizDomScriptArray[i].getBizdomainValue());&#xD;
			myObj.load(bizDomScriptArray[i].getDescription());&#xD;
			if (bizDomScriptArray[i].getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch(&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  if (dd &lt; 0) break;&#xD;
			  if (dd &gt;= 9) this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch(&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var messages = aa.env.getValue('EmailMessageList');   &#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
if (doStdChoices) doStandardChoiceActions(controlString,true,0);&#xD;
&#xD;
&#xD;
//&#xD;
//  Next, execute and scripts that are associated to the record type&#xD;
//&#xD;
&#xD;
if (doScripts) doScriptActions();&#xD;
&#xD;
aa.env.setValue(&quot;ScriptReturnCode&quot;,&quot;0&quot;);&#xD;
aa.env.setValue(&quot;ScriptReturnMessage&quot;,'The output below:');</content><initializer></initializer><title>CommunicationReceivingEmailAfterV3.0</title></script><scriptName>COMMUNICATIONRECEIVINGEMAILAFTERV3.0</scriptName></agencyEvent>
<agencyEvent><eventName>ConvertToRealCAPAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:50:40.813-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>ConvertToRealCAPAfter</name><auditModel><auditDate>2009-03-05T16:03:54-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after convert partial cap ID to real cap ID in ACA.</description></event><script><name>CONVERTTOREALCAPAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2010-08-20T14:01:44.130-06:00</auditDate><auditID>CPARKS</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: ConvertToRealCapAfter.js 4381 2009-05-29 02:05:03Z roland.vonschoech $&#xD;
| Program : ConvertToRealCapAfter1.6.js&#xD;
| Event   : ConvertToRealCapAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;ConvertToRealCapAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup = null;&#xD;
if(appTypeArray[0].substr(0,1) !=&quot;_&quot;) //Model Home Check&#xD;
{&#xD;
	var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
	if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
}&#xD;
var publicUser = false;&#xD;
if (currentUserID.indexOf(&quot;PUBLICUSER&quot;) == 0) { currentUserID = &quot;ADMIN&quot;; publicUser = true }&#xD;
var partialCap = !cap.isCompleteCap();&#xD;
&#xD;
var parentCapId = null&#xD;
var parentCapString = &quot;&quot; + aa.env.getValue(&quot;ParentCapID&quot;);&#xD;
if (parentCapString.length &gt; 0) { parentArray = parentCapString.split(&quot;-&quot;); parentCapId = aa.cap.getCapID(parentArray[0], parentArray[1], parentArray[2]).getOutput(); }&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;parentCapId = &quot; + parentCapId);&#xD;
logDebug(&quot;publicUser = &quot; + publicUser);&#xD;
logDebug(&quot;partialCap = &quot; + partialCap);&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
  &#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
    	{&#xD;
  	//  tableName is the name of the ASI table&#xD;
  	//  tableValueArray is an array of associative array values.  All elements MUST be either a string or asiTableVal object&#xD;
    	var itemCap = capId&#xD;
  	if (arguments.length &gt; 2)&#xD;
  		itemCap = arguments[2]; // use cap ID specified in args&#xD;
  &#xD;
  	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
  &#xD;
  	if (!tssmResult.getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
  &#xD;
  	var tssm = tssmResult.getOutput();&#xD;
  	var tsm = tssm.getAppSpecificTableModel();&#xD;
  	var fld = tsm.getTableField();&#xD;
        var fld_readonly = tsm.getReadonlyField(); // get Readonly field&#xD;
  &#xD;
         	for (thisrow in tableValueArray)&#xD;
  		{&#xD;
  &#xD;
  		var col = tsm.getColumns()&#xD;
  		var coli = col.iterator();&#xD;
  &#xD;
  		while (coli.hasNext())&#xD;
  			{&#xD;
  			var colname = coli.next();&#xD;
  &#xD;
			if (typeof(tableValueArray[thisrow][colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
				{&#xD;
	  			fld.add(tableValueArray[thisrow][colname.getColumnName()].fieldValue);&#xD;
	  			fld_readonly.add(tableValueArray[thisrow][colname.getColumnName()].readOnly);&#xD;
				}&#xD;
			else // we are passed a string&#xD;
				{&#xD;
  				fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
  				fld_readonly.add(null);&#xD;
				}&#xD;
  			}&#xD;
  &#xD;
  		tsm.setTableField(fld);&#xD;
  &#xD;
  		tsm.setReadonlyField(fld_readonly);&#xD;
  &#xD;
  		}&#xD;
  &#xD;
  	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
  &#xD;
  	 if (!addResult .getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
  	else&#xD;
  		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
  &#xD;
  	}&#xD;
  &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
&#xD;
function addFeeWithExtraData(fcode, fsched, fperiod, fqty, finvoice, feeCap, feeComment, UDF1, UDF2) {&#xD;
    var feeCapMessage = &quot;&quot;;&#xD;
    var feeSeq_L = new Array(); 			// invoicing fee for CAP in args&#xD;
    var paymentPeriod_L = new Array(); 		// invoicing pay periods for CAP in args&#xD;
&#xD;
    assessFeeResult = aa.finance.createFeeItem(feeCap, fsched, fcode, fperiod, fqty);&#xD;
    if (assessFeeResult.getSuccess()) {&#xD;
        feeSeq = assessFeeResult.getOutput();&#xD;
        logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
        logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
        fsm = aa.finance.getFeeItemByPK(feeCap, feeSeq).getOutput().getF4FeeItem();&#xD;
&#xD;
        if (feeComment) fsm.setFeeNotes(feeComment);&#xD;
        if (UDF1) fsm.setUdf1(UDF1);&#xD;
        if (UDF2) fsm.setUdf2(UDF2);&#xD;
&#xD;
        aa.finance.editFeeItem(fsm)&#xD;
&#xD;
&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
        {&#xD;
            feeSeqList.push(feeSeq);&#xD;
            paymentPeriodList.push(fperiod);&#xD;
        }&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
        {&#xD;
            feeSeq_L.push(feeSeq);&#xD;
            paymentPeriod_L.push(fperiod);&#xD;
            var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
            if (invoiceResult_L.getSuccess())&#xD;
                logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
            else&#xD;
                logDebug(&quot;**ERROR: Invoicing the fee items assessed was not successful.  Reason: &quot; + invoiceResult.getErrorMessage());&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
        return null;&#xD;
    }&#xD;
&#xD;
    return feeSeq;&#xD;
&#xD;
}&#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
function addParcelAndOwnerFromRefAddress(refAddress)  // optional capID&#xD;
	{&#xD;
&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	// first add the primary parcel&#xD;
	//&#xD;
	var primaryParcelResult = aa.parcel.getPrimaryParcelByRefAddressID(refAddress,&quot;Y&quot;);&#xD;
	if (primaryParcelResult.getSuccess())&#xD;
		var primaryParcel = primaryParcelResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get primary parcel for ref Address &quot; + refAddress + &quot; , &quot; + primaryParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var capParModel = aa.parcel.warpCapIdParcelModel2CapParcelModel(capId,primaryParcel).getOutput()&#xD;
&#xD;
	var createPMResult = aa.parcel.createCapParcel(capParModel);&#xD;
	if (createPMResult.getSuccess())&#xD;
		logDebug(&quot;created CAP Parcel&quot;);&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Failed to create the cap Parcel &quot; + createPMResult.getErrorMessage()); }&#xD;
&#xD;
&#xD;
	// Now the owners&#xD;
	//&#xD;
&#xD;
	var parcelListResult = aa.parcel.getParcelDailyByCapID(capId,null);&#xD;
	if (parcelListResult.getSuccess())&#xD;
		var parcelList = parcelListResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel List &quot; + parcelListResult.getErrorMessage()); return false; }&#xD;
&#xD;
&#xD;
	for (var thisP in parcelList)&#xD;
  		{&#xD;
  		var ownerListResult = aa.owner.getOwnersByParcel(parcelList[thisP]);&#xD;
		if (ownerListResult.getSuccess())&#xD;
			var ownerList = ownerListResult.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Failed to get Owner List &quot; + ownerListResult.getErrorMessage()); return false; }&#xD;
&#xD;
  		for (var thisO in ownerList)&#xD;
      			{&#xD;
      			ownerList[thisO].setCapID(capId);&#xD;
      			createOResult = aa.owner.createCapOwnerWithAPOAttribute(ownerList[thisO]);&#xD;
&#xD;
			if (createOResult.getSuccess())&#xD;
				logDebug(&quot;Created CAP Owner&quot;);&#xD;
			else&#xD;
				{ logDebug(&quot;**WARNING: Failed to create CAP Owner &quot; + createOResult.getErrorMessage()); }&#xD;
			}&#xD;
	      	}&#xD;
     }&#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
&#xD;
function addReferenceContactByName(vFirst, vMiddle, vLast)&#xD;
{&#xD;
	var userFirst = vFirst;&#xD;
	var userMiddle = vMiddle;&#xD;
	var userLast = vLast;&#xD;
&#xD;
	//Find PeopleModel object for user&#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
	//Add the reference contact record to the current CAP&#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
}&#xD;
function addressExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
	var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
	if (capAddResult.getSuccess())&#xD;
		var fcapAddressObj = capAddResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddResult.getErrorType() + &quot;:&quot; + capAddResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapAddressObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
			if (addCapCondResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements must be either a string or asiTableVal object&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	var col = tsm.getColumns();&#xD;
	var fld_readonly = tsm.getReadonlyField(); //get ReadOnly property&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
&#xD;
		if (typeof(tableValues[colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()].fieldValue);&#xD;
			fld_readonly.add(tableValues[colname.getColumnName()].readOnly);&#xD;
			}&#xD;
		else // we are passed a string&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()]);&#xD;
			fld_readonly.add(null);&#xD;
			}&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	tsm.setReadonlyField(fld_readonly); // set readonly field&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
&#xD;
function asiTableValObj(columnName, fieldValue, readOnly) {&#xD;
	this.columnName = columnName;&#xD;
	this.fieldValue = fieldValue;&#xD;
	this.readOnly = readOnly;&#xD;
&#xD;
	asiTableValObj.prototype.toString=function(){ return this.fieldValue }&#xD;
};&#xD;
&#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	}function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	}function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	}function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	}function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	function checkCapForLicensedProfessionalType( licProfType )&#xD;
{&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	&#xD;
	if( capLicenseResult.getSuccess() )&#xD;
	{ &#xD;
		var capLicenseArr = capLicenseResult.getOutput();&#xD;
		&#xD;
		if (!capLicenseArr)&#xD;
			{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
		&#xD;
		for( licProf in capLicenseArr )&#xD;
		{&#xD;
			if( licProfType.equals(capLicenseArr[licProf].getLicenseType()) )&#xD;
			{&#xD;
				aa.print( &quot;Found License Professional with Type= &quot; + licProfType );&#xD;
				return true; //Found Licensed Prof of specified type&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		return false;&#xD;
	}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
}function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
function closeSubWorkflow(thisProcessID,wfStat) // optional capId&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var isCompleted = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTaskSM = wfObj[i];&#xD;
		if (fTaskSM.getProcessID() == thisProcessID &amp;&amp; fTaskSM.getCompleteFlag() != &quot;Y&quot;)&#xD;
			{&#xD;
			logDebug(&quot;closeSubWorkflow: found an incomplete task processID #&quot; + thisProcessID + &quot; , Step# &quot; + fTaskSM.getStepNumber(),3);&#xD;
			isCompleted = false&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (!isCompleted) return false;&#xD;
&#xD;
&#xD;
	// get the parent task&#xD;
&#xD;
	var relationArray = aa.workflow.getProcessRelationByCapID(itemCap,null).getOutput()&#xD;
&#xD;
	var relRecord = null;&#xD;
&#xD;
	for (thisRel in relationArray)&#xD;
		if (relationArray[thisRel].getProcessID() == thisProcessID)&#xD;
			relRecord = relationArray[thisRel];&#xD;
&#xD;
	if (!relRecord)&#xD;
		{&#xD;
		logDebug(&quot;closeSubWorkflow: did not find a process relation, exiting&quot;,3);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	logDebug(&quot;executing handleDisposition:&quot; + relRecord.getStepNumber() + &quot;,&quot; + relRecord.getParentProcessID() + &quot;,&quot; + wfStat,3);&#xD;
&#xD;
	var handleResult = aa.workflow.handleDisposition(itemCap,relRecord.getStepNumber(),relRecord.getParentProcessID(),wfStat,sysDate,&quot;Closed via script&quot;,&quot;Closed via script&quot;,systemUserObj ,&quot;Y&quot;);&#xD;
&#xD;
	if (!handleResult.getSuccess())&#xD;
		logDebug(&quot;**WARNING: closing parent task: &quot; + handleResult.getErrorMessage());&#xD;
	else&#xD;
		logDebug(&quot;Closed parent task&quot;);&#xD;
	}&#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
function comparePeopleGeneric(peop)&#xD;
	{&#xD;
&#xD;
	// this function will be passed as a parameter to the createRefContactsFromCapContactsAndLink function.&#xD;
	//&#xD;
	// takes a single peopleModel as a parameter, and will return the sequence number of the first G6Contact result&#xD;
	//&#xD;
	// returns null if there are no matches&#xD;
	//&#xD;
	// current search method is by email only.  In order to use attributes enhancement 09ACC-05048 must be implemented&#xD;
	//&#xD;
&#xD;
	peop.setAuditDate(null)&#xD;
	peop.setAuditID(null)&#xD;
	peop.setAuditStatus(null)&#xD;
	peop.setBirthDate(null)&#xD;
	peop.setBusName2(null)&#xD;
	peop.setBusinessName(null)&#xD;
	peop.setComment(null)&#xD;
	peop.setCompactAddress(null)&#xD;
	peop.setContactSeqNumber(null)&#xD;
	peop.setContactType(null)&#xD;
	peop.setContactTypeFlag(null)&#xD;
	peop.setCountry(null)&#xD;
	peop.setCountryCode(null)&#xD;
	// peop.setEmail(null)       just as a test we are using email&#xD;
	peop.setEndBirthDate(null)&#xD;
	peop.setFax(null)&#xD;
	peop.setFaxCountryCode(null)&#xD;
	peop.setFein(null)&#xD;
	peop.setFirstName(null)&#xD;
	peop.setFlag(null)&#xD;
	peop.setFullName(null)&#xD;
	peop.setGender(null)&#xD;
	peop.setHoldCode(null)&#xD;
	peop.setHoldDescription(null)&#xD;
	peop.setId(null)&#xD;
	peop.setIvrPinNumber(null)&#xD;
	peop.setIvrUserNumber(null)&#xD;
	peop.setLastName(null)&#xD;
	peop.setMaskedSsn(null)&#xD;
	peop.setMiddleName(null)&#xD;
	peop.setNamesuffix(null)&#xD;
	peop.setPhone1(null)&#xD;
	peop.setPhone1CountryCode(null)&#xD;
	peop.setPhone2(null)&#xD;
	peop.setPhone2CountryCode(null)&#xD;
	peop.setPhone3(null)&#xD;
	peop.setPhone3CountryCode(null)&#xD;
	peop.setPostOfficeBox(null)&#xD;
	peop.setPreferredChannel(null)&#xD;
	peop.setPreferredChannelString(null)&#xD;
	peop.setRate1(null)&#xD;
	peop.setRelation(null)&#xD;
	peop.setSalutation(null)&#xD;
	peop.setServiceProviderCode(null)&#xD;
	peop.setSocialSecurityNumber(null)&#xD;
	peop.setTitle(null)&#xD;
	peop.setTradeName(null)&#xD;
&#xD;
	var r = aa.people.getPeopleByPeopleModel(peop);&#xD;
&#xD;
    if (!r.getSuccess())&#xD;
			{ logDebug(&quot;WARNING: error searching for people : &quot; + r.getErrorMessage()); return false; }&#xD;
&#xD;
	var peopResult = r.getOutput();&#xD;
&#xD;
	if (peopResult.length == 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for REF contact, no matches found, returing null&quot;);&#xD;
		return null;&#xD;
		}&#xD;
&#xD;
	if (peopResult.length &gt; 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for a REF Contact, &quot; + peopResult.length + &quot; matches found! returning the first match : &quot; + peopResult[0].getContactSeqNumber() );&#xD;
		return peopResult[0].getContactSeqNumber()&#xD;
		}&#xD;
&#xD;
}function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
}function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
function convertStringToPhone(theString)&#xD;
	{&#xD;
	var n = &quot;22233344455566677778889999&quot;;&#xD;
&#xD;
	var compString = String(theString.toUpperCase());&#xD;
	var retString = &quot;&quot;;&#xD;
&#xD;
	for (var x=0 ; x&lt; compString.length ; x++)&#xD;
   		{&#xD;
   		if (compString[x] &gt;= &quot;A&quot; &amp;&amp; compString[x] &lt;= &quot;Z&quot;)&#xD;
   			retString += n[compString.charCodeAt(x)-65]&#xD;
  		 else&#xD;
   			retString += compString[x];&#xD;
  		}&#xD;
   	return retString;&#xD;
 	}&#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
&#xD;
	//check if target CAP has primary address&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//get addresses from originating CAP&#xD;
	var capAddressResult = aa.address.getAddressWithAttributeByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddressWithAPOAttribute(vToCapId, newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	return copied;&#xD;
	}&#xD;
&#xD;
&#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional groups to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
&#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
&#xD;
function copyLicensedProf(sCapId, tCapId)&#xD;
{&#xD;
	//Function will copy all licensed professionals from source CapID to target CapID&#xD;
&#xD;
	var licProf = aa.licenseProfessional.getLicensedProfessionalsByCapID(sCapId).getOutput();&#xD;
	if (licProf != null)&#xD;
		for(x in licProf)&#xD;
		{&#xD;
			licProf[x].setCapID(tCapId);&#xD;
			aa.licenseProfessional.createLicensedProfessional(licProf[x]);&#xD;
			logDebug(&quot;Copied &quot; + licProf[x].getLicenseNbr());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;No licensed professional on source&quot;);&#xD;
}&#xD;
&#xD;
//Function will copy all owners from source CAP (sCapID) to target CAP (tCapId)&#xD;
function copyOwner(sCapID, tCapID)&#xD;
{&#xD;
	var ownrReq = aa.owner.getOwnerByCapId(sCapID);&#xD;
	if(ownrReq.getSuccess())&#xD;
	{&#xD;
		var ownrObj = ownrReq.getOutput();&#xD;
		for (xx in ownrObj)&#xD;
		{&#xD;
			ownrObj[xx].setCapID(tCapID);&#xD;
			aa.owner.createCapOwnerWithAPOAttribute(ownrObj[xx]);&#xD;
			logDebug(&quot;Copied Owner: &quot; + ownrObj[xx].getOwnerFullName())&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
		logDebug(&quot;Error Copying Owner : &quot; + ownrObj.getErrorType() + &quot; : &quot; + ownrObj.getErrorMessage());&#xD;
}&#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
&#xD;
function createCapComment(vComment)  //optional CapId&#xD;
{&#xD;
	var vCapId = capId;&#xD;
	if (arguments.length == 2)&#xD;
		vCapId = arguments[1];&#xD;
	var comDate = aa.date.getCurrentDate(); &#xD;
	var capCommentScriptModel= aa.cap.createCapCommentScriptModel(); &#xD;
	capCommentScriptModel.setCapIDModel(vCapId); &#xD;
	capCommentScriptModel.setCommentType(&quot;APP LEVEL COMMENT&quot;); &#xD;
	capCommentScriptModel.setSynopsis(&quot;&quot;); &#xD;
	capCommentScriptModel.setText(vComment); &#xD;
	capCommentScriptModel.setAuditUser(currentUserID); &#xD;
	capCommentScriptModel.setAuditStatus(&quot;A&quot;); &#xD;
	capCommentScriptModel.setAuditDate(comDate); &#xD;
	var capCommentModel=capCommentScriptModel.getCapCommentModel(); &#xD;
	aa.cap.createCapComment(capCommentModel); &#xD;
	logDebug(&quot;Comment Added&quot;);&#xD;
}function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createPublicUserFromContact()   // optional: Contact Type, default Applicant&#xD;
{&#xD;
    var contactType = &quot;Applicant&quot;;&#xD;
    var contact;&#xD;
    if (arguments.length &gt; 0) contactType = arguments[0]; // use contact type specified&#xD;
&#xD;
    var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
    if (capContactResult.getSuccess()) {&#xD;
        var Contacts = capContactResult.getOutput();&#xD;
        for (yy in Contacts) {&#xD;
            aa.print(Contacts[yy].getCapContactModel().getPeople().getContactType())&#xD;
            if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
                contact = Contacts[yy];&#xD;
        }&#xD;
    }&#xD;
&#xD;
    aa.print(contact.getEmail());&#xD;
    if (!contact)&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no such contact&quot;); return false; }&#xD;
&#xD;
    if (!contact.getEmail())&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no email address&quot;); return false; }&#xD;
&#xD;
    // check if exists already&#xD;
&#xD;
    var getUserResult = aa.publicUser.getPublicUserByEmail(contact.getEmail())&#xD;
    if (getUserResult.getSuccess()) {&#xD;
        var userModel = getUserResult.getOutput()&#xD;
        aa.print(&quot;found the user already&quot;);&#xD;
        if (userModel) return userModel;  // send back the existing user&#xD;
    }&#xD;
&#xD;
    // create a new one&#xD;
&#xD;
    var publicUser = aa.publicUser.getPublicUserModel();&#xD;
    publicUser.setFirstName(contact.getFirstName());&#xD;
    publicUser.setLastName(contact.getLastName());&#xD;
    publicUser.setEmail(contact.getEmail());&#xD;
    publicUser.setUserID(contact.getEmail());&#xD;
    publicUser.setPassword(&quot;7d3fe8b8d7ba80addfc296b07de60cc101e4af60&quot;); //password : Gary0813&#xD;
    publicUser.setAuditID(&quot;PublicUser&quot;);&#xD;
    publicUser.setAuditStatus(&quot;A&quot;);&#xD;
    publicUser.setCellPhone(contact.getCapContactModel().getPeople().getPhone2());&#xD;
&#xD;
    var result = aa.publicUser.createPublicUser(publicUser);&#xD;
&#xD;
    if (result.getSuccess()) {&#xD;
        logDebug(&quot;Created public user &quot; + contact.getEmail() + &quot;  sucessfully.&quot;);&#xD;
        var userSeqNum = result.getOutput();&#xD;
        var userModel = aa.publicUser.getPublicUser(userSeqNum).getOutput()&#xD;
&#xD;
        // create for agency&#xD;
        aa.publicUser.createPublicUserForAgency(userModel);&#xD;
&#xD;
        // activate for agency&#xD;
        var userPinBiz = aa.proxyInvoker.newInstance(&quot;com.accela.pa.pin.UserPINBusiness&quot;).getOutput()&#xD;
		userPinBiz.updateActiveStatusAndLicenseIssueDate4PublicUser(servProvCode,userSeqNum,&quot;ADMIN&quot;);&#xD;
		// reset password&#xD;
&#xD;
		var PUB = aa.proxyInvoker.newInstance(&quot;com.accela.v360.publicuser.PublicUserBusiness&quot;).getOutput()&#xD;
		PUB.resetPassword(contact.getEmail());&#xD;
&#xD;
        // send Activate email&#xD;
        aa.publicUser.sendActivateEmail(userModel, true, true);&#xD;
&#xD;
        // send another email&#xD;
        aa.publicUser.sendPasswordEmail(userModel);&#xD;
        return userModel;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**Warning creating public user &quot; + contact.getEmail() + &quot;  failure: &quot; + result.getErrorMessage()); return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
function createRefContactsFromCapContactsAndLink(pCapId, contactTypeArray, ignoreAttributeArray, replaceCapContact, overwriteRefContact, refContactExists)&#xD;
	{&#xD;
&#xD;
	// contactTypeArray is either null (all), or an array or contact types to process&#xD;
	//&#xD;
	// ignoreAttributeArray is either null (none), or an array of attributes to ignore when creating a REF contact&#xD;
	//&#xD;
	// replaceCapContact not implemented yet&#xD;
	//&#xD;
	// overwriteRefContact -- if true, will refresh linked ref contact with CAP contact data&#xD;
	//&#xD;
	// refContactExists is a function for REF contact comparisons.&#xD;
	//&#xD;
	var ingoreArray = new Array();&#xD;
	if (arguments.length &gt; 1) ignoreArray = arguments[1];&#xD;
&#xD;
	var c = aa.people.getCapContactByCapID(pCapId).getOutput()&#xD;
	var cCopy = aa.people.getCapContactByCapID(pCapId).getOutput()  // must have two working datasets&#xD;
&#xD;
	for (var i in c)&#xD;
	   {&#xD;
	   var con = c[i];&#xD;
&#xD;
	   var p = con.getPeople();&#xD;
	   &#xD;
	   if (contactTypeArray &amp;&amp; !exists(p.getContactType(),contactTypeArray))&#xD;
		continue;  // not in the contact type list.  Move along.&#xD;
&#xD;
	   &#xD;
	   var refContactNum = con.getCapContactModel().getRefContactNumber();&#xD;
	   if (refContactNum)  // This is a reference contact.   Let's refresh or overwrite as requested in parms.&#xD;
	   	{&#xD;
	   	if (overwriteRefContact)&#xD;
	   		{&#xD;
	   		p.setContactSeqNumber(refContactNum);  // set the ref seq# to refresh&#xD;
	   		&#xD;
	   		&#xD;
	   						var a = p.getAttributes();&#xD;
			&#xD;
							if (a)&#xD;
								{&#xD;
								var ai = a.iterator();&#xD;
								while (ai.hasNext())&#xD;
									{&#xD;
									var xx = ai.next();&#xD;
									xx.setContactNo(refContactNum);&#xD;
									}&#xD;
					}&#xD;
					&#xD;
					&#xD;
					&#xD;
	   		var r = aa.people.editPeopleWithAttribute(p,p.getAttributes());&#xD;
	   		&#xD;
			if (!r.getSuccess()) &#xD;
				logDebug(&quot;WARNING: couldn't refresh reference people : &quot; + r.getErrorMessage()); &#xD;
			else&#xD;
				logDebug(&quot;Successfully refreshed ref contact #&quot; + refContactNum + &quot; with CAP contact data&quot;); &#xD;
			}&#xD;
			&#xD;
	   	if (replaceCapContact)&#xD;
	   		{&#xD;
				// To Be Implemented later.   Is there a use case?&#xD;
			}&#xD;
			&#xD;
	   	}&#xD;
	   	else  // user entered the contact freehand.   Let's create or link to ref contact.&#xD;
	   	{&#xD;
			var ccmSeq = p.getContactSeqNumber();&#xD;
&#xD;
			var existingContact = refContactExists(p);  // Call the custom function to see if the REF contact exists&#xD;
&#xD;
			var p = cCopy[i].getPeople();  // get a fresh version, had to mangle the first for the search&#xD;
&#xD;
			if (existingContact)  // we found a match with our custom function.  Use this one.&#xD;
				{&#xD;
					refPeopleId = existingContact;&#xD;
				}&#xD;
			else  // did not find a match, let's create one&#xD;
				{&#xD;
&#xD;
				var a = p.getAttributes();&#xD;
&#xD;
				if (a)&#xD;
					{&#xD;
					//&#xD;
					// Clear unwanted attributes&#xD;
					var ai = a.iterator();&#xD;
					while (ai.hasNext())&#xD;
						{&#xD;
						var xx = ai.next();&#xD;
						if (ignoreAttributeArray &amp;&amp; exists(xx.getAttributeName().toUpperCase(),ignoreAttributeArray))&#xD;
							ai.remove();&#xD;
						}&#xD;
					}&#xD;
&#xD;
				var r = aa.people.createPeopleWithAttribute(p,a);&#xD;
&#xD;
				if (!r.getSuccess())&#xD;
					{logDebug(&quot;WARNING: couldn't create reference people : &quot; + r.getErrorMessage()); continue; }&#xD;
&#xD;
				//&#xD;
				// createPeople is nice and updates the sequence number to the ref seq&#xD;
				//&#xD;
&#xD;
				var p = cCopy[i].getPeople();&#xD;
				var refPeopleId = p.getContactSeqNumber();&#xD;
&#xD;
				logDebug(&quot;Successfully created reference contact #&quot; + refPeopleId);&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// now that we have the reference Id, we can link back to reference&#xD;
			//&#xD;
&#xD;
		    var ccm = aa.people.getCapContactByPK(pCapId,ccmSeq).getOutput().getCapContactModel();&#xD;
&#xD;
		    ccm.setRefContactNumber(refPeopleId);&#xD;
		    r = aa.people.editCapContact(ccm);&#xD;
&#xD;
		    if (!r.getSuccess())&#xD;
				{ logDebug(&quot;WARNING: error updating cap contact model : &quot; + r.getErrorMessage()); }&#xD;
			else&#xD;
				{ logDebug(&quot;Successfully linked ref contact &quot; + refPeopleId + &quot; to cap contact &quot; + ccmSeq);}&#xD;
&#xD;
&#xD;
	    }  // end if user hand entered contact &#xD;
	}  // end for each CAP contact&#xD;
} // end function&#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
function deactivateTask(wfstr) // optional process name&#xD;
{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
	{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
	}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
	{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
		{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
		}			&#xD;
	}&#xD;
}&#xD;
&#xD;
function deleteTask(targetCapId,deleteTaskName)&#xD;
{&#xD;
	//&#xD;
	// Get the target Task&#xD;
	//&#xD;
	var workflowResult = aa.workflow.getTasks(targetCapId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var tTask = null;&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(deleteTaskName.toUpperCase()))&#xD;
  			{&#xD;
			var tTask = wfObj[i];&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	if (!tTask)&#xD;
  	  	{ logDebug(&quot;**WARNING: Task not found: &quot; + deleteTaskName); return false; }&#xD;
&#xD;
&#xD;
	logDebug(&quot;Removing task &quot; + tTask.getTaskDescription());&#xD;
	var result = aa.workflow.removeTask(tTask)&#xD;
&#xD;
	if (!result.getSuccess())&#xD;
		{ logDebug(&quot;error &quot; + result.getErrorMessage()); return false; }&#xD;
&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	&#xD;
	itemCap = capId;&#xD;
	&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
   	&#xD;
   	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
			{&#xD;
				if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
				{&#xD;
					appspecObj[i].setChecklistComment(itemValue);&#xD;
						&#xD;
					var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
					if (actionResult.getSuccess()) &#xD;
					{							&#xD;
						logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
					} &#xD;
					else &#xD;
					{&#xD;
						logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
					}&#xD;
						&#xD;
					updated = true;&#xD;
					AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
				}&#xD;
				&#xD;
				i++;&#xD;
				&#xD;
			} // while loop&#xD;
		} // item name blank&#xD;
	} // got app specific object	&#xD;
	else&#xD;
	{ &#xD;
		logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage());&#xD;
	}&#xD;
}//End Function&#xD;
&#xD;
function editBuildingCount(numBuild) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setBuildingCount(parseFloat(numBuild));&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated building count to &quot; + numBuild); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
}function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editInspectionRequiredFlag(inspType,reqFlag)&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var result = aa.inspection.getInspMilestoneByCapID(itemCap);&#xD;
&#xD;
	if(!result.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection milestones: &quot;  + result.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspMilestones= result.getOutput();&#xD;
&#xD;
	if (!inspMilestones)&#xD;
		{ logDebug(&quot;No Inspection Milestones found&quot;) ; return false ; }&#xD;
&#xD;
	for (thisM in inspMilestones)&#xD;
		{&#xD;
		var obj= inspMilestones[thisM];&#xD;
		if (inspType.equals(obj.getInspType()))&#xD;
			{&#xD;
			if (reqFlag) obj.setInspRequired(&quot;Y&quot;);&#xD;
			else obj.setInspRequired(&quot;N&quot;);&#xD;
&#xD;
			result = aa.inspection.updateInspectionMilestone(inspMilestones);&#xD;
			if(result.getSuccess())&#xD;
				logDebug(&quot;inspection milestone updated sucessfully.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: could not update inpsection milestone &quot; +result.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	}function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editScheduledDate(scheduledDate) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	vScheduledDate = aa.date.parseDate(scheduledDate);&#xD;
	&#xD;
	//cd.setScheduledDate(vScheduledDate); //bug, doesn't work&#xD;
	cdScriptObj.setScheduledDate(vScheduledDate);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated scheduled date to &quot; + scheduledDate) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR updating scheduled date: &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = &quot;&quot; + Contacts[yy].getEmail();&#xD;
		}&#xD;
&#xD;
	if (emailAddress.indexOf(&quot;@&quot;) &gt; 0)&#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no valid email address&quot;);&#xD;
	}function endBranch() {&#xD;
	// stop execution of the current std choice&#xD;
	stopBranch = false;&#xD;
	}function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
&#xD;
function externalLP_CA(licNum,rlpType,doPopulateRef,doPopulateTrx,itemCap)&#xD;
	{&#xD;
&#xD;
	/*&#xD;
	Version: 3.2&#xD;
&#xD;
	Usage:&#xD;
&#xD;
		licNum			:  Valid CA license number.   Non-alpha, max 8 characters.  If null, function will use the LPs on the supplied CAP ID&#xD;
		rlpType			:  License professional type to use when validating and creating new LPs&#xD;
		doPopulateRef 	:  If true, will create/refresh a reference LP of this number/type&#xD;
		doPopulateTrx 	:  If true, will copy create/refreshed reference LPs to the supplied Cap ID.   doPopulateRef must be true for this to work&#xD;
		itemCap			:  If supplied, licenses on the CAP will be validated.  Also will be refreshed if doPopulateRef and doPopulateTrx are true&#xD;
&#xD;
	returns: non-null string of status codes for invalid licenses&#xD;
&#xD;
	examples:&#xD;
&#xD;
	appsubmitbefore   (will validate the LP entered, if any, and cancel the event if the LP is inactive, cancelled, expired, etc.)&#xD;
	===============&#xD;
	true ^ cslbMessage = &quot;&quot;;&#xD;
	CAELienseNumber ^ cslbMessage = externalLP_CA(CAELienseNumber,false,false,CAELienseType,null);&#xD;
	cslbMessage.length &gt; 0 ^ cancel = true ; showMessage = true ; comment(cslbMessage)&#xD;
&#xD;
	appsubmitafter  (update all CONTRACTOR LPs on the CAP and REFERENCE with data from CSLB.  Link the CAP LPs to REFERENCE.   Pop up a message if any are inactive...)&#xD;
	==============&#xD;
	true ^ 	cslbMessage = externalLP_CA(null,true,true,&quot;CONTRACTOR&quot;,capId)&#xD;
	cslbMessage.length &gt; 0 ^ showMessage = true ; comment(cslbMessage);&#xD;
&#xD;
	Note;  Custom LP Template Field Mappings can be edited in the script below&#xD;
	*/&#xD;
&#xD;
	var returnMessage = &quot;&quot;;&#xD;
&#xD;
	var workArray = new Array();&#xD;
	if (licNum)&#xD;
		workArray.push(String(licNum));&#xD;
&#xD;
	if (itemCap)&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(itemCap);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{&#xD;
			var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
		if (capLicenseArr == null || !capLicenseArr.length)&#xD;
			{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); }&#xD;
		else&#xD;
			{&#xD;
			for (var thisLic in capLicenseArr)&#xD;
				if (capLicenseArr[thisLic].getLicenseType() == rlpType)&#xD;
					workArray.push(capLicenseArr[thisLic]);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		doPopulateTrx = false; // can't do this without a CAP;&#xD;
&#xD;
	for (var thisLic = 0; thisLic &lt; workArray.length; thisLic++)&#xD;
		{&#xD;
		var licNum = workArray[thisLic];&#xD;
		var licObj = null;&#xD;
		var isObject = false;&#xD;
&#xD;
		if (typeof(licNum) == &quot;object&quot;)  // is this one an object or string?&#xD;
			{&#xD;
			licObj = licNum;&#xD;
			licNum = licObj.getLicenseNbr();&#xD;
			isObject = true;&#xD;
			}&#xD;
&#xD;
		// Make the call to the California State License Board&#xD;
&#xD;
        var saxBuilder = aa.proxyInvoker.newInstance(&quot;org.jdom.input.SAXBuilder&quot;).getOutput();&#xD;
        var aURLArgList = new Array()&#xD;
        aURLArgList[0] = &quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum;&#xD;
        var oURL = aa.proxyInvoker.newInstance(&quot;java.net.URL&quot;,aURLArgList).getOutput();&#xD;
        var document = saxBuilder.build(oURL); //(&quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum);&#xD;
        var root = document.getRootElement();&#xD;
&#xD;
		var errorNode = root.getChild(&quot;Error&quot;);&#xD;
		if (errorNode)&#xD;
			{&#xD;
			logDebug(&quot;Error for license &quot; + licNum + &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;));&#xD;
			returnMessage+=&quot;License &quot; + licNum +  &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;) + &quot; &quot;;&#xD;
			continue;&#xD;
			}&#xD;
&#xD;
		var lpBiz = root.getChild(&quot;BusinessInfo&quot;);&#xD;
		var lpStatus = root.getChild(&quot;PrimaryStatus&quot;);&#xD;
		var lpClass = root.getChild(&quot;Classifications&quot;);&#xD;
		var lpBonds = root.getChild(&quot;ContractorBond&quot;);&#xD;
		var lpWC = root.getChild(&quot;WorkersComp&quot;);&#xD;
&#xD;
		// Primary Status&#xD;
		// 3 = expired, 10 = good, 11 = inactive, 1 = canceled.   We will ignore all but 10 and return text.&#xD;
		var stas = lpStatus.getChildren();&#xD;
		for (var i=0 ; i&lt;stas.size(); i++) {&#xD;
			var sta = stas.get(i);&#xD;
&#xD;
			if (sta.getAttribute(&quot;Code&quot;).getValue() != &quot;10&quot;)&#xD;
				returnMessage+=&quot;License:&quot; + licNum + &quot;, &quot; + sta.getAttribute(&quot;Desc&quot;).getValue() + &quot; &quot;;&#xD;
		}&#xD;
&#xD;
		if (doPopulateRef)  // refresh or create a reference LP&#xD;
			{&#xD;
			var updating = false;&#xD;
&#xD;
			// check to see if the licnese already exists...if not, create.&#xD;
&#xD;
			var newLic = getRefLicenseProf(licNum)&#xD;
&#xD;
			if (newLic)&#xD;
				{&#xD;
				updating = true;&#xD;
				logDebug(&quot;Updating existing Ref Lic Prof : &quot; + licNum);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
				}&#xD;
&#xD;
			if (isObject)  // update the reference LP with data from the transactional, if we have some.&#xD;
				{&#xD;
				if (licObj.getAddress1()) newLic.setAddress1(licObj.getAddress1());&#xD;
				if (licObj.getAddress2()) newLic.setAddress2(licObj.getAddress2());&#xD;
				if (licObj.getAddress3()) newLic.setAddress3(licObj.getAddress3());&#xD;
				if (licObj.getAgencyCode()) newLic.setAgencyCode(licObj.getAgencyCode());&#xD;
				if (licObj.getBusinessLicense()) newLic.setBusinessLicense(licObj.getBusinessLicense());&#xD;
				if (licObj.getBusinessName()) newLic.setBusinessName(licObj.getBusinessName());&#xD;
				if (licObj.getBusName2()) newLic.setBusinessName2(licObj.getBusName2());&#xD;
				if (licObj.getCity()) newLic.setCity(licObj.getCity());&#xD;
				if (licObj.getCityCode()) newLic.setCityCode(licObj.getCityCode());&#xD;
				if (licObj.getContactFirstName()) newLic.setContactFirstName(licObj.getContactFirstName());&#xD;
				if (licObj.getContactLastName()) newLic.setContactLastName(licObj.getContactLastName());&#xD;
				if (licObj.getContactMiddleName()) newLic.setContactMiddleName(licObj.getContactMiddleName());&#xD;
				if (licObj.getCountryCode()) newLic.setContryCode(licObj.getCountryCode());&#xD;
				if (licObj.getEmail()) newLic.setEMailAddress(licObj.getEmail());&#xD;
				if (licObj.getCountry()) newLic.setCountry(licObj.getCountry());&#xD;
				if (licObj.getEinSs()) newLic.setEinSs(licObj.getEinSs());&#xD;
				if (licObj.getFax()) newLic.setFax(licObj.getFax());&#xD;
				if (licObj.getFaxCountryCode()) newLic.setFaxCountryCode(licObj.getFaxCountryCode());&#xD;
				if (licObj.getHoldCode()) newLic.setHoldCode(licObj.getHoldCode());&#xD;
				if (licObj.getHoldDesc()) newLic.setHoldDesc(licObj.getHoldDesc());&#xD;
				if (licObj.getLicenseExpirDate()) newLic.setLicenseExpirationDate(licObj.getLicenseExpirDate());&#xD;
				if (licObj.getLastRenewalDate()) newLic.setLicenseLastRenewalDate(licObj.getLastRenewalDate());&#xD;
				if (licObj.getLicesnseOrigIssueDate()) newLic.setLicOrigIssDate(licObj.getLicesnseOrigIssueDate());&#xD;
				if (licObj.getPhone1()) newLic.setPhone1(licObj.getPhone1());&#xD;
				if (licObj.getPhone1CountryCode()) newLic.setPhone1CountryCode(licObj.getPhone1CountryCode());&#xD;
				if (licObj.getPhone2()) newLic.setPhone2(licObj.getPhone2());&#xD;
				if (licObj.getPhone2CountryCode()) newLic.setPhone2CountryCode(licObj.getPhone2CountryCode());&#xD;
				if (licObj.getSelfIns()) newLic.setSelfIns(licObj.getSelfIns());&#xD;
				if (licObj.getState()) newLic.setState(licObj.getState());&#xD;
				if (licObj.getSuffixName()) newLic.setSuffixName(licObj.getSuffixName());&#xD;
				if (licObj.getZip()) newLic.setZip(licObj.getZip());&#xD;
				}&#xD;
&#xD;
			// Now set data from the CSLB&#xD;
&#xD;
			if (lpBiz.getChild(&quot;Name&quot;).getText() != &quot;&quot;) newLic.setBusinessName(unescape(lpBiz.getChild(&quot;Name&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr1&quot;).getText() != &quot;&quot;) newLic.setAddress1(unescape(lpBiz.getChild(&quot;Addr1&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr2&quot;).getText() != &quot;&quot;) newLic.setAddress2(unescape(lpBiz.getChild(&quot;Addr2&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;City&quot;).getText() != &quot;&quot;) newLic.setCity(unescape(lpBiz.getChild(&quot;City&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;State&quot;).getText() != &quot;&quot;) newLic.setState(unescape(lpBiz.getChild(&quot;State&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Zip&quot;).getText() != &quot;&quot;) newLic.setZip(unescape(lpBiz.getChild(&quot;Zip&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText() != &quot;&quot;) newLic.setPhone1(unescape(stripNN(lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText()).replace(/\+/g,&quot; &quot;)));&#xD;
			newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
			newLic.setAuditDate(sysDate);&#xD;
			newLic.setAuditID(currentUserID);&#xD;
			newLic.setAuditStatus(&quot;A&quot;);&#xD;
			newLic.setLicenseType(rlpType);&#xD;
			newLic.setLicState(&quot;CA&quot;);  // hardcode CA&#xD;
			newLic.setStateLicense(licNum);&#xD;
&#xD;
			if (lpBiz.getChild(&quot;IssueDt&quot;).getText()) newLic.setLicenseIssueDate(aa.date.parseDate(lpBiz.getChild(&quot;IssueDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ExpireDt&quot;).getText()) newLic.setLicenseExpirationDate(aa.date.parseDate(lpBiz.getChild(&quot;ExpireDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ReissueDt&quot;).getText()) newLic.setLicenseLastRenewalDate(aa.date.parseDate(lpBiz.getChild(&quot;ReissueDt&quot;).getText()));&#xD;
&#xD;
			var wcs = root.getChild(&quot;WorkersComp&quot;).getChildren();&#xD;
&#xD;
			for (var j=0 ; j&lt;wcs.size(); j++) {&#xD;
				wc = wcs.get(j);&#xD;
&#xD;
				if (wc.getAttribute(&quot;PolicyNo&quot;).getValue()) newLic.setWcPolicyNo(wc.getAttribute(&quot;PolicyNo&quot;).getValue());&#xD;
				if (wc.getAttribute(&quot;InsCoCde&quot;).getValue()) newLic.setWcInsCoCode(unescape(wc.getAttribute(&quot;InsCoCde&quot;).getValue()));&#xD;
				if (wc.getAttribute(&quot;WCEffDt&quot;).getValue()) newLic.setWcEffDate(aa.date.parseDate(wc.getAttribute(&quot;WCEffDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCExpDt&quot;).getValue()) newLic.setWcExpDate(aa.date.parseDate(wc.getAttribute(&quot;WCExpDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCCancDt&quot;).getValue()) newLic.setWcCancDate(aa.date.parseDate(wc.getAttribute(&quot;WCCancDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;Exempt&quot;).getValue() == &quot;E&quot;) newLic.setWcExempt(&quot;Y&quot;); else newLic.setWcExempt(&quot;N&quot;);&#xD;
&#xD;
				break; // only use first&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// Do the refresh/create and get the sequence number&#xD;
			//&#xD;
			if (updating)&#xD;
				{&#xD;
				var myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
				var licSeqNbr = newLic.getLicSeqNbr();&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
				if (!myResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;**WARNING: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
					continue;&#xD;
					}&#xD;
&#xD;
				var licSeqNbr = myResult.getOutput()&#xD;
				}&#xD;
&#xD;
			logDebug(&quot;Successfully added/updated License No. &quot; + licNum + &quot;, Type: &quot; + rlpType + &quot; Sequence Number &quot; + licSeqNbr);&#xD;
&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data -- first copy from the transactional LP if it exists&#xD;
			/////&#xD;
&#xD;
&#xD;
			if (isObject)  // update the reference LP with attributes from the transactional, if we have some.&#xD;
				{&#xD;
				var attrArray = licObj.getAttributes();&#xD;
&#xD;
				if (attrArray)&#xD;
					{&#xD;
					for (var k in attrArray)&#xD;
						{&#xD;
						var attr = attrArray[k];&#xD;
						editRefLicProfAttribute(licNum,attr.getAttributeName(),attr.getAttributeValue());&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data&#xD;
			/////&#xD;
			/////  NOTE!  Agencies may have to configure template data below based on their configuration.  Please note all edits&#xD;
			/////&#xD;
&#xD;
			var cbs = root.getChild(&quot;Classifications&quot;).getChildren();&#xD;
			for (var m=0 ; m&lt;cbs.size(); m++) {&#xD;
				cb = cbs.get(m);&#xD;
&#xD;
				if (m == 0)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 1&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 1&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 1)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 2&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 2&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				if (m == 2)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 3&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 3&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 3)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 4&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 4&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				}&#xD;
&#xD;
			var bos = root.getChild(&quot;ContractorBond&quot;).getChildren();&#xD;
&#xD;
			for (var n=0 ; n&lt;bos.size(); n++) {&#xD;
				var bo = bos.get(n);&#xD;
				if (bo.getAttribute(&quot;BondAmt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND AMOUNT&quot;,unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()));&#xD;
				if (bo.getAttribute(&quot;BondCancDt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND EXPIRATION&quot;,unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()));&#xD;
&#xD;
				// Currently unused but could be loaded into custom attributes.&#xD;
/*&#xD;
				aa.print(&quot;Bond Surety Type       : &quot; + unescape(bo.getAttribute(&quot;SuretyTp&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Code              : &quot; + unescape(bo.getAttribute(&quot;InsCoCde&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Insurance Company : &quot; + unescape(bo.getAttribute(&quot;InsCoName&quot;).getValue()).replace(/\+/g,&quot; &quot;))&#xD;
				aa.print(&quot;Bond Number            : &quot; + unescape(bo.getAttribute(&quot;BondNo&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Amount            : &quot; + unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Effective Date    : &quot; + unescape(bo.getAttribute(&quot;BondEffDt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Cancel Date       : &quot; + unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()))&#xD;
*/&#xD;
				break; // only use first bond&#xD;
				}&#xD;
&#xD;
			if (doPopulateTrx)&#xD;
				{&#xD;
				var lpsmResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,licSeqNbr)&#xD;
					if (!lpsmResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING error retrieving the LP just created &quot; + lpsmResult.getErrorMessage()) ; }&#xD;
&#xD;
				var lpsm = lpsmResult.getOutput();&#xD;
&#xD;
				// Remove from CAP&#xD;
&#xD;
				var isPrimary = false;&#xD;
&#xD;
				for (var currLic in capLicenseArr)&#xD;
					{&#xD;
					var thisLP = capLicenseArr[currLic];&#xD;
					if (thisLP.getLicenseType() == rlpType &amp;&amp; thisLP.getLicenseNbr() == licNum)&#xD;
						{&#xD;
						logDebug(&quot;Removing license: &quot; + thisLP.getLicenseNbr() + &quot; from CAP.  We will link the new reference LP&quot;);&#xD;
						if (thisLP.getPrintFlag() == &quot;Y&quot;)&#xD;
							{&#xD;
							logDebug(&quot;...remove primary status...&quot;);&#xD;
							isPrimary = true;&#xD;
							thisLP.setPrintFlag(&quot;N&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisLP);&#xD;
							}&#xD;
						var remCapResult = aa.licenseProfessional.removeLicensedProfessional(thisLP);&#xD;
						if (capLicenseResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;...Success.&quot;); }&#xD;
						else&#xD;
							{ logDebug(&quot;**WARNING removing lic prof: &quot; + remCapResult.getErrorMessage()); }&#xD;
						}&#xD;
					}&#xD;
&#xD;
				// add the LP to the CAP&#xD;
				var asCapResult= aa.licenseScript.associateLpWithCap(itemCap,lpsm)&#xD;
				if (!asCapResult.getSuccess())&#xD;
				{ logDebug(&quot;**WARNING error associating CAP to LP: &quot; + asCapResult.getErrorMessage()) }&#xD;
				else&#xD;
					{ logDebug(&quot;Associated the CAP to the new LP&quot;) }&#xD;
&#xD;
				// Now make the LP primary again&#xD;
				if (isPrimary)&#xD;
					{&#xD;
					var capLps = getLicenseProfessional(itemCap);&#xD;
&#xD;
					for (var thisCapLpNum in capLps)&#xD;
						{&#xD;
						if (capLps[thisCapLpNum].getLicenseNbr().equals(licNum))&#xD;
							{&#xD;
							var thisCapLp = capLps[thisCapLpNum];&#xD;
							thisCapLp.setPrintFlag(&quot;Y&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisCapLp);&#xD;
							logDebug(&quot;Updated primary flag on Cap LP : &quot; + licNum);&#xD;
&#xD;
							// adding this return will cause the test script to work without error, even though this is the last statement executed&#xD;
							//if (returnMessage.length &gt; 0) return returnMessage;&#xD;
							//else return null;&#xD;
&#xD;
							}&#xD;
						}&#xD;
				}&#xD;
			} // do populate on the CAP&#xD;
		} // do populate on the REF&#xD;
	} // for each license&#xD;
&#xD;
	if (returnMessage.length &gt; 0) return returnMessage;&#xD;
	else return null;&#xD;
&#xD;
} // end function&#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	}&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
function feeCopyByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			 addFee(ffeObjArr[ff].getFeeCod(),  ffeObjArr[ff].getFeeSchudle() ,  ffeObjArr[ff].getPaymentPeriod() ,  ffeObjArr[ff].getFeeUnit() ,    'Y') &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
function getChildTasks(taskName) {&#xD;
    var childTasks = new Array();&#xD;
    var childId = null;&#xD;
    var itemCap = capId&#xD;
    if (arguments.length &gt; 1)&#xD;
        itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
    var wfObj = workflowResult.getOutput();&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getTaskDescription().equals(taskName)) {&#xD;
            var relationArray = aa.workflow.getProcessRelationByCapID(itemCap, null).getOutput()&#xD;
            for (thisRel in relationArray) {&#xD;
                y = relationArray[thisRel]&#xD;
                if (y.getParentTaskName() &amp;&amp; y.getParentTaskName().equals(fTaskSM.getTaskDescription()))&#xD;
                    childId = y.getProcessID()&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getProcessID() == childId)&#xD;
            childTasks.push(fTaskSM)&#xD;
    }&#xD;
&#xD;
    return childTasks;&#xD;
&#xD;
}&#xD;
&#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0];&#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // we are in a page flow script so use the capModel to get contacts&#xD;
		{&#xD;
		capContactArray = cap.getContactsGroup().toArray() ;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var capContactArray = capContactResult.getOutput();&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	if (capContactArray)&#xD;
		{&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;middleName&quot;] = capContactArray[yy].getPeople().middleName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;&#xD;
&#xD;
			if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // using capModel to get contacts&#xD;
				var pa = capContactArray[yy].getPeople().getAttributes().toArray();&#xD;
			else&#xD;
				var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);&#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}&#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
  function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
function getLastScheduledInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector that is assigned to the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function getLicenseProfessional(itemcapId)&#xD;
{&#xD;
	capLicenseArr = null;&#xD;
	var s_result = aa.licenseProfessional.getLicenseProf(itemcapId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capLicenseArr = s_result.getOutput();&#xD;
		if (capLicenseArr == null || capLicenseArr.length == 0)&#xD;
		{&#xD;
			aa.print(&quot;WARNING: no licensed professionals on this CAP:&quot; + itemcapId);&#xD;
			capLicenseArr = null;&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to license professional: &quot; + s_result.getErrorMessage());&#xD;
		capLicenseArr = null;&#xD;
	}&#xD;
	return capLicenseArr;&#xD;
}&#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; newLicArray[thisLic] &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    }&#xD;
&#xD;
function isReadyRenew(capid) {&#xD;
    if (capid == null || aa.util.instanceOfString(capid)) {&#xD;
        return false;&#xD;
    }&#xD;
    var result = aa.expiration.isExpiredLicenses(capid);&#xD;
    if (result.getSuccess()) {&#xD;
        return true;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Failed to get expiration with CAP(&quot; + capid + &quot;): &quot; + result.getErrorMessage());&#xD;
    }&#xD;
    return false;&#xD;
}&#xD;
&#xD;
function isRenewProcess(parentCapID, partialCapID) {&#xD;
    //1. Check to see parent CAP ID is null.&#xD;
    if (parentCapID == null || partialCapID == null)&#xD;
    { logDebug(&quot;ERROR: the parentCapID or the partialCap ID is null&quot;); return false; }&#xD;
    //2. Get CAPModel by PK for partialCAP.&#xD;
    var result = aa.cap.getCap(partialCapID);&#xD;
    if (result.getSuccess()) {&#xD;
        capScriptModel = result.getOutput();&#xD;
        //2.1. Check to see if it is partial CAP.&#xD;
        if (capScriptModel.isCompleteCap()) {&#xD;
            logDebug(&quot;ERROR: It is not partial CAP(&quot; + capScriptModel.getCapID() + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Fail to get CAPModel (&quot; + partialCapID + &quot;): &quot; + result.getErrorMessage());&#xD;
        return false;&#xD;
    }&#xD;
    //3.  Check to see if the renewal was initiated before.&#xD;
    result = aa.cap.getProjectByMasterID(parentCapID, &quot;Renewal&quot;, &quot;Incomplete&quot;);&#xD;
    if (result.getSuccess()) {&#xD;
        partialProjects = result.getOutput();&#xD;
        if (partialProjects != null &amp;&amp; partialProjects.length &gt; 0) {&#xD;
            //Avoid to initiate renewal process multiple times.&#xD;
            logDebug(&quot;Warning: Renewal process was initiated before. ( &quot; + parentCapID + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
&#xD;
    }&#xD;
    //4 . Check to see if parent CAP is ready for renew.&#xD;
    return isReadyRenew(parentCapID);&#xD;
}&#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function licenseObject(licnumber)  // optional renewal Cap ID -- uses the expiration on the renewal CAP.&#xD;
	{&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
&#xD;
   	b1ExpResult = aa.expiration.getLicensesByCapID(itemCap)&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
			tmpDate = this.b1Exp.getExpDate();&#xD;
			if (tmpDate)&#xD;
				this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
			this.b1Status = this.b1Exp.getExpStatus();&#xD;
			logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + b1ExpResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function loadAddressAttributes(thisArr)&#xD;
{&#xD;
	//&#xD;
	// Returns an associative array of Address Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
   	var capAddressResult = aa.address.getAddressWithAttributeByCapId(itemCap);&#xD;
   	if (capAddressResult.getSuccess())&#xD;
   		var fcapAddressObj = capAddressResult.getOutput();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddressResult.getErrorType() + &quot;:&quot; + capAddressResult.getErrorMessage())&#xD;
&#xD;
  	for (i in fcapAddressObj)&#xD;
  	{&#xD;
  		addressAttrObj = fcapAddressObj[i].getAttributes().toArray();&#xD;
  		for (z in addressAttrObj)&#xD;
			thisArr[&quot;AddressAttribute.&quot; + addressAttrObj[z].getB1AttributeName()]=addressAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;AddressAttribute.PrimaryFlag&quot;] = fcapAddressObj[i].getPrimaryFlag();&#xD;
		thisArr[&quot;AddressAttribute.HouseNumberStart&quot;] = fcapAddressObj[i].getHouseNumberStart();&#xD;
		thisArr[&quot;AddressAttribute.StreetDirection&quot;] = fcapAddressObj[i].getStreetDirection();&#xD;
		thisArr[&quot;AddressAttribute.StreetName&quot;] = fcapAddressObj[i].getStreetName();&#xD;
		thisArr[&quot;AddressAttribute.StreetSuffix&quot;] = fcapAddressObj[i].getStreetSuffix();&#xD;
		thisArr[&quot;AddressAttribute.City&quot;] = fcapAddressObj[i].getCity();&#xD;
		thisArr[&quot;AddressAttribute.State&quot;] = fcapAddressObj[i].getState();&#xD;
		thisArr[&quot;AddressAttribute.Zip&quot;] = fcapAddressObj[i].getZip();&#xD;
		thisArr[&quot;AddressAttribute.AddressStatus&quot;] = fcapAddressObj[i].getAddressStatus();&#xD;
		thisArr[&quot;AddressAttribute.County&quot;] = fcapAddressObj[i].getCounty();&#xD;
		thisArr[&quot;AddressAttribute.Country&quot;] = fcapAddressObj[i].getCountry();&#xD;
		thisArr[&quot;AddressAttribute.AddressDescription&quot;] = fcapAddressObj[i].getAddressDescription();&#xD;
		thisArr[&quot;AddressAttribute.XCoordinate&quot;] = fcapAddressObj[i].getXCoordinator();&#xD;
		thisArr[&quot;AddressAttribute.YCoordinate&quot;] = fcapAddressObj[i].getYCoordinator();&#xD;
  	}&#xD;
}&#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
      var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		var readOnly = 'N';&#xD;
		if (readOnlyi.hasNext()) {&#xD;
			readOnly = readOnlyi.next();&#xD;
		}&#xD;
		var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
		tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
		}&#xD;
		tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	}&#xD;
&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
	  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
				}&#xD;
&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
			//tempObject[tcol.getColumnName()] = tval;&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadASITablesBefore() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	//&#xD;
&#xD;
	var gm =  aa.env.getValue(&quot;AppSpecificTableGroupModel&quot;);&#xD;
	var ta = gm.getTablesMap().values()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
		  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator();&#xD;
&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
			}&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
          eval(copyStr);  // move to table name&#xD;
&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
&#xD;
function loadGuideSheetItems(inspId) {&#xD;
	//&#xD;
	// Returns an associative array of Guide Sheet Items&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var retArray = new Array()&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var r = aa.inspection.getInspections(itemCap)&#xD;
&#xD;
	if (r.getSuccess())&#xD;
	 	{&#xD;
		var inspArray = r.getOutput();&#xD;
&#xD;
		for (i in inspArray)&#xD;
			{&#xD;
			if (inspArray[i].getIdNumber() == inspId)&#xD;
				{&#xD;
				var inspModel = inspArray[i].getInspection();&#xD;
&#xD;
				var gs = inspModel.getGuideSheets()&#xD;
&#xD;
				if (gs)&#xD;
					{&#xD;
					gsArray = gs.toArray();&#xD;
					for (var loopk in gsArray)&#xD;
						{&#xD;
						var gsItems = gsArray[loopk].getItems().toArray()&#xD;
						for (var loopi in gsItems)&#xD;
							retArray[gsItems[loopi].getGuideItemText()] = gsItems[loopi].getGuideItemStatus();&#xD;
						}&#xD;
					} // if there are guidesheets&#xD;
				else&#xD;
					logDebug(&quot;No guidesheets for this inspection&quot;);&#xD;
				} // if this is the right inspection&#xD;
			} // for each inspection&#xD;
		} // if there are inspections&#xD;
&#xD;
	logDebug(&quot;loaded &quot; + retArray.length + &quot; guidesheet items&quot;);&#xD;
	return retArray;&#xD;
	}&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + (fTask.getStatusDate().getMonth() + 1) + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
function logDebug(dstr) {&#xD;
&#xD;
    if (!aa.calendar.getNextWorkDay) {&#xD;
&#xD;
		vLevel = 1&#xD;
		if (arguments.length &gt; 1)&#xD;
			vLevel = arguments[1]&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
			debug += dstr + br;&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel)&#xD;
			aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr)&#xD;
		}&#xD;
	else {&#xD;
			debug+=dstr + br;&#xD;
		}&#xD;
&#xD;
}&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
function lookupFeesByValuationSlidingScale(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 2;&#xD;
	if (arguments.length == 4) valNumber = (arguments[3] + 1);&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
                        &#xD;
                        &#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 2)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					var divisor = workVals[1];&#xD;
					saveVal = parseInt((capval - workVals[0])/divisor);&#xD;
					if ((capval - workVals[0]) % divisor &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function prepareRenewal() {&#xD;
&#xD;
    if (isRenewProcess(parentCapId, capId)) {&#xD;
        logDebug(&quot;CAPID(&quot; + parentCapId + &quot;) is ready for renew. PartialCap (&quot; + capId + &quot;)&quot;);&#xD;
&#xD;
        //Associate partial cap with parent CAP.&#xD;
        var result = aa.cap.createRenewalCap(parentCapId, capId, true);&#xD;
        if (result.getSuccess()) {&#xD;
            // Set B1PERMIT.B1_ACCESS_BY_ACA to &quot;N&quot; for partial CAP to not allow that it is searched by ACA user.&#xD;
            aa.cap.updateAccessByACA(capId, &quot;N&quot;);&#xD;
        }&#xD;
        else&#xD;
        { logDebug(&quot;ERROR: Associate partial cap with parent CAP. &quot; + result.getErrorMessage()); return false };&#xD;
&#xD;
        return true;&#xD;
    }&#xD;
    else&#xD;
    { logDebug(&quot;Renewal Process did not finish properly&quot;); return false; }&#xD;
}&#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function removeAllFees(itemCap) // Removes all non-invoiced fee items for a CAP ID&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByCapID(itemCap);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
&#xD;
				var editResult = aa.finance.removeFeeItem(itemCap, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + feeList[feeNum].getFeeCod());&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+feeList[feeNum].getFeeCod()+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
	}&#xD;
&#xD;
	function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.removeAppSpecificTableInfos(tableName,itemCap,currentUserID)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ aa.print(&quot;**WARNING: error removing ASI table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
        else&#xD;
	logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function replaceMessageTokens(m)&#xD;
	{&#xD;
	//  tokens in pipes will attempt to interpret as script variables&#xD;
	//  tokens in curly braces will attempt to replace from AInfo (ASI, etc)&#xD;
	//&#xD;
	//  e.g.   |capId|  or |wfTask|  or |wfStatus|&#xD;
	//&#xD;
	//  e.g.   {Expiration Date}  or  {Number of Electrical Outlets}&#xD;
	//&#xD;
	//  e.g.   m = &quot;Your recent license application (|capIdString|) has successfully passed |wfTask| with a status of |wfStatus|&quot;&#xD;
&#xD;
	while (m.indexOf(&quot;|&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;|&quot;)&#xD;
	  var e = m.indexOf(&quot;|&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;typeof(&quot; + r + &quot;) != \&quot;undefined\&quot; ? &quot; + r + &quot; : \&quot;undefined\&quot;&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\|&quot; + r + &quot;\\|&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
	  }&#xD;
&#xD;
	while (m.indexOf(&quot;{&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;{&quot;)&#xD;
	  var e = m.indexOf(&quot;}&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;AInfo[\&quot;&quot; + r + &quot;\&quot;]&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\{&quot; + r + &quot;\\}&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
&#xD;
	  }&#xD;
&#xD;
	 return m&#xD;
	 }&#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID.&#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm&#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3)&#xD;
		if (arguments[2] != null)&#xD;
			{&#xD;
			var inspRes = aa.person.getUser(arguments[2]);&#xD;
			if (inspRes.getSuccess())&#xD;
				inspectorObj = inspRes.getOutput();&#xD;
			}&#xD;
&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
&#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
function stripNN(fullStr) {&#xD;
    var allowed = &quot;0123456789.&quot;;&#xD;
    var stripped = &quot;&quot;;&#xD;
    for (i = 0; i &lt; fullStr.length(); i++)&#xD;
        if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
        stripped += String.fromCharCode(fullStr.charAt(i))&#xD;
    return stripped;&#xD;
}&#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*&#xD;
DQ 09/03/2009 - Added Check to ensure Task status date is not null prior to getting status date&#xD;
Function will return false on fail&#xD;
*/&#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
	            if (fTask.getStatusDate() != null)&#xD;
	                return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
	            else&#xD;
	                { logMessage(&quot;**ERROR: NULL workflow task &quot;+fTask.getTaskDescription()+&quot; status date. &quot;); return false; }&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap, &quot;APPLICATION&quot;, stat, sysDate, cmt, systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
}&#xD;
&#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq)&#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
    // 12/22/2008 - DQ - Correct Invoice loop to accumulate instead of reset each iteration&#xD;
&#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)&#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
&#xD;
    var invFeeFound=false;&#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = adjustedQty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) )&#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
&#xD;
	return feeSeq;&#xD;
	}&#xD;
&#xD;
&#xD;
function updateRefParcelToCap() //Takes Optional CapId&#xD;
{&#xD;
	var vCapId = null;&#xD;
	if (arguments.length &gt; 0)&#xD;
		vCapId = arguments[0];&#xD;
	else&#xD;
		vCapId = capId;&#xD;
&#xD;
    var capPrclArr = aa.parcel.getParcelDailyByCapID(vCapId,null).getOutput();&#xD;
    if(capPrclArr != null)&#xD;
    {&#xD;
        for (x in capPrclArr)&#xD;
        {&#xD;
	        var prclObj = aa.parcel.getParceListForAdmin(capPrclArr[x].getParcelNumber(), null, null, null, null, null, null, null, null, null);&#xD;
	        if (prclObj.getSuccess() )&#xD;
	        {&#xD;
		        var prclArr = prclObj.getOutput();&#xD;
		        if (prclArr.length)&#xD;
		        {&#xD;
			        var prcl = prclArr[0].getParcelModel();&#xD;
			        var capPrclObj = aa.parcel.warpCapIdParcelModel2CapParcelModel(vCapId, prcl);&#xD;
&#xD;
			        if (capPrclObj.getSuccess())&#xD;
			        {&#xD;
&#xD;
				        var capPrcl = capPrclObj.getOutput();&#xD;
				        aa.parcel.updateDailyParcelWithAPOAttribute(capPrcl);	&#xD;
				        logDebug(&quot;Updated Parcel &quot; + capPrclArr[x].getParcelNumber() + &quot; with Reference Data&quot;);&#xD;
			        }&#xD;
			        else&#xD;
				        logDebug(&quot;Failed to Wrap Parcel Model for &quot; + capPrclArr[x].getParcelNumber());&#xD;
&#xD;
		        }&#xD;
		        else&#xD;
			        logDebug(&quot;No matching reference Parcels found for &quot; + capPrclArr[x].getParcelNumber());&#xD;
	        }&#xD;
	        else&#xD;
		        logDebug(&quot;Failed to get reference Parcel for &quot; + capPrclArr[x].getParcelNumber())&#xD;
	    }&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskDepartment(wfstr,wfDepartment) // optional process name&#xD;
	{&#xD;
	// Update the task assignment department&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
        var assignBureau = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[2];&#xD;
	var assignDivision = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[3];&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
        for (var i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
                if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
 			{&#xD;
			if (wfDepartment)&#xD;
				{&#xD;
				var taskUserObj = fTask.getTaskItem().getAssignedUser()&#xD;
				taskUserObj.setBureauCode(assignBureau);&#xD;
				taskUserObj.setDivisionCode(assignDivision);&#xD;
				fTask.setAssignedUser(taskUserObj);&#xD;
        			var taskItem = fTask.getTaskItem();&#xD;
&#xD;
				var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Department Set to &quot; + assignBureau);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update Department.  Invalid department : &quot; + assignBureau);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel()&#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
&#xD;
	}&#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><initializer></initializer><title>ConvertToRealCapAfter</title></script><scriptName>ConvertToRealCapAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>DocumentReviewUpdateAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-05-21T18:53:54.367-06:00</auditDate><auditID>VONSCHOECHRF</auditID><auditStatus>A</auditStatus></auditModel><event><name>DocumentReviewUpdateAfter</name><auditModel><auditDate>2012-11-15T21:21:58.340-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after update an document reviewer.</description><udf1></udf1><udf2></udf2><udf3></udf3><udf4></udf4><udf5></udf5></event><script><name>DOCUMENTREVIEWUPDATEAFTER_2_0</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-05-21T18:53:24.263-06:00</auditDate><auditID>VONSCHOECHRF</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: DocumentReviewUpdateAfter.js &#xD;
| Program : DocumentReviewUpdateAfterV2.0.js&#xD;
| Event   : DocumentReviewUpdateAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   : This Master Script uses the Productized Includes files that are deployed with the software, not the manually installed scripts.&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var controlString = &quot;DocumentReviewUpdateAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var SCRIPT_VERSION = 2.0&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var documentReviewModel = aa.env.getValue(&quot;DocumentReviewModel&quot;);&#xD;
var id1 = documentReviewModel.getID1();&#xD;
var id2 = documentReviewModel.getID2();&#xD;
var id3 = documentReviewModel.getID3();&#xD;
aa.env.setValue(&quot;PermitId1&quot;,id1);&#xD;
aa.env.setValue(&quot;PermitId2&quot;,id2);&#xD;
aa.env.setValue(&quot;PermitId3&quot;,id3);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
eval(getScriptText(&quot;INCLUDES_ACCELA_FUNCTIONS&quot;));&#xD;
eval(getScriptText(&quot;INCLUDES_ACCELA_GLOBALS&quot;));&#xD;
eval(getScriptText(&quot;INCLUDES_CUSTOM&quot;));&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
	&#xD;
function getScriptText(vScriptName){&#xD;
                vScriptName = vScriptName.toUpperCase();&#xD;
                var emseBiz = aa.proxyInvoker.newInstance(&quot;com.accela.aa.emse.emse.EMSEBusiness&quot;).getOutput();&#xD;
                var emseScript = emseBiz.getMasterScript(aa.getServiceProviderCode(),vScriptName);&#xD;
                return emseScript.getScriptText() + &quot;&quot;;&#xD;
}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
logDebug(&quot;documentReviewModel = &quot; + documentReviewModel);&#xD;
&#xD;
//values added by Lu, different names&#xD;
var wfComment = documentReviewModel.getTaskReviewComments(); logDebug(&quot;wfComment = &quot; + wfComment);&#xD;
var wfTask = documentReviewModel.getTaskName(); logDebug(&quot;wfTask = &quot; + wfTask);&#xD;
var wfStatus = documentReviewModel.getStatus(); logDebug(&quot;wfStatus = &quot; + wfStatus);&#xD;
&#xD;
//Default 'standard' values below&#xD;
var taskReviewComments = documentReviewModel.getTaskReviewComments(); logDebug(&quot;taskReviewComments = &quot; + taskReviewComments);&#xD;
var taskName = documentReviewModel.getTaskName(); logDebug(&quot;taskName = &quot; + taskName);&#xD;
var status = documentReviewModel.getStatus(); logDebug(&quot;status = &quot; + status);&#xD;
&#xD;
var wfDateMMDDYYYY = sysDateMMDDYYYY; logDebug(&quot;date = &quot; + wfDateMMDDYYYY);&#xD;
var taskReviewPages = documentReviewModel.getTaskReviewPages(); logDebug(&quot;taskReviewPages = &quot; + taskReviewPages);&#xD;
var entityType = documentReviewModel.getEntityType(); logDebug(&quot;entityType = &quot; + entityType);&#xD;
var documentID = documentReviewModel.getDocumentID(); logDebug(&quot;documentID = &quot; + documentID);&#xD;
//var wfProcess =&#xD;
&#xD;
&#xD;
var originalDocumentReviewModel = aa.env.getValue(&quot;OriginalDocumentReviewModel&quot;);	//logDebug(&quot;originalDocumentReviewModel = &quot; + originalDocumentReviewModel);&#xD;
logDebug(documentReviewModel);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/</content><title>DocumentReviewUpdateAfter_2_0</title></script><scriptName>DOCUMENTREVIEWUPDATEAFTER_2_0</scriptName></agencyEvent>
<agencyEvent><eventName>DocumentUploadAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-05T21:44:48.753-06:00</auditDate><auditID>VONSCHOECHRF</auditID><auditStatus>A</auditStatus></auditModel><event><name>DocumentUploadAfter</name><auditModel><auditDate>2009-03-05T16:14:41-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after document upload.</description></event><script><name>DOCUMENTUPLOADAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2012-11-15T21:22:34.473-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><content> var documentList = aa.env.getValue(&quot;DocumentModelList&quot;);&#xD;var templateName = &quot;DOCUMENTUPLOAD&quot;;&#xD;var from = &quot;ethan.mo@achievo.com&quot;;&#xD;var to = &quot;ethan.mo@achievo.com&quot;;&#xD;var cc = &quot;william.wang@achievo.com&quot;;&#xD;var dateFormatStr = &quot;MM/dd/yyyy hh:mm&quot;;&#xD;var entityType =&quot;LICENSEPROFESSIONAL&quot;;&#xD;&#xD;if(&quot;ACA&quot;.equals(aa.env.getValue(&quot;From&quot;)) &amp;&amp; isCorrectFile())&#xD;{&#xD;	sendMail();&#xD;}&#xD;else&#xD;{&#xD;	aa.print(&quot;Do not send mail for this file(s).&quot;);&#xD;}&#xD;&#xD;function sendMail()&#xD;{&#xD;	var fileNames = [];&#xD;	var result = aa.document.sendEmailByTemplateName(from, to, cc, templateName, getParams(), fileNames);&#xD;	if(result.getSuccess())&#xD;	{&#xD;		aa.print(&quot;Send mail success.&quot;);&#xD;	}&#xD;	else&#xD;	{&#xD;		aa.print(&quot;Send mail fail.&quot;);&#xD;	}&#xD;}&#xD;&#xD;function isCorrectFile()&#xD;{&#xD;	var validateResult = true;&#xD;	if(documentList == null)&#xD;	{&#xD;		validateResult = false;&#xD;	}&#xD;	else&#xD;	{&#xD;		for(var i=0; i&lt;documentList.size(); i++)&#xD;		{&#xD;			if(!entityType.equals(documentList.get(i).getEntityType()))&#xD;			{&#xD;				validateResult = false;&#xD;				break;&#xD;			}&#xD;		}&#xD;	}&#xD;	return validateResult&#xD;}&#xD;&#xD;function getProviderModel(providerNbr)&#xD;{&#xD;	var result = aa.licenseScript.getProviderBySeq(providerNbr);&#xD;	if(result.getSuccess())&#xD;	{&#xD;		return result.getOutput();&#xD;	}&#xD;	return null;&#xD;}&#xD;&#xD;function getParams()&#xD;{&#xD;	var params = aa.util.newHashtable();&#xD;	if(documentList != null)&#xD;	{&#xD;		addParameter(params, &quot;$$DocumentName$$&quot;, documentList.get(0).getDocName());&#xD;		addParameter(params, &quot;$$EntityID$$&quot;, documentList.get(0).getEntityID());&#xD;		addParameter(params, &quot;$$EntityType$$&quot;, documentList.get(0).getEntityType());&#xD;		addParameter(params, &quot;$$UploadDate$$&quot;, formatDate(documentList.get(0).getFileUpLoadDate() ,dateFormatStr));&#xD;	}&#xD;	return params;&#xD;}&#xD;&#xD;function formatDate(date, dateFormat)&#xD;{&#xD;	var dateStr = &quot;&quot;;&#xD;	if(date != null)&#xD;	{&#xD;		dateStr = aa.util.formatDate(date, dateFormat);&#xD;	}&#xD;	return dateStr;&#xD;}&#xD;&#xD;function addParameter(pamaremeters, key, value)&#xD;{&#xD;	if(key != null)&#xD;	{&#xD;		if(value == null)&#xD;		{&#xD;			value = &quot;&quot;;&#xD;		}&#xD;		&#xD;		pamaremeters.put(key, value);&#xD;	}&#xD;}&#xD;&#xD;function getCapIDScriptModel()&#xD;{&#xD;	return aa.cap.createCapIDScriptModel(&quot;&quot;, &quot;&quot;, &quot;&quot;);&#xD;}&#xD;&#xD;aa.env.setValue(&quot;ScriptReturnCode&quot;,&quot;0&quot;);&#xD;aa.env.setValue(&quot;ScriptReturnMessage&quot;,&quot;DocumentUploadAfter successful&quot;);&#xD;</content><title>DOCUMENTUPLOADAFTER</title></script><scriptName>DocumentUploadAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>DocumentUploadBefore</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-07-10T19:04:49.050-06:00</auditDate><auditID>VONSCHOECHRF</auditID><auditStatus>A</auditStatus></auditModel><event><name>DocumentUploadBefore</name><auditModel><auditDate>2009-03-05T16:14:41-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs before document upload.</description></event><scriptName>DocumentUploadBefore</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>FeeAssessAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:50:54.660-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>FeeAssessAfter</name><auditModel><auditDate>2002-06-19T18:12:32-06:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after the application fee is assessed.</description></event><script><name>FEEASSESSAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2011-01-12T14:34:17.553-07:00</auditDate><auditID>CPARKS</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: FeeAssessAfter.js 4781 2009-10-01 05:55:23Z roland.vonschoech $&#xD;
| Program : FeeAssessAfterV1.6.js&#xD;
| Event   : FeeAssessAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;FeeAssessAfter&quot;; 					// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup = null;&#xD;
if(appTypeArray[0].substr(0,1) !=&quot;_&quot;) //Model Home Check&#xD;
{&#xD;
	var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
	if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
}&#xD;
var publicUser = false;&#xD;
if (currentUserID.indexOf(&quot;PUBLICUSER&quot;) == 0) { currentUserID = &quot;ADMIN&quot;; publicUser = true }&#xD;
var partialCap = !cap.isCompleteCap();&#xD;
&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var FeeItemsCalculatedFeeList = aa.env.getValue(&quot;FeeItemsCalculatedFeeList&quot;);logDebug(&quot;FeeItemsCalculatedFeeList= &quot; + FeeItemsCalculatedFeeList);&#xD;
var FeeItemsList = aa.env.getValue(&quot;FeeItemsList&quot;); logDebug(&quot;FeeItemsList= &quot; + FeeItemsList);&#xD;
var FeeItemsQuantityList = aa.env.getValue(&quot;FeeItemsQuantityList&quot;);logDebug(&quot;FeeItemsQuantityList= &quot; + FeeItemsQuantityList);&#xD;
var FeeItemsTotalFeeStr = aa.env.getValue(&quot;FeeItemsTotalFee&quot;);&#xD;
var FeeItemsTotalFee = stripNN(FeeItemsTotalFeeStr); logDebug(&quot;FeeItemsTotalFee= &quot; + FeeItemsTotalFee);&#xD;
var NumberOfFeeItems = aa.env.getValue(&quot;NumberOfFeeItems&quot;); logDebug(&quot;NumberOfFeeItems= &quot; + NumberOfFeeItems);&#xD;
&#xD;
function stripNN(fullStr)&#xD;
	{&#xD;
	var allowed = &quot;0123456789.&quot;;&#xD;
	var stripped=&quot;&quot;;&#xD;
	for (i = 0; i &lt; fullStr.length() ; i++)&#xD;
		if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
			stripped+=String.fromCharCode(fullStr.charAt(i))&#xD;
	return stripped;&#xD;
	}&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
  &#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
    	{&#xD;
  	//  tableName is the name of the ASI table&#xD;
  	//  tableValueArray is an array of associative array values.  All elements MUST be either a string or asiTableVal object&#xD;
    	var itemCap = capId&#xD;
  	if (arguments.length &gt; 2)&#xD;
  		itemCap = arguments[2]; // use cap ID specified in args&#xD;
  &#xD;
  	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
  &#xD;
  	if (!tssmResult.getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
  &#xD;
  	var tssm = tssmResult.getOutput();&#xD;
  	var tsm = tssm.getAppSpecificTableModel();&#xD;
  	var fld = tsm.getTableField();&#xD;
        var fld_readonly = tsm.getReadonlyField(); // get Readonly field&#xD;
  &#xD;
         	for (thisrow in tableValueArray)&#xD;
  		{&#xD;
  &#xD;
  		var col = tsm.getColumns()&#xD;
  		var coli = col.iterator();&#xD;
  &#xD;
  		while (coli.hasNext())&#xD;
  			{&#xD;
  			var colname = coli.next();&#xD;
  &#xD;
			if (typeof(tableValueArray[thisrow][colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
				{&#xD;
	  			fld.add(tableValueArray[thisrow][colname.getColumnName()].fieldValue);&#xD;
	  			fld_readonly.add(tableValueArray[thisrow][colname.getColumnName()].readOnly);&#xD;
				}&#xD;
			else // we are passed a string&#xD;
				{&#xD;
  				fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
  				fld_readonly.add(null);&#xD;
				}&#xD;
  			}&#xD;
  &#xD;
  		tsm.setTableField(fld);&#xD;
  &#xD;
  		tsm.setReadonlyField(fld_readonly);&#xD;
  &#xD;
  		}&#xD;
  &#xD;
  	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
  &#xD;
  	 if (!addResult .getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
  	else&#xD;
  		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
  &#xD;
  	}&#xD;
  &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
&#xD;
function addFeeWithExtraData(fcode, fsched, fperiod, fqty, finvoice, feeCap, feeComment, UDF1, UDF2) {&#xD;
    var feeCapMessage = &quot;&quot;;&#xD;
    var feeSeq_L = new Array(); 			// invoicing fee for CAP in args&#xD;
    var paymentPeriod_L = new Array(); 		// invoicing pay periods for CAP in args&#xD;
&#xD;
    assessFeeResult = aa.finance.createFeeItem(feeCap, fsched, fcode, fperiod, fqty);&#xD;
    if (assessFeeResult.getSuccess()) {&#xD;
        feeSeq = assessFeeResult.getOutput();&#xD;
        logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
        logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
        fsm = aa.finance.getFeeItemByPK(feeCap, feeSeq).getOutput().getF4FeeItem();&#xD;
&#xD;
        if (feeComment) fsm.setFeeNotes(feeComment);&#xD;
        if (UDF1) fsm.setUdf1(UDF1);&#xD;
        if (UDF2) fsm.setUdf2(UDF2);&#xD;
&#xD;
        aa.finance.editFeeItem(fsm)&#xD;
&#xD;
&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
        {&#xD;
            feeSeqList.push(feeSeq);&#xD;
            paymentPeriodList.push(fperiod);&#xD;
        }&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
        {&#xD;
            feeSeq_L.push(feeSeq);&#xD;
            paymentPeriod_L.push(fperiod);&#xD;
            var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
            if (invoiceResult_L.getSuccess())&#xD;
                logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
            else&#xD;
                logDebug(&quot;**ERROR: Invoicing the fee items assessed was not successful.  Reason: &quot; + invoiceResult.getErrorMessage());&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
        return null;&#xD;
    }&#xD;
&#xD;
    return feeSeq;&#xD;
&#xD;
}&#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
function addParcelAndOwnerFromRefAddress(refAddress)  // optional capID&#xD;
	{&#xD;
&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	// first add the primary parcel&#xD;
	//&#xD;
	var primaryParcelResult = aa.parcel.getPrimaryParcelByRefAddressID(refAddress,&quot;Y&quot;);&#xD;
	if (primaryParcelResult.getSuccess())&#xD;
		var primaryParcel = primaryParcelResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get primary parcel for ref Address &quot; + refAddress + &quot; , &quot; + primaryParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var capParModel = aa.parcel.warpCapIdParcelModel2CapParcelModel(capId,primaryParcel).getOutput()&#xD;
&#xD;
	var createPMResult = aa.parcel.createCapParcel(capParModel);&#xD;
	if (createPMResult.getSuccess())&#xD;
		logDebug(&quot;created CAP Parcel&quot;);&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Failed to create the cap Parcel &quot; + createPMResult.getErrorMessage()); }&#xD;
&#xD;
&#xD;
	// Now the owners&#xD;
	//&#xD;
&#xD;
	var parcelListResult = aa.parcel.getParcelDailyByCapID(capId,null);&#xD;
	if (parcelListResult.getSuccess())&#xD;
		var parcelList = parcelListResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel List &quot; + parcelListResult.getErrorMessage()); return false; }&#xD;
&#xD;
&#xD;
	for (var thisP in parcelList)&#xD;
  		{&#xD;
  		var ownerListResult = aa.owner.getOwnersByParcel(parcelList[thisP]);&#xD;
		if (ownerListResult.getSuccess())&#xD;
			var ownerList = ownerListResult.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Failed to get Owner List &quot; + ownerListResult.getErrorMessage()); return false; }&#xD;
&#xD;
  		for (var thisO in ownerList)&#xD;
      			{&#xD;
      			ownerList[thisO].setCapID(capId);&#xD;
      			createOResult = aa.owner.createCapOwnerWithAPOAttribute(ownerList[thisO]);&#xD;
&#xD;
			if (createOResult.getSuccess())&#xD;
				logDebug(&quot;Created CAP Owner&quot;);&#xD;
			else&#xD;
				{ logDebug(&quot;**WARNING: Failed to create CAP Owner &quot; + createOResult.getErrorMessage()); }&#xD;
			}&#xD;
	      	}&#xD;
     }&#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
&#xD;
function addReferenceContactByName(vFirst, vMiddle, vLast)&#xD;
{&#xD;
	var userFirst = vFirst;&#xD;
	var userMiddle = vMiddle;&#xD;
	var userLast = vLast;&#xD;
&#xD;
	//Find PeopleModel object for user&#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
	//Add the reference contact record to the current CAP&#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
}&#xD;
function addressExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
	var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
	if (capAddResult.getSuccess())&#xD;
		var fcapAddressObj = capAddResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddResult.getErrorType() + &quot;:&quot; + capAddResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapAddressObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
			if (addCapCondResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements must be either a string or asiTableVal object&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	var col = tsm.getColumns();&#xD;
	var fld_readonly = tsm.getReadonlyField(); //get ReadOnly property&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
&#xD;
		if (typeof(tableValues[colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()].fieldValue);&#xD;
			fld_readonly.add(tableValues[colname.getColumnName()].readOnly);&#xD;
			}&#xD;
		else // we are passed a string&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()]);&#xD;
			fld_readonly.add(null);&#xD;
			}&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	tsm.setReadonlyField(fld_readonly); // set readonly field&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
&#xD;
function asiTableValObj(columnName, fieldValue, readOnly) {&#xD;
	this.columnName = columnName;&#xD;
	this.fieldValue = fieldValue;&#xD;
	this.readOnly = readOnly;&#xD;
&#xD;
	asiTableValObj.prototype.toString=function(){ return this.fieldValue }&#xD;
};&#xD;
&#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	}function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	}function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	}function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	}function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	function checkCapForLicensedProfessionalType( licProfType )&#xD;
{&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	&#xD;
	if( capLicenseResult.getSuccess() )&#xD;
	{ &#xD;
		var capLicenseArr = capLicenseResult.getOutput();&#xD;
		&#xD;
		if (!capLicenseArr)&#xD;
			{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
		&#xD;
		for( licProf in capLicenseArr )&#xD;
		{&#xD;
			if( licProfType.equals(capLicenseArr[licProf].getLicenseType()) )&#xD;
			{&#xD;
				aa.print( &quot;Found License Professional with Type= &quot; + licProfType );&#xD;
				return true; //Found Licensed Prof of specified type&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		return false;&#xD;
	}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
}function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
function closeSubWorkflow(thisProcessID,wfStat) // optional capId&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var isCompleted = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTaskSM = wfObj[i];&#xD;
		if (fTaskSM.getProcessID() == thisProcessID &amp;&amp; fTaskSM.getCompleteFlag() != &quot;Y&quot;)&#xD;
			{&#xD;
			logDebug(&quot;closeSubWorkflow: found an incomplete task processID #&quot; + thisProcessID + &quot; , Step# &quot; + fTaskSM.getStepNumber(),3);&#xD;
			isCompleted = false&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (!isCompleted) return false;&#xD;
&#xD;
&#xD;
	// get the parent task&#xD;
&#xD;
	var relationArray = aa.workflow.getProcessRelationByCapID(itemCap,null).getOutput()&#xD;
&#xD;
	var relRecord = null;&#xD;
&#xD;
	for (thisRel in relationArray)&#xD;
		if (relationArray[thisRel].getProcessID() == thisProcessID)&#xD;
			relRecord = relationArray[thisRel];&#xD;
&#xD;
	if (!relRecord)&#xD;
		{&#xD;
		logDebug(&quot;closeSubWorkflow: did not find a process relation, exiting&quot;,3);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	logDebug(&quot;executing handleDisposition:&quot; + relRecord.getStepNumber() + &quot;,&quot; + relRecord.getParentProcessID() + &quot;,&quot; + wfStat,3);&#xD;
&#xD;
	var handleResult = aa.workflow.handleDisposition(itemCap,relRecord.getStepNumber(),relRecord.getParentProcessID(),wfStat,sysDate,&quot;Closed via script&quot;,&quot;Closed via script&quot;,systemUserObj ,&quot;Y&quot;);&#xD;
&#xD;
	if (!handleResult.getSuccess())&#xD;
		logDebug(&quot;**WARNING: closing parent task: &quot; + handleResult.getErrorMessage());&#xD;
	else&#xD;
		logDebug(&quot;Closed parent task&quot;);&#xD;
	}&#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
function comparePeopleGeneric(peop)&#xD;
	{&#xD;
&#xD;
	// this function will be passed as a parameter to the createRefContactsFromCapContactsAndLink function.&#xD;
	//&#xD;
	// takes a single peopleModel as a parameter, and will return the sequence number of the first G6Contact result&#xD;
	//&#xD;
	// returns null if there are no matches&#xD;
	//&#xD;
	// current search method is by email only.  In order to use attributes enhancement 09ACC-05048 must be implemented&#xD;
	//&#xD;
&#xD;
	peop.setAuditDate(null)&#xD;
	peop.setAuditID(null)&#xD;
	peop.setAuditStatus(null)&#xD;
	peop.setBirthDate(null)&#xD;
	peop.setBusName2(null)&#xD;
	peop.setBusinessName(null)&#xD;
	peop.setComment(null)&#xD;
	peop.setCompactAddress(null)&#xD;
	peop.setContactSeqNumber(null)&#xD;
	peop.setContactType(null)&#xD;
	peop.setContactTypeFlag(null)&#xD;
	peop.setCountry(null)&#xD;
	peop.setCountryCode(null)&#xD;
	// peop.setEmail(null)       just as a test we are using email&#xD;
	peop.setEndBirthDate(null)&#xD;
	peop.setFax(null)&#xD;
	peop.setFaxCountryCode(null)&#xD;
	peop.setFein(null)&#xD;
	peop.setFirstName(null)&#xD;
	peop.setFlag(null)&#xD;
	peop.setFullName(null)&#xD;
	peop.setGender(null)&#xD;
	peop.setHoldCode(null)&#xD;
	peop.setHoldDescription(null)&#xD;
	peop.setId(null)&#xD;
	peop.setIvrPinNumber(null)&#xD;
	peop.setIvrUserNumber(null)&#xD;
	peop.setLastName(null)&#xD;
	peop.setMaskedSsn(null)&#xD;
	peop.setMiddleName(null)&#xD;
	peop.setNamesuffix(null)&#xD;
	peop.setPhone1(null)&#xD;
	peop.setPhone1CountryCode(null)&#xD;
	peop.setPhone2(null)&#xD;
	peop.setPhone2CountryCode(null)&#xD;
	peop.setPhone3(null)&#xD;
	peop.setPhone3CountryCode(null)&#xD;
	peop.setPostOfficeBox(null)&#xD;
	peop.setPreferredChannel(null)&#xD;
	peop.setPreferredChannelString(null)&#xD;
	peop.setRate1(null)&#xD;
	peop.setRelation(null)&#xD;
	peop.setSalutation(null)&#xD;
	peop.setServiceProviderCode(null)&#xD;
	peop.setSocialSecurityNumber(null)&#xD;
	peop.setTitle(null)&#xD;
	peop.setTradeName(null)&#xD;
&#xD;
	var r = aa.people.getPeopleByPeopleModel(peop);&#xD;
&#xD;
    if (!r.getSuccess())&#xD;
			{ logDebug(&quot;WARNING: error searching for people : &quot; + r.getErrorMessage()); return false; }&#xD;
&#xD;
	var peopResult = r.getOutput();&#xD;
&#xD;
	if (peopResult.length == 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for REF contact, no matches found, returing null&quot;);&#xD;
		return null;&#xD;
		}&#xD;
&#xD;
	if (peopResult.length &gt; 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for a REF Contact, &quot; + peopResult.length + &quot; matches found! returning the first match : &quot; + peopResult[0].getContactSeqNumber() );&#xD;
		return peopResult[0].getContactSeqNumber()&#xD;
		}&#xD;
&#xD;
}function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
}function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
function convertStringToPhone(theString)&#xD;
	{&#xD;
	var n = &quot;22233344455566677778889999&quot;;&#xD;
&#xD;
	var compString = String(theString.toUpperCase());&#xD;
	var retString = &quot;&quot;;&#xD;
&#xD;
	for (var x=0 ; x&lt; compString.length ; x++)&#xD;
   		{&#xD;
   		if (compString[x] &gt;= &quot;A&quot; &amp;&amp; compString[x] &lt;= &quot;Z&quot;)&#xD;
   			retString += n[compString.charCodeAt(x)-65]&#xD;
  		 else&#xD;
   			retString += compString[x];&#xD;
  		}&#xD;
   	return retString;&#xD;
 	}&#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
&#xD;
	//check if target CAP has primary address&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//get addresses from originating CAP&#xD;
	var capAddressResult = aa.address.getAddressWithAttributeByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddressWithAPOAttribute(vToCapId, newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	return copied;&#xD;
	}&#xD;
&#xD;
&#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional groups to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
&#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
&#xD;
function copyLicensedProf(sCapId, tCapId)&#xD;
{&#xD;
	//Function will copy all licensed professionals from source CapID to target CapID&#xD;
&#xD;
	var licProf = aa.licenseProfessional.getLicensedProfessionalsByCapID(sCapId).getOutput();&#xD;
	if (licProf != null)&#xD;
		for(x in licProf)&#xD;
		{&#xD;
			licProf[x].setCapID(tCapId);&#xD;
			aa.licenseProfessional.createLicensedProfessional(licProf[x]);&#xD;
			logDebug(&quot;Copied &quot; + licProf[x].getLicenseNbr());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;No licensed professional on source&quot;);&#xD;
}&#xD;
&#xD;
//Function will copy all owners from source CAP (sCapID) to target CAP (tCapId)&#xD;
function copyOwner(sCapID, tCapID)&#xD;
{&#xD;
	var ownrReq = aa.owner.getOwnerByCapId(sCapID);&#xD;
	if(ownrReq.getSuccess())&#xD;
	{&#xD;
		var ownrObj = ownrReq.getOutput();&#xD;
		for (xx in ownrObj)&#xD;
		{&#xD;
			ownrObj[xx].setCapID(tCapID);&#xD;
			aa.owner.createCapOwnerWithAPOAttribute(ownrObj[xx]);&#xD;
			logDebug(&quot;Copied Owner: &quot; + ownrObj[xx].getOwnerFullName())&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
		logDebug(&quot;Error Copying Owner : &quot; + ownrObj.getErrorType() + &quot; : &quot; + ownrObj.getErrorMessage());&#xD;
}&#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
&#xD;
function createCapComment(vComment)  //optional CapId&#xD;
{&#xD;
	var vCapId = capId;&#xD;
	if (arguments.length == 2)&#xD;
		vCapId = arguments[1];&#xD;
	var comDate = aa.date.getCurrentDate(); &#xD;
	var capCommentScriptModel= aa.cap.createCapCommentScriptModel(); &#xD;
	capCommentScriptModel.setCapIDModel(vCapId); &#xD;
	capCommentScriptModel.setCommentType(&quot;APP LEVEL COMMENT&quot;); &#xD;
	capCommentScriptModel.setSynopsis(&quot;&quot;); &#xD;
	capCommentScriptModel.setText(vComment); &#xD;
	capCommentScriptModel.setAuditUser(currentUserID); &#xD;
	capCommentScriptModel.setAuditStatus(&quot;A&quot;); &#xD;
	capCommentScriptModel.setAuditDate(comDate); &#xD;
	var capCommentModel=capCommentScriptModel.getCapCommentModel(); &#xD;
	aa.cap.createCapComment(capCommentModel); &#xD;
	logDebug(&quot;Comment Added&quot;);&#xD;
}function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createPublicUserFromContact()   // optional: Contact Type, default Applicant&#xD;
{&#xD;
    var contactType = &quot;Applicant&quot;;&#xD;
    var contact;&#xD;
    if (arguments.length &gt; 0) contactType = arguments[0]; // use contact type specified&#xD;
&#xD;
    var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
    if (capContactResult.getSuccess()) {&#xD;
        var Contacts = capContactResult.getOutput();&#xD;
        for (yy in Contacts) {&#xD;
            aa.print(Contacts[yy].getCapContactModel().getPeople().getContactType())&#xD;
            if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
                contact = Contacts[yy];&#xD;
        }&#xD;
    }&#xD;
&#xD;
    aa.print(contact.getEmail());&#xD;
    if (!contact)&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no such contact&quot;); return false; }&#xD;
&#xD;
    if (!contact.getEmail())&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no email address&quot;); return false; }&#xD;
&#xD;
    // check if exists already&#xD;
&#xD;
    var getUserResult = aa.publicUser.getPublicUserByEmail(contact.getEmail())&#xD;
    if (getUserResult.getSuccess()) {&#xD;
        var userModel = getUserResult.getOutput()&#xD;
        aa.print(&quot;found the user already&quot;);&#xD;
        if (userModel) return userModel;  // send back the existing user&#xD;
    }&#xD;
&#xD;
    // create a new one&#xD;
&#xD;
    var publicUser = aa.publicUser.getPublicUserModel();&#xD;
    publicUser.setFirstName(contact.getFirstName());&#xD;
    publicUser.setLastName(contact.getLastName());&#xD;
    publicUser.setEmail(contact.getEmail());&#xD;
    publicUser.setUserID(contact.getEmail());&#xD;
    publicUser.setPassword(&quot;7d3fe8b8d7ba80addfc296b07de60cc101e4af60&quot;); //password : Gary0813&#xD;
    publicUser.setAuditID(&quot;PublicUser&quot;);&#xD;
    publicUser.setAuditStatus(&quot;A&quot;);&#xD;
    publicUser.setCellPhone(contact.getCapContactModel().getPeople().getPhone2());&#xD;
&#xD;
    var result = aa.publicUser.createPublicUser(publicUser);&#xD;
&#xD;
    if (result.getSuccess()) {&#xD;
        logDebug(&quot;Created public user &quot; + contact.getEmail() + &quot;  sucessfully.&quot;);&#xD;
        var userSeqNum = result.getOutput();&#xD;
        var userModel = aa.publicUser.getPublicUser(userSeqNum).getOutput()&#xD;
&#xD;
        // create for agency&#xD;
        aa.publicUser.createPublicUserForAgency(userModel);&#xD;
&#xD;
        // activate for agency&#xD;
        var userPinBiz = aa.proxyInvoker.newInstance(&quot;com.accela.pa.pin.UserPINBusiness&quot;).getOutput()&#xD;
		userPinBiz.updateActiveStatusAndLicenseIssueDate4PublicUser(servProvCode,userSeqNum,&quot;ADMIN&quot;);&#xD;
		// reset password&#xD;
&#xD;
		var PUB = aa.proxyInvoker.newInstance(&quot;com.accela.v360.publicuser.PublicUserBusiness&quot;).getOutput()&#xD;
		PUB.resetPassword(contact.getEmail());&#xD;
&#xD;
        // send Activate email&#xD;
        aa.publicUser.sendActivateEmail(userModel, true, true);&#xD;
&#xD;
        // send another email&#xD;
        aa.publicUser.sendPasswordEmail(userModel);&#xD;
        return userModel;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**Warning creating public user &quot; + contact.getEmail() + &quot;  failure: &quot; + result.getErrorMessage()); return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
function createRefContactsFromCapContactsAndLink(pCapId, contactTypeArray, ignoreAttributeArray, replaceCapContact, overwriteRefContact, refContactExists)&#xD;
	{&#xD;
&#xD;
	// contactTypeArray is either null (all), or an array or contact types to process&#xD;
	//&#xD;
	// ignoreAttributeArray is either null (none), or an array of attributes to ignore when creating a REF contact&#xD;
	//&#xD;
	// replaceCapContact not implemented yet&#xD;
	//&#xD;
	// overwriteRefContact -- if true, will refresh linked ref contact with CAP contact data&#xD;
	//&#xD;
	// refContactExists is a function for REF contact comparisons.&#xD;
	//&#xD;
	var ingoreArray = new Array();&#xD;
	if (arguments.length &gt; 1) ignoreArray = arguments[1];&#xD;
&#xD;
	var c = aa.people.getCapContactByCapID(pCapId).getOutput()&#xD;
	var cCopy = aa.people.getCapContactByCapID(pCapId).getOutput()  // must have two working datasets&#xD;
&#xD;
	for (var i in c)&#xD;
	   {&#xD;
	   var con = c[i];&#xD;
&#xD;
	   var p = con.getPeople();&#xD;
	   &#xD;
	   if (contactTypeArray &amp;&amp; !exists(p.getContactType(),contactTypeArray))&#xD;
		continue;  // not in the contact type list.  Move along.&#xD;
&#xD;
	   &#xD;
	   var refContactNum = con.getCapContactModel().getRefContactNumber();&#xD;
	   if (refContactNum)  // This is a reference contact.   Let's refresh or overwrite as requested in parms.&#xD;
	   	{&#xD;
	   	if (overwriteRefContact)&#xD;
	   		{&#xD;
	   		p.setContactSeqNumber(refContactNum);  // set the ref seq# to refresh&#xD;
	   		&#xD;
	   		&#xD;
	   						var a = p.getAttributes();&#xD;
			&#xD;
							if (a)&#xD;
								{&#xD;
								var ai = a.iterator();&#xD;
								while (ai.hasNext())&#xD;
									{&#xD;
									var xx = ai.next();&#xD;
									xx.setContactNo(refContactNum);&#xD;
									}&#xD;
					}&#xD;
					&#xD;
					&#xD;
					&#xD;
	   		var r = aa.people.editPeopleWithAttribute(p,p.getAttributes());&#xD;
	   		&#xD;
			if (!r.getSuccess()) &#xD;
				logDebug(&quot;WARNING: couldn't refresh reference people : &quot; + r.getErrorMessage()); &#xD;
			else&#xD;
				logDebug(&quot;Successfully refreshed ref contact #&quot; + refContactNum + &quot; with CAP contact data&quot;); &#xD;
			}&#xD;
			&#xD;
	   	if (replaceCapContact)&#xD;
	   		{&#xD;
				// To Be Implemented later.   Is there a use case?&#xD;
			}&#xD;
			&#xD;
	   	}&#xD;
	   	else  // user entered the contact freehand.   Let's create or link to ref contact.&#xD;
	   	{&#xD;
			var ccmSeq = p.getContactSeqNumber();&#xD;
&#xD;
			var existingContact = refContactExists(p);  // Call the custom function to see if the REF contact exists&#xD;
&#xD;
			var p = cCopy[i].getPeople();  // get a fresh version, had to mangle the first for the search&#xD;
&#xD;
			if (existingContact)  // we found a match with our custom function.  Use this one.&#xD;
				{&#xD;
					refPeopleId = existingContact;&#xD;
				}&#xD;
			else  // did not find a match, let's create one&#xD;
				{&#xD;
&#xD;
				var a = p.getAttributes();&#xD;
&#xD;
				if (a)&#xD;
					{&#xD;
					//&#xD;
					// Clear unwanted attributes&#xD;
					var ai = a.iterator();&#xD;
					while (ai.hasNext())&#xD;
						{&#xD;
						var xx = ai.next();&#xD;
						if (ignoreAttributeArray &amp;&amp; exists(xx.getAttributeName().toUpperCase(),ignoreAttributeArray))&#xD;
							ai.remove();&#xD;
						}&#xD;
					}&#xD;
&#xD;
				var r = aa.people.createPeopleWithAttribute(p,a);&#xD;
&#xD;
				if (!r.getSuccess())&#xD;
					{logDebug(&quot;WARNING: couldn't create reference people : &quot; + r.getErrorMessage()); continue; }&#xD;
&#xD;
				//&#xD;
				// createPeople is nice and updates the sequence number to the ref seq&#xD;
				//&#xD;
&#xD;
				var p = cCopy[i].getPeople();&#xD;
				var refPeopleId = p.getContactSeqNumber();&#xD;
&#xD;
				logDebug(&quot;Successfully created reference contact #&quot; + refPeopleId);&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// now that we have the reference Id, we can link back to reference&#xD;
			//&#xD;
&#xD;
		    var ccm = aa.people.getCapContactByPK(pCapId,ccmSeq).getOutput().getCapContactModel();&#xD;
&#xD;
		    ccm.setRefContactNumber(refPeopleId);&#xD;
		    r = aa.people.editCapContact(ccm);&#xD;
&#xD;
		    if (!r.getSuccess())&#xD;
				{ logDebug(&quot;WARNING: error updating cap contact model : &quot; + r.getErrorMessage()); }&#xD;
			else&#xD;
				{ logDebug(&quot;Successfully linked ref contact &quot; + refPeopleId + &quot; to cap contact &quot; + ccmSeq);}&#xD;
&#xD;
&#xD;
	    }  // end if user hand entered contact &#xD;
	}  // end for each CAP contact&#xD;
} // end function&#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
function deactivateTask(wfstr) // optional process name&#xD;
{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
	{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
	}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
	{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
		{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
		}			&#xD;
	}&#xD;
}&#xD;
&#xD;
function deleteTask(targetCapId,deleteTaskName)&#xD;
{&#xD;
	//&#xD;
	// Get the target Task&#xD;
	//&#xD;
	var workflowResult = aa.workflow.getTasks(targetCapId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var tTask = null;&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(deleteTaskName.toUpperCase()))&#xD;
  			{&#xD;
			var tTask = wfObj[i];&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	if (!tTask)&#xD;
  	  	{ logDebug(&quot;**WARNING: Task not found: &quot; + deleteTaskName); return false; }&#xD;
&#xD;
&#xD;
	logDebug(&quot;Removing task &quot; + tTask.getTaskDescription());&#xD;
	var result = aa.workflow.removeTask(tTask)&#xD;
&#xD;
	if (!result.getSuccess())&#xD;
		{ logDebug(&quot;error &quot; + result.getErrorMessage()); return false; }&#xD;
&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	&#xD;
	itemCap = capId;&#xD;
	&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
   	&#xD;
   	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
			{&#xD;
				if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
				{&#xD;
					appspecObj[i].setChecklistComment(itemValue);&#xD;
						&#xD;
					var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
					if (actionResult.getSuccess()) &#xD;
					{							&#xD;
						logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
					} &#xD;
					else &#xD;
					{&#xD;
						logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
					}&#xD;
						&#xD;
					updated = true;&#xD;
					AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
				}&#xD;
				&#xD;
				i++;&#xD;
				&#xD;
			} // while loop&#xD;
		} // item name blank&#xD;
	} // got app specific object	&#xD;
	else&#xD;
	{ &#xD;
		logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage());&#xD;
	}&#xD;
}//End Function&#xD;
&#xD;
function editBuildingCount(numBuild) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setBuildingCount(parseFloat(numBuild));&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated building count to &quot; + numBuild); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
}function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editInspectionRequiredFlag(inspType,reqFlag)&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var result = aa.inspection.getInspMilestoneByCapID(itemCap);&#xD;
&#xD;
	if(!result.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection milestones: &quot;  + result.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspMilestones= result.getOutput();&#xD;
&#xD;
	if (!inspMilestones)&#xD;
		{ logDebug(&quot;No Inspection Milestones found&quot;) ; return false ; }&#xD;
&#xD;
	for (thisM in inspMilestones)&#xD;
		{&#xD;
		var obj= inspMilestones[thisM];&#xD;
		if (inspType.equals(obj.getInspType()))&#xD;
			{&#xD;
			if (reqFlag) obj.setInspRequired(&quot;Y&quot;);&#xD;
			else obj.setInspRequired(&quot;N&quot;);&#xD;
&#xD;
			result = aa.inspection.updateInspectionMilestone(inspMilestones);&#xD;
			if(result.getSuccess())&#xD;
				logDebug(&quot;inspection milestone updated sucessfully.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: could not update inpsection milestone &quot; +result.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	}function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editScheduledDate(scheduledDate) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	vScheduledDate = aa.date.parseDate(scheduledDate);&#xD;
	&#xD;
	//cd.setScheduledDate(vScheduledDate); //bug, doesn't work&#xD;
	cdScriptObj.setScheduledDate(vScheduledDate);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated scheduled date to &quot; + scheduledDate) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR updating scheduled date: &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = &quot;&quot; + Contacts[yy].getEmail();&#xD;
		}&#xD;
&#xD;
	if (emailAddress.indexOf(&quot;@&quot;) &gt; 0)&#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no valid email address&quot;);&#xD;
	}function endBranch() {&#xD;
	// stop execution of the current std choice&#xD;
	stopBranch = false;&#xD;
	}function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
&#xD;
function externalLP_CA(licNum,rlpType,doPopulateRef,doPopulateTrx,itemCap)&#xD;
	{&#xD;
&#xD;
	/*&#xD;
	Version: 3.2&#xD;
&#xD;
	Usage:&#xD;
&#xD;
		licNum			:  Valid CA license number.   Non-alpha, max 8 characters.  If null, function will use the LPs on the supplied CAP ID&#xD;
		rlpType			:  License professional type to use when validating and creating new LPs&#xD;
		doPopulateRef 	:  If true, will create/refresh a reference LP of this number/type&#xD;
		doPopulateTrx 	:  If true, will copy create/refreshed reference LPs to the supplied Cap ID.   doPopulateRef must be true for this to work&#xD;
		itemCap			:  If supplied, licenses on the CAP will be validated.  Also will be refreshed if doPopulateRef and doPopulateTrx are true&#xD;
&#xD;
	returns: non-null string of status codes for invalid licenses&#xD;
&#xD;
	examples:&#xD;
&#xD;
	appsubmitbefore   (will validate the LP entered, if any, and cancel the event if the LP is inactive, cancelled, expired, etc.)&#xD;
	===============&#xD;
	true ^ cslbMessage = &quot;&quot;;&#xD;
	CAELienseNumber ^ cslbMessage = externalLP_CA(CAELienseNumber,false,false,CAELienseType,null);&#xD;
	cslbMessage.length &gt; 0 ^ cancel = true ; showMessage = true ; comment(cslbMessage)&#xD;
&#xD;
	appsubmitafter  (update all CONTRACTOR LPs on the CAP and REFERENCE with data from CSLB.  Link the CAP LPs to REFERENCE.   Pop up a message if any are inactive...)&#xD;
	==============&#xD;
	true ^ 	cslbMessage = externalLP_CA(null,true,true,&quot;CONTRACTOR&quot;,capId)&#xD;
	cslbMessage.length &gt; 0 ^ showMessage = true ; comment(cslbMessage);&#xD;
&#xD;
	Note;  Custom LP Template Field Mappings can be edited in the script below&#xD;
	*/&#xD;
&#xD;
	var returnMessage = &quot;&quot;;&#xD;
&#xD;
	var workArray = new Array();&#xD;
	if (licNum)&#xD;
		workArray.push(String(licNum));&#xD;
&#xD;
	if (itemCap)&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(itemCap);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{&#xD;
			var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
		if (capLicenseArr == null || !capLicenseArr.length)&#xD;
			{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); }&#xD;
		else&#xD;
			{&#xD;
			for (var thisLic in capLicenseArr)&#xD;
				if (capLicenseArr[thisLic].getLicenseType() == rlpType)&#xD;
					workArray.push(capLicenseArr[thisLic]);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		doPopulateTrx = false; // can't do this without a CAP;&#xD;
&#xD;
	for (var thisLic = 0; thisLic &lt; workArray.length; thisLic++)&#xD;
		{&#xD;
		var licNum = workArray[thisLic];&#xD;
		var licObj = null;&#xD;
		var isObject = false;&#xD;
&#xD;
		if (typeof(licNum) == &quot;object&quot;)  // is this one an object or string?&#xD;
			{&#xD;
			licObj = licNum;&#xD;
			licNum = licObj.getLicenseNbr();&#xD;
			isObject = true;&#xD;
			}&#xD;
&#xD;
		// Make the call to the California State License Board&#xD;
&#xD;
        var saxBuilder = aa.proxyInvoker.newInstance(&quot;org.jdom.input.SAXBuilder&quot;).getOutput();&#xD;
        var aURLArgList = new Array()&#xD;
        aURLArgList[0] = &quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum;&#xD;
        var oURL = aa.proxyInvoker.newInstance(&quot;java.net.URL&quot;,aURLArgList).getOutput();&#xD;
        var document = saxBuilder.build(oURL); //(&quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum);&#xD;
        var root = document.getRootElement();&#xD;
&#xD;
		var errorNode = root.getChild(&quot;Error&quot;);&#xD;
		if (errorNode)&#xD;
			{&#xD;
			logDebug(&quot;Error for license &quot; + licNum + &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;));&#xD;
			returnMessage+=&quot;License &quot; + licNum +  &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;) + &quot; &quot;;&#xD;
			continue;&#xD;
			}&#xD;
&#xD;
		var lpBiz = root.getChild(&quot;BusinessInfo&quot;);&#xD;
		var lpStatus = root.getChild(&quot;PrimaryStatus&quot;);&#xD;
		var lpClass = root.getChild(&quot;Classifications&quot;);&#xD;
		var lpBonds = root.getChild(&quot;ContractorBond&quot;);&#xD;
		var lpWC = root.getChild(&quot;WorkersComp&quot;);&#xD;
&#xD;
		// Primary Status&#xD;
		// 3 = expired, 10 = good, 11 = inactive, 1 = canceled.   We will ignore all but 10 and return text.&#xD;
		var stas = lpStatus.getChildren();&#xD;
		for (var i=0 ; i&lt;stas.size(); i++) {&#xD;
			var sta = stas.get(i);&#xD;
&#xD;
			if (sta.getAttribute(&quot;Code&quot;).getValue() != &quot;10&quot;)&#xD;
				returnMessage+=&quot;License:&quot; + licNum + &quot;, &quot; + sta.getAttribute(&quot;Desc&quot;).getValue() + &quot; &quot;;&#xD;
		}&#xD;
&#xD;
		if (doPopulateRef)  // refresh or create a reference LP&#xD;
			{&#xD;
			var updating = false;&#xD;
&#xD;
			// check to see if the licnese already exists...if not, create.&#xD;
&#xD;
			var newLic = getRefLicenseProf(licNum)&#xD;
&#xD;
			if (newLic)&#xD;
				{&#xD;
				updating = true;&#xD;
				logDebug(&quot;Updating existing Ref Lic Prof : &quot; + licNum);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
				}&#xD;
&#xD;
			if (isObject)  // update the reference LP with data from the transactional, if we have some.&#xD;
				{&#xD;
				if (licObj.getAddress1()) newLic.setAddress1(licObj.getAddress1());&#xD;
				if (licObj.getAddress2()) newLic.setAddress2(licObj.getAddress2());&#xD;
				if (licObj.getAddress3()) newLic.setAddress3(licObj.getAddress3());&#xD;
				if (licObj.getAgencyCode()) newLic.setAgencyCode(licObj.getAgencyCode());&#xD;
				if (licObj.getBusinessLicense()) newLic.setBusinessLicense(licObj.getBusinessLicense());&#xD;
				if (licObj.getBusinessName()) newLic.setBusinessName(licObj.getBusinessName());&#xD;
				if (licObj.getBusName2()) newLic.setBusinessName2(licObj.getBusName2());&#xD;
				if (licObj.getCity()) newLic.setCity(licObj.getCity());&#xD;
				if (licObj.getCityCode()) newLic.setCityCode(licObj.getCityCode());&#xD;
				if (licObj.getContactFirstName()) newLic.setContactFirstName(licObj.getContactFirstName());&#xD;
				if (licObj.getContactLastName()) newLic.setContactLastName(licObj.getContactLastName());&#xD;
				if (licObj.getContactMiddleName()) newLic.setContactMiddleName(licObj.getContactMiddleName());&#xD;
				if (licObj.getCountryCode()) newLic.setContryCode(licObj.getCountryCode());&#xD;
				if (licObj.getEmail()) newLic.setEMailAddress(licObj.getEmail());&#xD;
				if (licObj.getCountry()) newLic.setCountry(licObj.getCountry());&#xD;
				if (licObj.getEinSs()) newLic.setEinSs(licObj.getEinSs());&#xD;
				if (licObj.getFax()) newLic.setFax(licObj.getFax());&#xD;
				if (licObj.getFaxCountryCode()) newLic.setFaxCountryCode(licObj.getFaxCountryCode());&#xD;
				if (licObj.getHoldCode()) newLic.setHoldCode(licObj.getHoldCode());&#xD;
				if (licObj.getHoldDesc()) newLic.setHoldDesc(licObj.getHoldDesc());&#xD;
				if (licObj.getLicenseExpirDate()) newLic.setLicenseExpirationDate(licObj.getLicenseExpirDate());&#xD;
				if (licObj.getLastRenewalDate()) newLic.setLicenseLastRenewalDate(licObj.getLastRenewalDate());&#xD;
				if (licObj.getLicesnseOrigIssueDate()) newLic.setLicOrigIssDate(licObj.getLicesnseOrigIssueDate());&#xD;
				if (licObj.getPhone1()) newLic.setPhone1(licObj.getPhone1());&#xD;
				if (licObj.getPhone1CountryCode()) newLic.setPhone1CountryCode(licObj.getPhone1CountryCode());&#xD;
				if (licObj.getPhone2()) newLic.setPhone2(licObj.getPhone2());&#xD;
				if (licObj.getPhone2CountryCode()) newLic.setPhone2CountryCode(licObj.getPhone2CountryCode());&#xD;
				if (licObj.getSelfIns()) newLic.setSelfIns(licObj.getSelfIns());&#xD;
				if (licObj.getState()) newLic.setState(licObj.getState());&#xD;
				if (licObj.getSuffixName()) newLic.setSuffixName(licObj.getSuffixName());&#xD;
				if (licObj.getZip()) newLic.setZip(licObj.getZip());&#xD;
				}&#xD;
&#xD;
			// Now set data from the CSLB&#xD;
&#xD;
			if (lpBiz.getChild(&quot;Name&quot;).getText() != &quot;&quot;) newLic.setBusinessName(unescape(lpBiz.getChild(&quot;Name&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr1&quot;).getText() != &quot;&quot;) newLic.setAddress1(unescape(lpBiz.getChild(&quot;Addr1&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr2&quot;).getText() != &quot;&quot;) newLic.setAddress2(unescape(lpBiz.getChild(&quot;Addr2&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;City&quot;).getText() != &quot;&quot;) newLic.setCity(unescape(lpBiz.getChild(&quot;City&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;State&quot;).getText() != &quot;&quot;) newLic.setState(unescape(lpBiz.getChild(&quot;State&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Zip&quot;).getText() != &quot;&quot;) newLic.setZip(unescape(lpBiz.getChild(&quot;Zip&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText() != &quot;&quot;) newLic.setPhone1(unescape(stripNN(lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText()).replace(/\+/g,&quot; &quot;)));&#xD;
			newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
			newLic.setAuditDate(sysDate);&#xD;
			newLic.setAuditID(currentUserID);&#xD;
			newLic.setAuditStatus(&quot;A&quot;);&#xD;
			newLic.setLicenseType(rlpType);&#xD;
			newLic.setLicState(&quot;CA&quot;);  // hardcode CA&#xD;
			newLic.setStateLicense(licNum);&#xD;
&#xD;
			if (lpBiz.getChild(&quot;IssueDt&quot;).getText()) newLic.setLicenseIssueDate(aa.date.parseDate(lpBiz.getChild(&quot;IssueDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ExpireDt&quot;).getText()) newLic.setLicenseExpirationDate(aa.date.parseDate(lpBiz.getChild(&quot;ExpireDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ReissueDt&quot;).getText()) newLic.setLicenseLastRenewalDate(aa.date.parseDate(lpBiz.getChild(&quot;ReissueDt&quot;).getText()));&#xD;
&#xD;
			var wcs = root.getChild(&quot;WorkersComp&quot;).getChildren();&#xD;
&#xD;
			for (var j=0 ; j&lt;wcs.size(); j++) {&#xD;
				wc = wcs.get(j);&#xD;
&#xD;
				if (wc.getAttribute(&quot;PolicyNo&quot;).getValue()) newLic.setWcPolicyNo(wc.getAttribute(&quot;PolicyNo&quot;).getValue());&#xD;
				if (wc.getAttribute(&quot;InsCoCde&quot;).getValue()) newLic.setWcInsCoCode(unescape(wc.getAttribute(&quot;InsCoCde&quot;).getValue()));&#xD;
				if (wc.getAttribute(&quot;WCEffDt&quot;).getValue()) newLic.setWcEffDate(aa.date.parseDate(wc.getAttribute(&quot;WCEffDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCExpDt&quot;).getValue()) newLic.setWcExpDate(aa.date.parseDate(wc.getAttribute(&quot;WCExpDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCCancDt&quot;).getValue()) newLic.setWcCancDate(aa.date.parseDate(wc.getAttribute(&quot;WCCancDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;Exempt&quot;).getValue() == &quot;E&quot;) newLic.setWcExempt(&quot;Y&quot;); else newLic.setWcExempt(&quot;N&quot;);&#xD;
&#xD;
				break; // only use first&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// Do the refresh/create and get the sequence number&#xD;
			//&#xD;
			if (updating)&#xD;
				{&#xD;
				var myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
				var licSeqNbr = newLic.getLicSeqNbr();&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
				if (!myResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;**WARNING: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
					continue;&#xD;
					}&#xD;
&#xD;
				var licSeqNbr = myResult.getOutput()&#xD;
				}&#xD;
&#xD;
			logDebug(&quot;Successfully added/updated License No. &quot; + licNum + &quot;, Type: &quot; + rlpType + &quot; Sequence Number &quot; + licSeqNbr);&#xD;
&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data -- first copy from the transactional LP if it exists&#xD;
			/////&#xD;
&#xD;
&#xD;
			if (isObject)  // update the reference LP with attributes from the transactional, if we have some.&#xD;
				{&#xD;
				var attrArray = licObj.getAttributes();&#xD;
&#xD;
				if (attrArray)&#xD;
					{&#xD;
					for (var k in attrArray)&#xD;
						{&#xD;
						var attr = attrArray[k];&#xD;
						editRefLicProfAttribute(licNum,attr.getAttributeName(),attr.getAttributeValue());&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data&#xD;
			/////&#xD;
			/////  NOTE!  Agencies may have to configure template data below based on their configuration.  Please note all edits&#xD;
			/////&#xD;
&#xD;
			var cbs = root.getChild(&quot;Classifications&quot;).getChildren();&#xD;
			for (var m=0 ; m&lt;cbs.size(); m++) {&#xD;
				cb = cbs.get(m);&#xD;
&#xD;
				if (m == 0)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 1&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 1&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 1)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 2&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 2&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				if (m == 2)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 3&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 3&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 3)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 4&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 4&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				}&#xD;
&#xD;
			var bos = root.getChild(&quot;ContractorBond&quot;).getChildren();&#xD;
&#xD;
			for (var n=0 ; n&lt;bos.size(); n++) {&#xD;
				var bo = bos.get(n);&#xD;
				if (bo.getAttribute(&quot;BondAmt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND AMOUNT&quot;,unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()));&#xD;
				if (bo.getAttribute(&quot;BondCancDt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND EXPIRATION&quot;,unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()));&#xD;
&#xD;
				// Currently unused but could be loaded into custom attributes.&#xD;
/*&#xD;
				aa.print(&quot;Bond Surety Type       : &quot; + unescape(bo.getAttribute(&quot;SuretyTp&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Code              : &quot; + unescape(bo.getAttribute(&quot;InsCoCde&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Insurance Company : &quot; + unescape(bo.getAttribute(&quot;InsCoName&quot;).getValue()).replace(/\+/g,&quot; &quot;))&#xD;
				aa.print(&quot;Bond Number            : &quot; + unescape(bo.getAttribute(&quot;BondNo&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Amount            : &quot; + unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Effective Date    : &quot; + unescape(bo.getAttribute(&quot;BondEffDt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Cancel Date       : &quot; + unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()))&#xD;
*/&#xD;
				break; // only use first bond&#xD;
				}&#xD;
&#xD;
			if (doPopulateTrx)&#xD;
				{&#xD;
				var lpsmResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,licSeqNbr)&#xD;
					if (!lpsmResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING error retrieving the LP just created &quot; + lpsmResult.getErrorMessage()) ; }&#xD;
&#xD;
				var lpsm = lpsmResult.getOutput();&#xD;
&#xD;
				// Remove from CAP&#xD;
&#xD;
				var isPrimary = false;&#xD;
&#xD;
				for (var currLic in capLicenseArr)&#xD;
					{&#xD;
					var thisLP = capLicenseArr[currLic];&#xD;
					if (thisLP.getLicenseType() == rlpType &amp;&amp; thisLP.getLicenseNbr() == licNum)&#xD;
						{&#xD;
						logDebug(&quot;Removing license: &quot; + thisLP.getLicenseNbr() + &quot; from CAP.  We will link the new reference LP&quot;);&#xD;
						if (thisLP.getPrintFlag() == &quot;Y&quot;)&#xD;
							{&#xD;
							logDebug(&quot;...remove primary status...&quot;);&#xD;
							isPrimary = true;&#xD;
							thisLP.setPrintFlag(&quot;N&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisLP);&#xD;
							}&#xD;
						var remCapResult = aa.licenseProfessional.removeLicensedProfessional(thisLP);&#xD;
						if (capLicenseResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;...Success.&quot;); }&#xD;
						else&#xD;
							{ logDebug(&quot;**WARNING removing lic prof: &quot; + remCapResult.getErrorMessage()); }&#xD;
						}&#xD;
					}&#xD;
&#xD;
				// add the LP to the CAP&#xD;
				var asCapResult= aa.licenseScript.associateLpWithCap(itemCap,lpsm)&#xD;
				if (!asCapResult.getSuccess())&#xD;
				{ logDebug(&quot;**WARNING error associating CAP to LP: &quot; + asCapResult.getErrorMessage()) }&#xD;
				else&#xD;
					{ logDebug(&quot;Associated the CAP to the new LP&quot;) }&#xD;
&#xD;
				// Now make the LP primary again&#xD;
				if (isPrimary)&#xD;
					{&#xD;
					var capLps = getLicenseProfessional(itemCap);&#xD;
&#xD;
					for (var thisCapLpNum in capLps)&#xD;
						{&#xD;
						if (capLps[thisCapLpNum].getLicenseNbr().equals(licNum))&#xD;
							{&#xD;
							var thisCapLp = capLps[thisCapLpNum];&#xD;
							thisCapLp.setPrintFlag(&quot;Y&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisCapLp);&#xD;
							logDebug(&quot;Updated primary flag on Cap LP : &quot; + licNum);&#xD;
&#xD;
							// adding this return will cause the test script to work without error, even though this is the last statement executed&#xD;
							//if (returnMessage.length &gt; 0) return returnMessage;&#xD;
							//else return null;&#xD;
&#xD;
							}&#xD;
						}&#xD;
				}&#xD;
			} // do populate on the CAP&#xD;
		} // do populate on the REF&#xD;
	} // for each license&#xD;
&#xD;
	if (returnMessage.length &gt; 0) return returnMessage;&#xD;
	else return null;&#xD;
&#xD;
} // end function&#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	}&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
function feeCopyByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			 addFee(ffeObjArr[ff].getFeeCod(),  ffeObjArr[ff].getFeeSchudle() ,  ffeObjArr[ff].getPaymentPeriod() ,  ffeObjArr[ff].getFeeUnit() ,    'Y') &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
function getChildTasks(taskName) {&#xD;
    var childTasks = new Array();&#xD;
    var childId = null;&#xD;
    var itemCap = capId&#xD;
    if (arguments.length &gt; 1)&#xD;
        itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
    var wfObj = workflowResult.getOutput();&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getTaskDescription().equals(taskName)) {&#xD;
            var relationArray = aa.workflow.getProcessRelationByCapID(itemCap, null).getOutput()&#xD;
            for (thisRel in relationArray) {&#xD;
                y = relationArray[thisRel]&#xD;
                if (y.getParentTaskName() &amp;&amp; y.getParentTaskName().equals(fTaskSM.getTaskDescription()))&#xD;
                    childId = y.getProcessID()&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getProcessID() == childId)&#xD;
            childTasks.push(fTaskSM)&#xD;
    }&#xD;
&#xD;
    return childTasks;&#xD;
&#xD;
}&#xD;
&#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0];&#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // we are in a page flow script so use the capModel to get contacts&#xD;
		{&#xD;
		capContactArray = cap.getContactsGroup().toArray() ;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var capContactArray = capContactResult.getOutput();&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	if (capContactArray)&#xD;
		{&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;middleName&quot;] = capContactArray[yy].getPeople().middleName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;&#xD;
&#xD;
			if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // using capModel to get contacts&#xD;
				var pa = capContactArray[yy].getPeople().getAttributes().toArray();&#xD;
			else&#xD;
				var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);&#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}&#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
  function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
function getLastScheduledInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector that is assigned to the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function getLicenseProfessional(itemcapId)&#xD;
{&#xD;
	capLicenseArr = null;&#xD;
	var s_result = aa.licenseProfessional.getLicenseProf(itemcapId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capLicenseArr = s_result.getOutput();&#xD;
		if (capLicenseArr == null || capLicenseArr.length == 0)&#xD;
		{&#xD;
			aa.print(&quot;WARNING: no licensed professionals on this CAP:&quot; + itemcapId);&#xD;
			capLicenseArr = null;&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to license professional: &quot; + s_result.getErrorMessage());&#xD;
		capLicenseArr = null;&#xD;
	}&#xD;
	return capLicenseArr;&#xD;
}&#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; newLicArray[thisLic] &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    }&#xD;
&#xD;
function isReadyRenew(capid) {&#xD;
    if (capid == null || aa.util.instanceOfString(capid)) {&#xD;
        return false;&#xD;
    }&#xD;
    var result = aa.expiration.isExpiredLicenses(capid);&#xD;
    if (result.getSuccess()) {&#xD;
        return true;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Failed to get expiration with CAP(&quot; + capid + &quot;): &quot; + result.getErrorMessage());&#xD;
    }&#xD;
    return false;&#xD;
}&#xD;
&#xD;
function isRenewProcess(parentCapID, partialCapID) {&#xD;
    //1. Check to see parent CAP ID is null.&#xD;
    if (parentCapID == null || partialCapID == null)&#xD;
    { logDebug(&quot;ERROR: the parentCapID or the partialCap ID is null&quot;); return false; }&#xD;
    //2. Get CAPModel by PK for partialCAP.&#xD;
    var result = aa.cap.getCap(partialCapID);&#xD;
    if (result.getSuccess()) {&#xD;
        capScriptModel = result.getOutput();&#xD;
        //2.1. Check to see if it is partial CAP.&#xD;
        if (capScriptModel.isCompleteCap()) {&#xD;
            logDebug(&quot;ERROR: It is not partial CAP(&quot; + capScriptModel.getCapID() + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Fail to get CAPModel (&quot; + partialCapID + &quot;): &quot; + result.getErrorMessage());&#xD;
        return false;&#xD;
    }&#xD;
    //3.  Check to see if the renewal was initiated before.&#xD;
    result = aa.cap.getProjectByMasterID(parentCapID, &quot;Renewal&quot;, &quot;Incomplete&quot;);&#xD;
    if (result.getSuccess()) {&#xD;
        partialProjects = result.getOutput();&#xD;
        if (partialProjects != null &amp;&amp; partialProjects.length &gt; 0) {&#xD;
            //Avoid to initiate renewal process multiple times.&#xD;
            logDebug(&quot;Warning: Renewal process was initiated before. ( &quot; + parentCapID + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
&#xD;
    }&#xD;
    //4 . Check to see if parent CAP is ready for renew.&#xD;
    return isReadyRenew(parentCapID);&#xD;
}&#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function licenseObject(licnumber)  // optional renewal Cap ID -- uses the expiration on the renewal CAP.&#xD;
	{&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
&#xD;
   	b1ExpResult = aa.expiration.getLicensesByCapID(itemCap)&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
			tmpDate = this.b1Exp.getExpDate();&#xD;
			if (tmpDate)&#xD;
				this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
			this.b1Status = this.b1Exp.getExpStatus();&#xD;
			logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + b1ExpResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function loadAddressAttributes(thisArr)&#xD;
{&#xD;
	//&#xD;
	// Returns an associative array of Address Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
   	var capAddressResult = aa.address.getAddressWithAttributeByCapId(itemCap);&#xD;
   	if (capAddressResult.getSuccess())&#xD;
   		var fcapAddressObj = capAddressResult.getOutput();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddressResult.getErrorType() + &quot;:&quot; + capAddressResult.getErrorMessage())&#xD;
&#xD;
  	for (i in fcapAddressObj)&#xD;
  	{&#xD;
  		addressAttrObj = fcapAddressObj[i].getAttributes().toArray();&#xD;
  		for (z in addressAttrObj)&#xD;
			thisArr[&quot;AddressAttribute.&quot; + addressAttrObj[z].getB1AttributeName()]=addressAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;AddressAttribute.PrimaryFlag&quot;] = fcapAddressObj[i].getPrimaryFlag();&#xD;
		thisArr[&quot;AddressAttribute.HouseNumberStart&quot;] = fcapAddressObj[i].getHouseNumberStart();&#xD;
		thisArr[&quot;AddressAttribute.StreetDirection&quot;] = fcapAddressObj[i].getStreetDirection();&#xD;
		thisArr[&quot;AddressAttribute.StreetName&quot;] = fcapAddressObj[i].getStreetName();&#xD;
		thisArr[&quot;AddressAttribute.StreetSuffix&quot;] = fcapAddressObj[i].getStreetSuffix();&#xD;
		thisArr[&quot;AddressAttribute.City&quot;] = fcapAddressObj[i].getCity();&#xD;
		thisArr[&quot;AddressAttribute.State&quot;] = fcapAddressObj[i].getState();&#xD;
		thisArr[&quot;AddressAttribute.Zip&quot;] = fcapAddressObj[i].getZip();&#xD;
		thisArr[&quot;AddressAttribute.AddressStatus&quot;] = fcapAddressObj[i].getAddressStatus();&#xD;
		thisArr[&quot;AddressAttribute.County&quot;] = fcapAddressObj[i].getCounty();&#xD;
		thisArr[&quot;AddressAttribute.Country&quot;] = fcapAddressObj[i].getCountry();&#xD;
		thisArr[&quot;AddressAttribute.AddressDescription&quot;] = fcapAddressObj[i].getAddressDescription();&#xD;
		thisArr[&quot;AddressAttribute.XCoordinate&quot;] = fcapAddressObj[i].getXCoordinator();&#xD;
		thisArr[&quot;AddressAttribute.YCoordinate&quot;] = fcapAddressObj[i].getYCoordinator();&#xD;
  	}&#xD;
}&#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
      var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		var readOnly = 'N';&#xD;
		if (readOnlyi.hasNext()) {&#xD;
			readOnly = readOnlyi.next();&#xD;
		}&#xD;
		var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
		tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
		}&#xD;
		tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	}&#xD;
&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
	  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
				}&#xD;
&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
			//tempObject[tcol.getColumnName()] = tval;&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadASITablesBefore() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	//&#xD;
&#xD;
	var gm =  aa.env.getValue(&quot;AppSpecificTableGroupModel&quot;);&#xD;
	var ta = gm.getTablesMap().values()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
		  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator();&#xD;
&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
			}&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
          eval(copyStr);  // move to table name&#xD;
&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
&#xD;
function loadGuideSheetItems(inspId) {&#xD;
	//&#xD;
	// Returns an associative array of Guide Sheet Items&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var retArray = new Array()&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var r = aa.inspection.getInspections(itemCap)&#xD;
&#xD;
	if (r.getSuccess())&#xD;
	 	{&#xD;
		var inspArray = r.getOutput();&#xD;
&#xD;
		for (i in inspArray)&#xD;
			{&#xD;
			if (inspArray[i].getIdNumber() == inspId)&#xD;
				{&#xD;
				var inspModel = inspArray[i].getInspection();&#xD;
&#xD;
				var gs = inspModel.getGuideSheets()&#xD;
&#xD;
				if (gs)&#xD;
					{&#xD;
					gsArray = gs.toArray();&#xD;
					for (var loopk in gsArray)&#xD;
						{&#xD;
						var gsItems = gsArray[loopk].getItems().toArray()&#xD;
						for (var loopi in gsItems)&#xD;
							retArray[gsItems[loopi].getGuideItemText()] = gsItems[loopi].getGuideItemStatus();&#xD;
						}&#xD;
					} // if there are guidesheets&#xD;
				else&#xD;
					logDebug(&quot;No guidesheets for this inspection&quot;);&#xD;
				} // if this is the right inspection&#xD;
			} // for each inspection&#xD;
		} // if there are inspections&#xD;
&#xD;
	logDebug(&quot;loaded &quot; + retArray.length + &quot; guidesheet items&quot;);&#xD;
	return retArray;&#xD;
	}&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + (fTask.getStatusDate().getMonth() + 1) + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
function logDebug(dstr) {&#xD;
&#xD;
    if (!aa.calendar.getNextWorkDay) {&#xD;
&#xD;
		vLevel = 1&#xD;
		if (arguments.length &gt; 1)&#xD;
			vLevel = arguments[1]&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
			debug += dstr + br;&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel)&#xD;
			aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr)&#xD;
		}&#xD;
	else {&#xD;
			debug+=dstr + br;&#xD;
		}&#xD;
&#xD;
}&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
function lookupFeesByValuationSlidingScale(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 2;&#xD;
	if (arguments.length == 4) valNumber = (arguments[3] + 1);&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
                        &#xD;
                        &#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 2)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					var divisor = workVals[1];&#xD;
					saveVal = parseInt((capval - workVals[0])/divisor);&#xD;
					if ((capval - workVals[0]) % divisor &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function prepareRenewal() {&#xD;
&#xD;
    if (isRenewProcess(parentCapId, capId)) {&#xD;
        logDebug(&quot;CAPID(&quot; + parentCapId + &quot;) is ready for renew. PartialCap (&quot; + capId + &quot;)&quot;);&#xD;
&#xD;
        //Associate partial cap with parent CAP.&#xD;
        var result = aa.cap.createRenewalCap(parentCapId, capId, true);&#xD;
        if (result.getSuccess()) {&#xD;
            // Set B1PERMIT.B1_ACCESS_BY_ACA to &quot;N&quot; for partial CAP to not allow that it is searched by ACA user.&#xD;
            aa.cap.updateAccessByACA(capId, &quot;N&quot;);&#xD;
        }&#xD;
        else&#xD;
        { logDebug(&quot;ERROR: Associate partial cap with parent CAP. &quot; + result.getErrorMessage()); return false };&#xD;
&#xD;
        return true;&#xD;
    }&#xD;
    else&#xD;
    { logDebug(&quot;Renewal Process did not finish properly&quot;); return false; }&#xD;
}&#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function removeAllFees(itemCap) // Removes all non-invoiced fee items for a CAP ID&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByCapID(itemCap);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
&#xD;
				var editResult = aa.finance.removeFeeItem(itemCap, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + feeList[feeNum].getFeeCod());&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+feeList[feeNum].getFeeCod()+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
	}&#xD;
&#xD;
	function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.removeAppSpecificTableInfos(tableName,itemCap,currentUserID)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ aa.print(&quot;**WARNING: error removing ASI table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
        else&#xD;
	logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function replaceMessageTokens(m)&#xD;
	{&#xD;
	//  tokens in pipes will attempt to interpret as script variables&#xD;
	//  tokens in curly braces will attempt to replace from AInfo (ASI, etc)&#xD;
	//&#xD;
	//  e.g.   |capId|  or |wfTask|  or |wfStatus|&#xD;
	//&#xD;
	//  e.g.   {Expiration Date}  or  {Number of Electrical Outlets}&#xD;
	//&#xD;
	//  e.g.   m = &quot;Your recent license application (|capIdString|) has successfully passed |wfTask| with a status of |wfStatus|&quot;&#xD;
&#xD;
	while (m.indexOf(&quot;|&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;|&quot;)&#xD;
	  var e = m.indexOf(&quot;|&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;typeof(&quot; + r + &quot;) != \&quot;undefined\&quot; ? &quot; + r + &quot; : \&quot;undefined\&quot;&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\|&quot; + r + &quot;\\|&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
	  }&#xD;
&#xD;
	while (m.indexOf(&quot;{&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;{&quot;)&#xD;
	  var e = m.indexOf(&quot;}&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;AInfo[\&quot;&quot; + r + &quot;\&quot;]&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\{&quot; + r + &quot;\\}&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
&#xD;
	  }&#xD;
&#xD;
	 return m&#xD;
	 }&#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID.&#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm&#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3)&#xD;
		if (arguments[2] != null)&#xD;
			{&#xD;
			var inspRes = aa.person.getUser(arguments[2]);&#xD;
			if (inspRes.getSuccess())&#xD;
				inspectorObj = inspRes.getOutput();&#xD;
			}&#xD;
&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
&#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
function stripNN(fullStr) {&#xD;
    var allowed = &quot;0123456789.&quot;;&#xD;
    var stripped = &quot;&quot;;&#xD;
    for (i = 0; i &lt; fullStr.length(); i++)&#xD;
        if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
        stripped += String.fromCharCode(fullStr.charAt(i))&#xD;
    return stripped;&#xD;
}&#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*&#xD;
DQ 09/03/2009 - Added Check to ensure Task status date is not null prior to getting status date&#xD;
Function will return false on fail&#xD;
*/&#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
	            if (fTask.getStatusDate() != null)&#xD;
	                return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
	            else&#xD;
	                { logMessage(&quot;**ERROR: NULL workflow task &quot;+fTask.getTaskDescription()+&quot; status date. &quot;); return false; }&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap, &quot;APPLICATION&quot;, stat, sysDate, cmt, systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
}&#xD;
&#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq)&#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
    // 12/22/2008 - DQ - Correct Invoice loop to accumulate instead of reset each iteration&#xD;
&#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)&#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
&#xD;
    var invFeeFound=false;&#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = adjustedQty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) )&#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
&#xD;
	return feeSeq;&#xD;
	}&#xD;
&#xD;
&#xD;
function updateRefParcelToCap() //Takes Optional CapId&#xD;
{&#xD;
	var vCapId = null;&#xD;
	if (arguments.length &gt; 0)&#xD;
		vCapId = arguments[0];&#xD;
	else&#xD;
		vCapId = capId;&#xD;
&#xD;
    var capPrclArr = aa.parcel.getParcelDailyByCapID(vCapId,null).getOutput();&#xD;
    if(capPrclArr != null)&#xD;
    {&#xD;
        for (x in capPrclArr)&#xD;
        {&#xD;
	        var prclObj = aa.parcel.getParceListForAdmin(capPrclArr[x].getParcelNumber(), null, null, null, null, null, null, null, null, null);&#xD;
	        if (prclObj.getSuccess() )&#xD;
	        {&#xD;
		        var prclArr = prclObj.getOutput();&#xD;
		        if (prclArr.length)&#xD;
		        {&#xD;
			        var prcl = prclArr[0].getParcelModel();&#xD;
			        var capPrclObj = aa.parcel.warpCapIdParcelModel2CapParcelModel(vCapId, prcl);&#xD;
&#xD;
			        if (capPrclObj.getSuccess())&#xD;
			        {&#xD;
&#xD;
				        var capPrcl = capPrclObj.getOutput();&#xD;
				        aa.parcel.updateDailyParcelWithAPOAttribute(capPrcl);	&#xD;
				        logDebug(&quot;Updated Parcel &quot; + capPrclArr[x].getParcelNumber() + &quot; with Reference Data&quot;);&#xD;
			        }&#xD;
			        else&#xD;
				        logDebug(&quot;Failed to Wrap Parcel Model for &quot; + capPrclArr[x].getParcelNumber());&#xD;
&#xD;
		        }&#xD;
		        else&#xD;
			        logDebug(&quot;No matching reference Parcels found for &quot; + capPrclArr[x].getParcelNumber());&#xD;
	        }&#xD;
	        else&#xD;
		        logDebug(&quot;Failed to get reference Parcel for &quot; + capPrclArr[x].getParcelNumber())&#xD;
	    }&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskDepartment(wfstr,wfDepartment) // optional process name&#xD;
	{&#xD;
	// Update the task assignment department&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
        var assignBureau = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[2];&#xD;
	var assignDivision = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[3];&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
        for (var i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
                if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
 			{&#xD;
			if (wfDepartment)&#xD;
				{&#xD;
				var taskUserObj = fTask.getTaskItem().getAssignedUser()&#xD;
				taskUserObj.setBureauCode(assignBureau);&#xD;
				taskUserObj.setDivisionCode(assignDivision);&#xD;
				fTask.setAssignedUser(taskUserObj);&#xD;
        			var taskItem = fTask.getTaskItem();&#xD;
&#xD;
				var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Department Set to &quot; + assignBureau);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update Department.  Invalid department : &quot; + assignBureau);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel()&#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
&#xD;
	}&#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><initializer></initializer><title>FeeAssessAfter</title></script><scriptName>FeeAssessAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>FeeAssessBefore</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:51:07.810-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>FeeAssessBefore</name><auditModel><auditDate>2002-06-19T18:12:32-06:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs before the application fee is assessed.</description></event><script><name>FEEASSESSBEFORE</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2015-12-02T14:42:29.747-07:00</auditDate><auditID>RIVERALD</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: FeeAssessBefore.js 4781 2009-10-01 05:55:23Z roland.vonschoech $&#xD;
| Program : FeeAssessBeforeV1.6.js&#xD;
| Event   : FeeAssessBefore&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = true;			// Set to true to see results in popup window&#xD;
var showDebug = true;				// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;FeeAssessBefore&quot;; 		// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForBeforeEvents&quot;&#xD;
var cancel = false ; 				// Setting cancel to true in standard choices will cancel the event&#xD;
var documentOnly = false;			// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;			// turn off tokenizing of App Specific and Parcel Attributes&#xD;
var useAppSpecificGroupName = false;		// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;		// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;				// Maximum number of std choice entries.  Must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup = null;&#xD;
if(appTypeArray[0].substr(0,1) !=&quot;_&quot;) //Model Home Check&#xD;
{&#xD;
	var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
	if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
}&#xD;
var publicUser = false;&#xD;
if (currentUserID.indexOf(&quot;PUBLICUSER&quot;) == 0) { currentUserID = &quot;ADMIN&quot;; publicUser = true }&#xD;
var partialCap = !cap.isCompleteCap();&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var FeeItemsList = aa.env.getValue(&quot;FeeItemsList&quot;); logDebug(&quot;FeeItemsList= &quot; + FeeItemsList);&#xD;
var FeeItemsQuantityList = aa.env.getValue(&quot;FeeItemsQuantityList&quot;);logDebug(&quot;FeeItemsQuantityList= &quot; + FeeItemsQuantityList);&#xD;
var NumberOfFeeItems = aa.env.getValue(&quot;NumberOfFeeItems&quot;); logDebug(&quot;NumberOfFeeItems= &quot; + NumberOfFeeItems);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + appId + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	if (cancel)&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + debug);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
  &#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
    	{&#xD;
  	//  tableName is the name of the ASI table&#xD;
  	//  tableValueArray is an array of associative array values.  All elements MUST be either a string or asiTableVal object&#xD;
    	var itemCap = capId&#xD;
  	if (arguments.length &gt; 2)&#xD;
  		itemCap = arguments[2]; // use cap ID specified in args&#xD;
  &#xD;
  	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
  &#xD;
  	if (!tssmResult.getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
  &#xD;
  	var tssm = tssmResult.getOutput();&#xD;
  	var tsm = tssm.getAppSpecificTableModel();&#xD;
  	var fld = tsm.getTableField();&#xD;
        var fld_readonly = tsm.getReadonlyField(); // get Readonly field&#xD;
  &#xD;
         	for (thisrow in tableValueArray)&#xD;
  		{&#xD;
  &#xD;
  		var col = tsm.getColumns()&#xD;
  		var coli = col.iterator();&#xD;
  &#xD;
  		while (coli.hasNext())&#xD;
  			{&#xD;
  			var colname = coli.next();&#xD;
  &#xD;
			if (typeof(tableValueArray[thisrow][colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
				{&#xD;
	  			fld.add(tableValueArray[thisrow][colname.getColumnName()].fieldValue);&#xD;
	  			fld_readonly.add(tableValueArray[thisrow][colname.getColumnName()].readOnly);&#xD;
				}&#xD;
			else // we are passed a string&#xD;
				{&#xD;
  				fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
  				fld_readonly.add(null);&#xD;
				}&#xD;
  			}&#xD;
  &#xD;
  		tsm.setTableField(fld);&#xD;
  &#xD;
  		tsm.setReadonlyField(fld_readonly);&#xD;
  &#xD;
  		}&#xD;
  &#xD;
  	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
  &#xD;
  	 if (!addResult .getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
  	else&#xD;
  		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
  &#xD;
  	}&#xD;
  &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
&#xD;
function addFeeWithExtraData(fcode, fsched, fperiod, fqty, finvoice, feeCap, feeComment, UDF1, UDF2) {&#xD;
    var feeCapMessage = &quot;&quot;;&#xD;
    var feeSeq_L = new Array(); 			// invoicing fee for CAP in args&#xD;
    var paymentPeriod_L = new Array(); 		// invoicing pay periods for CAP in args&#xD;
&#xD;
    assessFeeResult = aa.finance.createFeeItem(feeCap, fsched, fcode, fperiod, fqty);&#xD;
    if (assessFeeResult.getSuccess()) {&#xD;
        feeSeq = assessFeeResult.getOutput();&#xD;
        logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
        logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
        fsm = aa.finance.getFeeItemByPK(feeCap, feeSeq).getOutput().getF4FeeItem();&#xD;
&#xD;
        if (feeComment) fsm.setFeeNotes(feeComment);&#xD;
        if (UDF1) fsm.setUdf1(UDF1);&#xD;
        if (UDF2) fsm.setUdf2(UDF2);&#xD;
&#xD;
        aa.finance.editFeeItem(fsm)&#xD;
&#xD;
&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
        {&#xD;
            feeSeqList.push(feeSeq);&#xD;
            paymentPeriodList.push(fperiod);&#xD;
        }&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
        {&#xD;
            feeSeq_L.push(feeSeq);&#xD;
            paymentPeriod_L.push(fperiod);&#xD;
            var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
            if (invoiceResult_L.getSuccess())&#xD;
                logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
            else&#xD;
                logDebug(&quot;**ERROR: Invoicing the fee items assessed was not successful.  Reason: &quot; + invoiceResult.getErrorMessage());&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
        return null;&#xD;
    }&#xD;
&#xD;
    return feeSeq;&#xD;
&#xD;
}&#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
function addParcelAndOwnerFromRefAddress(refAddress)  // optional capID&#xD;
	{&#xD;
&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	// first add the primary parcel&#xD;
	//&#xD;
	var primaryParcelResult = aa.parcel.getPrimaryParcelByRefAddressID(refAddress,&quot;Y&quot;);&#xD;
	if (primaryParcelResult.getSuccess())&#xD;
		var primaryParcel = primaryParcelResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get primary parcel for ref Address &quot; + refAddress + &quot; , &quot; + primaryParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var capParModel = aa.parcel.warpCapIdParcelModel2CapParcelModel(capId,primaryParcel).getOutput()&#xD;
&#xD;
	var createPMResult = aa.parcel.createCapParcel(capParModel);&#xD;
	if (createPMResult.getSuccess())&#xD;
		logDebug(&quot;created CAP Parcel&quot;);&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Failed to create the cap Parcel &quot; + createPMResult.getErrorMessage()); }&#xD;
&#xD;
&#xD;
	// Now the owners&#xD;
	//&#xD;
&#xD;
	var parcelListResult = aa.parcel.getParcelDailyByCapID(capId,null);&#xD;
	if (parcelListResult.getSuccess())&#xD;
		var parcelList = parcelListResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel List &quot; + parcelListResult.getErrorMessage()); return false; }&#xD;
&#xD;
&#xD;
	for (var thisP in parcelList)&#xD;
  		{&#xD;
  		var ownerListResult = aa.owner.getOwnersByParcel(parcelList[thisP]);&#xD;
		if (ownerListResult.getSuccess())&#xD;
			var ownerList = ownerListResult.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Failed to get Owner List &quot; + ownerListResult.getErrorMessage()); return false; }&#xD;
&#xD;
  		for (var thisO in ownerList)&#xD;
      			{&#xD;
      			ownerList[thisO].setCapID(capId);&#xD;
      			createOResult = aa.owner.createCapOwnerWithAPOAttribute(ownerList[thisO]);&#xD;
&#xD;
			if (createOResult.getSuccess())&#xD;
				logDebug(&quot;Created CAP Owner&quot;);&#xD;
			else&#xD;
				{ logDebug(&quot;**WARNING: Failed to create CAP Owner &quot; + createOResult.getErrorMessage()); }&#xD;
			}&#xD;
	      	}&#xD;
     }&#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
&#xD;
function addReferenceContactByName(vFirst, vMiddle, vLast)&#xD;
{&#xD;
	var userFirst = vFirst;&#xD;
	var userMiddle = vMiddle;&#xD;
	var userLast = vLast;&#xD;
&#xD;
	//Find PeopleModel object for user&#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
	//Add the reference contact record to the current CAP&#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
}&#xD;
function addressExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
	var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
	if (capAddResult.getSuccess())&#xD;
		var fcapAddressObj = capAddResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddResult.getErrorType() + &quot;:&quot; + capAddResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapAddressObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
			if (addCapCondResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements must be either a string or asiTableVal object&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	var col = tsm.getColumns();&#xD;
	var fld_readonly = tsm.getReadonlyField(); //get ReadOnly property&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
&#xD;
		if (typeof(tableValues[colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()].fieldValue);&#xD;
			fld_readonly.add(tableValues[colname.getColumnName()].readOnly);&#xD;
			}&#xD;
		else // we are passed a string&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()]);&#xD;
			fld_readonly.add(null);&#xD;
			}&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	tsm.setReadonlyField(fld_readonly); // set readonly field&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
&#xD;
function asiTableValObj(columnName, fieldValue, readOnly) {&#xD;
	this.columnName = columnName;&#xD;
	this.fieldValue = fieldValue;&#xD;
	this.readOnly = readOnly;&#xD;
&#xD;
	asiTableValObj.prototype.toString=function(){ return this.fieldValue }&#xD;
};&#xD;
&#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	}function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	}function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	}function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	}function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	function checkCapForLicensedProfessionalType( licProfType )&#xD;
{&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	&#xD;
	if( capLicenseResult.getSuccess() )&#xD;
	{ &#xD;
		var capLicenseArr = capLicenseResult.getOutput();&#xD;
		&#xD;
		if (!capLicenseArr)&#xD;
			{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
		&#xD;
		for( licProf in capLicenseArr )&#xD;
		{&#xD;
			if( licProfType.equals(capLicenseArr[licProf].getLicenseType()) )&#xD;
			{&#xD;
				aa.print( &quot;Found License Professional with Type= &quot; + licProfType );&#xD;
				return true; //Found Licensed Prof of specified type&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		return false;&#xD;
	}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
}function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
function closeSubWorkflow(thisProcessID,wfStat) // optional capId&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var isCompleted = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTaskSM = wfObj[i];&#xD;
		if (fTaskSM.getProcessID() == thisProcessID &amp;&amp; fTaskSM.getCompleteFlag() != &quot;Y&quot;)&#xD;
			{&#xD;
			logDebug(&quot;closeSubWorkflow: found an incomplete task processID #&quot; + thisProcessID + &quot; , Step# &quot; + fTaskSM.getStepNumber(),3);&#xD;
			isCompleted = false&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (!isCompleted) return false;&#xD;
&#xD;
&#xD;
	// get the parent task&#xD;
&#xD;
	var relationArray = aa.workflow.getProcessRelationByCapID(itemCap,null).getOutput()&#xD;
&#xD;
	var relRecord = null;&#xD;
&#xD;
	for (thisRel in relationArray)&#xD;
		if (relationArray[thisRel].getProcessID() == thisProcessID)&#xD;
			relRecord = relationArray[thisRel];&#xD;
&#xD;
	if (!relRecord)&#xD;
		{&#xD;
		logDebug(&quot;closeSubWorkflow: did not find a process relation, exiting&quot;,3);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	logDebug(&quot;executing handleDisposition:&quot; + relRecord.getStepNumber() + &quot;,&quot; + relRecord.getParentProcessID() + &quot;,&quot; + wfStat,3);&#xD;
&#xD;
	var handleResult = aa.workflow.handleDisposition(itemCap,relRecord.getStepNumber(),relRecord.getParentProcessID(),wfStat,sysDate,&quot;Closed via script&quot;,&quot;Closed via script&quot;,systemUserObj ,&quot;Y&quot;);&#xD;
&#xD;
	if (!handleResult.getSuccess())&#xD;
		logDebug(&quot;**WARNING: closing parent task: &quot; + handleResult.getErrorMessage());&#xD;
	else&#xD;
		logDebug(&quot;Closed parent task&quot;);&#xD;
	}&#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
function comparePeopleGeneric(peop)&#xD;
	{&#xD;
&#xD;
	// this function will be passed as a parameter to the createRefContactsFromCapContactsAndLink function.&#xD;
	//&#xD;
	// takes a single peopleModel as a parameter, and will return the sequence number of the first G6Contact result&#xD;
	//&#xD;
	// returns null if there are no matches&#xD;
	//&#xD;
	// current search method is by email only.  In order to use attributes enhancement 09ACC-05048 must be implemented&#xD;
	//&#xD;
&#xD;
	peop.setAuditDate(null)&#xD;
	peop.setAuditID(null)&#xD;
	peop.setAuditStatus(null)&#xD;
	peop.setBirthDate(null)&#xD;
	peop.setBusName2(null)&#xD;
	peop.setBusinessName(null)&#xD;
	peop.setComment(null)&#xD;
	peop.setCompactAddress(null)&#xD;
	peop.setContactSeqNumber(null)&#xD;
	peop.setContactType(null)&#xD;
	peop.setContactTypeFlag(null)&#xD;
	peop.setCountry(null)&#xD;
	peop.setCountryCode(null)&#xD;
	// peop.setEmail(null)       just as a test we are using email&#xD;
	peop.setEndBirthDate(null)&#xD;
	peop.setFax(null)&#xD;
	peop.setFaxCountryCode(null)&#xD;
	peop.setFein(null)&#xD;
	peop.setFirstName(null)&#xD;
	peop.setFlag(null)&#xD;
	peop.setFullName(null)&#xD;
	peop.setGender(null)&#xD;
	peop.setHoldCode(null)&#xD;
	peop.setHoldDescription(null)&#xD;
	peop.setId(null)&#xD;
	peop.setIvrPinNumber(null)&#xD;
	peop.setIvrUserNumber(null)&#xD;
	peop.setLastName(null)&#xD;
	peop.setMaskedSsn(null)&#xD;
	peop.setMiddleName(null)&#xD;
	peop.setNamesuffix(null)&#xD;
	peop.setPhone1(null)&#xD;
	peop.setPhone1CountryCode(null)&#xD;
	peop.setPhone2(null)&#xD;
	peop.setPhone2CountryCode(null)&#xD;
	peop.setPhone3(null)&#xD;
	peop.setPhone3CountryCode(null)&#xD;
	peop.setPostOfficeBox(null)&#xD;
	peop.setPreferredChannel(null)&#xD;
	peop.setPreferredChannelString(null)&#xD;
	peop.setRate1(null)&#xD;
	peop.setRelation(null)&#xD;
	peop.setSalutation(null)&#xD;
	peop.setServiceProviderCode(null)&#xD;
	peop.setSocialSecurityNumber(null)&#xD;
	peop.setTitle(null)&#xD;
	peop.setTradeName(null)&#xD;
&#xD;
	var r = aa.people.getPeopleByPeopleModel(peop);&#xD;
&#xD;
    if (!r.getSuccess())&#xD;
			{ logDebug(&quot;WARNING: error searching for people : &quot; + r.getErrorMessage()); return false; }&#xD;
&#xD;
	var peopResult = r.getOutput();&#xD;
&#xD;
	if (peopResult.length == 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for REF contact, no matches found, returing null&quot;);&#xD;
		return null;&#xD;
		}&#xD;
&#xD;
	if (peopResult.length &gt; 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for a REF Contact, &quot; + peopResult.length + &quot; matches found! returning the first match : &quot; + peopResult[0].getContactSeqNumber() );&#xD;
		return peopResult[0].getContactSeqNumber()&#xD;
		}&#xD;
&#xD;
}function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
}function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
function convertStringToPhone(theString)&#xD;
	{&#xD;
	var n = &quot;22233344455566677778889999&quot;;&#xD;
&#xD;
	var compString = String(theString.toUpperCase());&#xD;
	var retString = &quot;&quot;;&#xD;
&#xD;
	for (var x=0 ; x&lt; compString.length ; x++)&#xD;
   		{&#xD;
   		if (compString[x] &gt;= &quot;A&quot; &amp;&amp; compString[x] &lt;= &quot;Z&quot;)&#xD;
   			retString += n[compString.charCodeAt(x)-65]&#xD;
  		 else&#xD;
   			retString += compString[x];&#xD;
  		}&#xD;
   	return retString;&#xD;
 	}&#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
&#xD;
	//check if target CAP has primary address&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//get addresses from originating CAP&#xD;
	var capAddressResult = aa.address.getAddressWithAttributeByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddressWithAPOAttribute(vToCapId, newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	return copied;&#xD;
	}&#xD;
&#xD;
&#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional groups to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
&#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
&#xD;
function copyLicensedProf(sCapId, tCapId)&#xD;
{&#xD;
	//Function will copy all licensed professionals from source CapID to target CapID&#xD;
&#xD;
	var licProf = aa.licenseProfessional.getLicensedProfessionalsByCapID(sCapId).getOutput();&#xD;
	if (licProf != null)&#xD;
		for(x in licProf)&#xD;
		{&#xD;
			licProf[x].setCapID(tCapId);&#xD;
			aa.licenseProfessional.createLicensedProfessional(licProf[x]);&#xD;
			logDebug(&quot;Copied &quot; + licProf[x].getLicenseNbr());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;No licensed professional on source&quot;);&#xD;
}&#xD;
&#xD;
//Function will copy all owners from source CAP (sCapID) to target CAP (tCapId)&#xD;
function copyOwner(sCapID, tCapID)&#xD;
{&#xD;
	var ownrReq = aa.owner.getOwnerByCapId(sCapID);&#xD;
	if(ownrReq.getSuccess())&#xD;
	{&#xD;
		var ownrObj = ownrReq.getOutput();&#xD;
		for (xx in ownrObj)&#xD;
		{&#xD;
			ownrObj[xx].setCapID(tCapID);&#xD;
			aa.owner.createCapOwnerWithAPOAttribute(ownrObj[xx]);&#xD;
			logDebug(&quot;Copied Owner: &quot; + ownrObj[xx].getOwnerFullName())&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
		logDebug(&quot;Error Copying Owner : &quot; + ownrObj.getErrorType() + &quot; : &quot; + ownrObj.getErrorMessage());&#xD;
}&#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
&#xD;
function createCapComment(vComment)  //optional CapId&#xD;
{&#xD;
	var vCapId = capId;&#xD;
	if (arguments.length == 2)&#xD;
		vCapId = arguments[1];&#xD;
	var comDate = aa.date.getCurrentDate(); &#xD;
	var capCommentScriptModel= aa.cap.createCapCommentScriptModel(); &#xD;
	capCommentScriptModel.setCapIDModel(vCapId); &#xD;
	capCommentScriptModel.setCommentType(&quot;APP LEVEL COMMENT&quot;); &#xD;
	capCommentScriptModel.setSynopsis(&quot;&quot;); &#xD;
	capCommentScriptModel.setText(vComment); &#xD;
	capCommentScriptModel.setAuditUser(currentUserID); &#xD;
	capCommentScriptModel.setAuditStatus(&quot;A&quot;); &#xD;
	capCommentScriptModel.setAuditDate(comDate); &#xD;
	var capCommentModel=capCommentScriptModel.getCapCommentModel(); &#xD;
	aa.cap.createCapComment(capCommentModel); &#xD;
	logDebug(&quot;Comment Added&quot;);&#xD;
}function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createPublicUserFromContact()   // optional: Contact Type, default Applicant&#xD;
{&#xD;
    var contactType = &quot;Applicant&quot;;&#xD;
    var contact;&#xD;
    if (arguments.length &gt; 0) contactType = arguments[0]; // use contact type specified&#xD;
&#xD;
    var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
    if (capContactResult.getSuccess()) {&#xD;
        var Contacts = capContactResult.getOutput();&#xD;
        for (yy in Contacts) {&#xD;
            aa.print(Contacts[yy].getCapContactModel().getPeople().getContactType())&#xD;
            if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
                contact = Contacts[yy];&#xD;
        }&#xD;
    }&#xD;
&#xD;
    aa.print(contact.getEmail());&#xD;
    if (!contact)&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no such contact&quot;); return false; }&#xD;
&#xD;
    if (!contact.getEmail())&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no email address&quot;); return false; }&#xD;
&#xD;
    // check if exists already&#xD;
&#xD;
    var getUserResult = aa.publicUser.getPublicUserByEmail(contact.getEmail())&#xD;
    if (getUserResult.getSuccess()) {&#xD;
        var userModel = getUserResult.getOutput()&#xD;
        aa.print(&quot;found the user already&quot;);&#xD;
        if (userModel) return userModel;  // send back the existing user&#xD;
    }&#xD;
&#xD;
    // create a new one&#xD;
&#xD;
    var publicUser = aa.publicUser.getPublicUserModel();&#xD;
    publicUser.setFirstName(contact.getFirstName());&#xD;
    publicUser.setLastName(contact.getLastName());&#xD;
    publicUser.setEmail(contact.getEmail());&#xD;
    publicUser.setUserID(contact.getEmail());&#xD;
    publicUser.setPassword(&quot;7d3fe8b8d7ba80addfc296b07de60cc101e4af60&quot;); //password : Gary0813&#xD;
    publicUser.setAuditID(&quot;PublicUser&quot;);&#xD;
    publicUser.setAuditStatus(&quot;A&quot;);&#xD;
    publicUser.setCellPhone(contact.getCapContactModel().getPeople().getPhone2());&#xD;
&#xD;
    var result = aa.publicUser.createPublicUser(publicUser);&#xD;
&#xD;
    if (result.getSuccess()) {&#xD;
        logDebug(&quot;Created public user &quot; + contact.getEmail() + &quot;  sucessfully.&quot;);&#xD;
        var userSeqNum = result.getOutput();&#xD;
        var userModel = aa.publicUser.getPublicUser(userSeqNum).getOutput()&#xD;
&#xD;
        // create for agency&#xD;
        aa.publicUser.createPublicUserForAgency(userModel);&#xD;
&#xD;
        // activate for agency&#xD;
        var userPinBiz = aa.proxyInvoker.newInstance(&quot;com.accela.pa.pin.UserPINBusiness&quot;).getOutput()&#xD;
		userPinBiz.updateActiveStatusAndLicenseIssueDate4PublicUser(servProvCode,userSeqNum,&quot;ADMIN&quot;);&#xD;
		// reset password&#xD;
&#xD;
		var PUB = aa.proxyInvoker.newInstance(&quot;com.accela.v360.publicuser.PublicUserBusiness&quot;).getOutput()&#xD;
		PUB.resetPassword(contact.getEmail());&#xD;
&#xD;
        // send Activate email&#xD;
        aa.publicUser.sendActivateEmail(userModel, true, true);&#xD;
&#xD;
        // send another email&#xD;
        aa.publicUser.sendPasswordEmail(userModel);&#xD;
        return userModel;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**Warning creating public user &quot; + contact.getEmail() + &quot;  failure: &quot; + result.getErrorMessage()); return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
function createRefContactsFromCapContactsAndLink(pCapId, contactTypeArray, ignoreAttributeArray, replaceCapContact, overwriteRefContact, refContactExists)&#xD;
	{&#xD;
&#xD;
	// contactTypeArray is either null (all), or an array or contact types to process&#xD;
	//&#xD;
	// ignoreAttributeArray is either null (none), or an array of attributes to ignore when creating a REF contact&#xD;
	//&#xD;
	// replaceCapContact not implemented yet&#xD;
	//&#xD;
	// overwriteRefContact -- if true, will refresh linked ref contact with CAP contact data&#xD;
	//&#xD;
	// refContactExists is a function for REF contact comparisons.&#xD;
	//&#xD;
	var ingoreArray = new Array();&#xD;
	if (arguments.length &gt; 1) ignoreArray = arguments[1];&#xD;
&#xD;
	var c = aa.people.getCapContactByCapID(pCapId).getOutput()&#xD;
	var cCopy = aa.people.getCapContactByCapID(pCapId).getOutput()  // must have two working datasets&#xD;
&#xD;
	for (var i in c)&#xD;
	   {&#xD;
	   var con = c[i];&#xD;
&#xD;
	   var p = con.getPeople();&#xD;
	   &#xD;
	   if (contactTypeArray &amp;&amp; !exists(p.getContactType(),contactTypeArray))&#xD;
		continue;  // not in the contact type list.  Move along.&#xD;
&#xD;
	   &#xD;
	   var refContactNum = con.getCapContactModel().getRefContactNumber();&#xD;
	   if (refContactNum)  // This is a reference contact.   Let's refresh or overwrite as requested in parms.&#xD;
	   	{&#xD;
	   	if (overwriteRefContact)&#xD;
	   		{&#xD;
	   		p.setContactSeqNumber(refContactNum);  // set the ref seq# to refresh&#xD;
	   		&#xD;
	   		&#xD;
	   						var a = p.getAttributes();&#xD;
			&#xD;
							if (a)&#xD;
								{&#xD;
								var ai = a.iterator();&#xD;
								while (ai.hasNext())&#xD;
									{&#xD;
									var xx = ai.next();&#xD;
									xx.setContactNo(refContactNum);&#xD;
									}&#xD;
					}&#xD;
					&#xD;
					&#xD;
					&#xD;
	   		var r = aa.people.editPeopleWithAttribute(p,p.getAttributes());&#xD;
	   		&#xD;
			if (!r.getSuccess()) &#xD;
				logDebug(&quot;WARNING: couldn't refresh reference people : &quot; + r.getErrorMessage()); &#xD;
			else&#xD;
				logDebug(&quot;Successfully refreshed ref contact #&quot; + refContactNum + &quot; with CAP contact data&quot;); &#xD;
			}&#xD;
			&#xD;
	   	if (replaceCapContact)&#xD;
	   		{&#xD;
				// To Be Implemented later.   Is there a use case?&#xD;
			}&#xD;
			&#xD;
	   	}&#xD;
	   	else  // user entered the contact freehand.   Let's create or link to ref contact.&#xD;
	   	{&#xD;
			var ccmSeq = p.getContactSeqNumber();&#xD;
&#xD;
			var existingContact = refContactExists(p);  // Call the custom function to see if the REF contact exists&#xD;
&#xD;
			var p = cCopy[i].getPeople();  // get a fresh version, had to mangle the first for the search&#xD;
&#xD;
			if (existingContact)  // we found a match with our custom function.  Use this one.&#xD;
				{&#xD;
					refPeopleId = existingContact;&#xD;
				}&#xD;
			else  // did not find a match, let's create one&#xD;
				{&#xD;
&#xD;
				var a = p.getAttributes();&#xD;
&#xD;
				if (a)&#xD;
					{&#xD;
					//&#xD;
					// Clear unwanted attributes&#xD;
					var ai = a.iterator();&#xD;
					while (ai.hasNext())&#xD;
						{&#xD;
						var xx = ai.next();&#xD;
						if (ignoreAttributeArray &amp;&amp; exists(xx.getAttributeName().toUpperCase(),ignoreAttributeArray))&#xD;
							ai.remove();&#xD;
						}&#xD;
					}&#xD;
&#xD;
				var r = aa.people.createPeopleWithAttribute(p,a);&#xD;
&#xD;
				if (!r.getSuccess())&#xD;
					{logDebug(&quot;WARNING: couldn't create reference people : &quot; + r.getErrorMessage()); continue; }&#xD;
&#xD;
				//&#xD;
				// createPeople is nice and updates the sequence number to the ref seq&#xD;
				//&#xD;
&#xD;
				var p = cCopy[i].getPeople();&#xD;
				var refPeopleId = p.getContactSeqNumber();&#xD;
&#xD;
				logDebug(&quot;Successfully created reference contact #&quot; + refPeopleId);&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// now that we have the reference Id, we can link back to reference&#xD;
			//&#xD;
&#xD;
		    var ccm = aa.people.getCapContactByPK(pCapId,ccmSeq).getOutput().getCapContactModel();&#xD;
&#xD;
		    ccm.setRefContactNumber(refPeopleId);&#xD;
		    r = aa.people.editCapContact(ccm);&#xD;
&#xD;
		    if (!r.getSuccess())&#xD;
				{ logDebug(&quot;WARNING: error updating cap contact model : &quot; + r.getErrorMessage()); }&#xD;
			else&#xD;
				{ logDebug(&quot;Successfully linked ref contact &quot; + refPeopleId + &quot; to cap contact &quot; + ccmSeq);}&#xD;
&#xD;
&#xD;
	    }  // end if user hand entered contact &#xD;
	}  // end for each CAP contact&#xD;
} // end function&#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
function deactivateTask(wfstr) // optional process name&#xD;
{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
	{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
	}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
	{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
		{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
		}			&#xD;
	}&#xD;
}&#xD;
&#xD;
function deleteTask(targetCapId,deleteTaskName)&#xD;
{&#xD;
	//&#xD;
	// Get the target Task&#xD;
	//&#xD;
	var workflowResult = aa.workflow.getTasks(targetCapId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var tTask = null;&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(deleteTaskName.toUpperCase()))&#xD;
  			{&#xD;
			var tTask = wfObj[i];&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	if (!tTask)&#xD;
  	  	{ logDebug(&quot;**WARNING: Task not found: &quot; + deleteTaskName); return false; }&#xD;
&#xD;
&#xD;
	logDebug(&quot;Removing task &quot; + tTask.getTaskDescription());&#xD;
	var result = aa.workflow.removeTask(tTask)&#xD;
&#xD;
	if (!result.getSuccess())&#xD;
		{ logDebug(&quot;error &quot; + result.getErrorMessage()); return false; }&#xD;
&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	&#xD;
	itemCap = capId;&#xD;
	&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
   	&#xD;
   	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
			{&#xD;
				if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
				{&#xD;
					appspecObj[i].setChecklistComment(itemValue);&#xD;
						&#xD;
					var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
					if (actionResult.getSuccess()) &#xD;
					{							&#xD;
						logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
					} &#xD;
					else &#xD;
					{&#xD;
						logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
					}&#xD;
						&#xD;
					updated = true;&#xD;
					AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
				}&#xD;
				&#xD;
				i++;&#xD;
				&#xD;
			} // while loop&#xD;
		} // item name blank&#xD;
	} // got app specific object	&#xD;
	else&#xD;
	{ &#xD;
		logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage());&#xD;
	}&#xD;
}//End Function&#xD;
&#xD;
function editBuildingCount(numBuild) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setBuildingCount(parseFloat(numBuild));&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated building count to &quot; + numBuild); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
}function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editInspectionRequiredFlag(inspType,reqFlag)&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var result = aa.inspection.getInspMilestoneByCapID(itemCap);&#xD;
&#xD;
	if(!result.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection milestones: &quot;  + result.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspMilestones= result.getOutput();&#xD;
&#xD;
	if (!inspMilestones)&#xD;
		{ logDebug(&quot;No Inspection Milestones found&quot;) ; return false ; }&#xD;
&#xD;
	for (thisM in inspMilestones)&#xD;
		{&#xD;
		var obj= inspMilestones[thisM];&#xD;
		if (inspType.equals(obj.getInspType()))&#xD;
			{&#xD;
			if (reqFlag) obj.setInspRequired(&quot;Y&quot;);&#xD;
			else obj.setInspRequired(&quot;N&quot;);&#xD;
&#xD;
			result = aa.inspection.updateInspectionMilestone(inspMilestones);&#xD;
			if(result.getSuccess())&#xD;
				logDebug(&quot;inspection milestone updated sucessfully.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: could not update inpsection milestone &quot; +result.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	}function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editScheduledDate(scheduledDate) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	vScheduledDate = aa.date.parseDate(scheduledDate);&#xD;
	&#xD;
	//cd.setScheduledDate(vScheduledDate); //bug, doesn't work&#xD;
	cdScriptObj.setScheduledDate(vScheduledDate);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated scheduled date to &quot; + scheduledDate) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR updating scheduled date: &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = &quot;&quot; + Contacts[yy].getEmail();&#xD;
		}&#xD;
&#xD;
	if (emailAddress.indexOf(&quot;@&quot;) &gt; 0)&#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no valid email address&quot;);&#xD;
	}function endBranch() {&#xD;
	// stop execution of the current std choice&#xD;
	stopBranch = false;&#xD;
	}function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
&#xD;
function externalLP_CA(licNum,rlpType,doPopulateRef,doPopulateTrx,itemCap)&#xD;
	{&#xD;
&#xD;
	/*&#xD;
	Version: 3.2&#xD;
&#xD;
	Usage:&#xD;
&#xD;
		licNum			:  Valid CA license number.   Non-alpha, max 8 characters.  If null, function will use the LPs on the supplied CAP ID&#xD;
		rlpType			:  License professional type to use when validating and creating new LPs&#xD;
		doPopulateRef 	:  If true, will create/refresh a reference LP of this number/type&#xD;
		doPopulateTrx 	:  If true, will copy create/refreshed reference LPs to the supplied Cap ID.   doPopulateRef must be true for this to work&#xD;
		itemCap			:  If supplied, licenses on the CAP will be validated.  Also will be refreshed if doPopulateRef and doPopulateTrx are true&#xD;
&#xD;
	returns: non-null string of status codes for invalid licenses&#xD;
&#xD;
	examples:&#xD;
&#xD;
	appsubmitbefore   (will validate the LP entered, if any, and cancel the event if the LP is inactive, cancelled, expired, etc.)&#xD;
	===============&#xD;
	true ^ cslbMessage = &quot;&quot;;&#xD;
	CAELienseNumber ^ cslbMessage = externalLP_CA(CAELienseNumber,false,false,CAELienseType,null);&#xD;
	cslbMessage.length &gt; 0 ^ cancel = true ; showMessage = true ; comment(cslbMessage)&#xD;
&#xD;
	appsubmitafter  (update all CONTRACTOR LPs on the CAP and REFERENCE with data from CSLB.  Link the CAP LPs to REFERENCE.   Pop up a message if any are inactive...)&#xD;
	==============&#xD;
	true ^ 	cslbMessage = externalLP_CA(null,true,true,&quot;CONTRACTOR&quot;,capId)&#xD;
	cslbMessage.length &gt; 0 ^ showMessage = true ; comment(cslbMessage);&#xD;
&#xD;
	Note;  Custom LP Template Field Mappings can be edited in the script below&#xD;
	*/&#xD;
&#xD;
	var returnMessage = &quot;&quot;;&#xD;
&#xD;
	var workArray = new Array();&#xD;
	if (licNum)&#xD;
		workArray.push(String(licNum));&#xD;
&#xD;
	if (itemCap)&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(itemCap);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{&#xD;
			var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
		if (capLicenseArr == null || !capLicenseArr.length)&#xD;
			{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); }&#xD;
		else&#xD;
			{&#xD;
			for (var thisLic in capLicenseArr)&#xD;
				if (capLicenseArr[thisLic].getLicenseType() == rlpType)&#xD;
					workArray.push(capLicenseArr[thisLic]);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		doPopulateTrx = false; // can't do this without a CAP;&#xD;
&#xD;
	for (var thisLic = 0; thisLic &lt; workArray.length; thisLic++)&#xD;
		{&#xD;
		var licNum = workArray[thisLic];&#xD;
		var licObj = null;&#xD;
		var isObject = false;&#xD;
&#xD;
		if (typeof(licNum) == &quot;object&quot;)  // is this one an object or string?&#xD;
			{&#xD;
			licObj = licNum;&#xD;
			licNum = licObj.getLicenseNbr();&#xD;
			isObject = true;&#xD;
			}&#xD;
&#xD;
		// Make the call to the California State License Board&#xD;
&#xD;
        var saxBuilder = aa.proxyInvoker.newInstance(&quot;org.jdom.input.SAXBuilder&quot;).getOutput();&#xD;
        var aURLArgList = new Array()&#xD;
        aURLArgList[0] = &quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum;&#xD;
        var oURL = aa.proxyInvoker.newInstance(&quot;java.net.URL&quot;,aURLArgList).getOutput();&#xD;
        var document = saxBuilder.build(oURL); //(&quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum);&#xD;
        var root = document.getRootElement();&#xD;
&#xD;
		var errorNode = root.getChild(&quot;Error&quot;);&#xD;
		if (errorNode)&#xD;
			{&#xD;
			logDebug(&quot;Error for license &quot; + licNum + &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;));&#xD;
			returnMessage+=&quot;License &quot; + licNum +  &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;) + &quot; &quot;;&#xD;
			continue;&#xD;
			}&#xD;
&#xD;
		var lpBiz = root.getChild(&quot;BusinessInfo&quot;);&#xD;
		var lpStatus = root.getChild(&quot;PrimaryStatus&quot;);&#xD;
		var lpClass = root.getChild(&quot;Classifications&quot;);&#xD;
		var lpBonds = root.getChild(&quot;ContractorBond&quot;);&#xD;
		var lpWC = root.getChild(&quot;WorkersComp&quot;);&#xD;
&#xD;
		// Primary Status&#xD;
		// 3 = expired, 10 = good, 11 = inactive, 1 = canceled.   We will ignore all but 10 and return text.&#xD;
		var stas = lpStatus.getChildren();&#xD;
		for (var i=0 ; i&lt;stas.size(); i++) {&#xD;
			var sta = stas.get(i);&#xD;
&#xD;
			if (sta.getAttribute(&quot;Code&quot;).getValue() != &quot;10&quot;)&#xD;
				returnMessage+=&quot;License:&quot; + licNum + &quot;, &quot; + sta.getAttribute(&quot;Desc&quot;).getValue() + &quot; &quot;;&#xD;
		}&#xD;
&#xD;
		if (doPopulateRef)  // refresh or create a reference LP&#xD;
			{&#xD;
			var updating = false;&#xD;
&#xD;
			// check to see if the licnese already exists...if not, create.&#xD;
&#xD;
			var newLic = getRefLicenseProf(licNum)&#xD;
&#xD;
			if (newLic)&#xD;
				{&#xD;
				updating = true;&#xD;
				logDebug(&quot;Updating existing Ref Lic Prof : &quot; + licNum);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
				}&#xD;
&#xD;
			if (isObject)  // update the reference LP with data from the transactional, if we have some.&#xD;
				{&#xD;
				if (licObj.getAddress1()) newLic.setAddress1(licObj.getAddress1());&#xD;
				if (licObj.getAddress2()) newLic.setAddress2(licObj.getAddress2());&#xD;
				if (licObj.getAddress3()) newLic.setAddress3(licObj.getAddress3());&#xD;
				if (licObj.getAgencyCode()) newLic.setAgencyCode(licObj.getAgencyCode());&#xD;
				if (licObj.getBusinessLicense()) newLic.setBusinessLicense(licObj.getBusinessLicense());&#xD;
				if (licObj.getBusinessName()) newLic.setBusinessName(licObj.getBusinessName());&#xD;
				if (licObj.getBusName2()) newLic.setBusinessName2(licObj.getBusName2());&#xD;
				if (licObj.getCity()) newLic.setCity(licObj.getCity());&#xD;
				if (licObj.getCityCode()) newLic.setCityCode(licObj.getCityCode());&#xD;
				if (licObj.getContactFirstName()) newLic.setContactFirstName(licObj.getContactFirstName());&#xD;
				if (licObj.getContactLastName()) newLic.setContactLastName(licObj.getContactLastName());&#xD;
				if (licObj.getContactMiddleName()) newLic.setContactMiddleName(licObj.getContactMiddleName());&#xD;
				if (licObj.getCountryCode()) newLic.setContryCode(licObj.getCountryCode());&#xD;
				if (licObj.getEmail()) newLic.setEMailAddress(licObj.getEmail());&#xD;
				if (licObj.getCountry()) newLic.setCountry(licObj.getCountry());&#xD;
				if (licObj.getEinSs()) newLic.setEinSs(licObj.getEinSs());&#xD;
				if (licObj.getFax()) newLic.setFax(licObj.getFax());&#xD;
				if (licObj.getFaxCountryCode()) newLic.setFaxCountryCode(licObj.getFaxCountryCode());&#xD;
				if (licObj.getHoldCode()) newLic.setHoldCode(licObj.getHoldCode());&#xD;
				if (licObj.getHoldDesc()) newLic.setHoldDesc(licObj.getHoldDesc());&#xD;
				if (licObj.getLicenseExpirDate()) newLic.setLicenseExpirationDate(licObj.getLicenseExpirDate());&#xD;
				if (licObj.getLastRenewalDate()) newLic.setLicenseLastRenewalDate(licObj.getLastRenewalDate());&#xD;
				if (licObj.getLicesnseOrigIssueDate()) newLic.setLicOrigIssDate(licObj.getLicesnseOrigIssueDate());&#xD;
				if (licObj.getPhone1()) newLic.setPhone1(licObj.getPhone1());&#xD;
				if (licObj.getPhone1CountryCode()) newLic.setPhone1CountryCode(licObj.getPhone1CountryCode());&#xD;
				if (licObj.getPhone2()) newLic.setPhone2(licObj.getPhone2());&#xD;
				if (licObj.getPhone2CountryCode()) newLic.setPhone2CountryCode(licObj.getPhone2CountryCode());&#xD;
				if (licObj.getSelfIns()) newLic.setSelfIns(licObj.getSelfIns());&#xD;
				if (licObj.getState()) newLic.setState(licObj.getState());&#xD;
				if (licObj.getSuffixName()) newLic.setSuffixName(licObj.getSuffixName());&#xD;
				if (licObj.getZip()) newLic.setZip(licObj.getZip());&#xD;
				}&#xD;
&#xD;
			// Now set data from the CSLB&#xD;
&#xD;
			if (lpBiz.getChild(&quot;Name&quot;).getText() != &quot;&quot;) newLic.setBusinessName(unescape(lpBiz.getChild(&quot;Name&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr1&quot;).getText() != &quot;&quot;) newLic.setAddress1(unescape(lpBiz.getChild(&quot;Addr1&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr2&quot;).getText() != &quot;&quot;) newLic.setAddress2(unescape(lpBiz.getChild(&quot;Addr2&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;City&quot;).getText() != &quot;&quot;) newLic.setCity(unescape(lpBiz.getChild(&quot;City&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;State&quot;).getText() != &quot;&quot;) newLic.setState(unescape(lpBiz.getChild(&quot;State&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Zip&quot;).getText() != &quot;&quot;) newLic.setZip(unescape(lpBiz.getChild(&quot;Zip&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText() != &quot;&quot;) newLic.setPhone1(unescape(stripNN(lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText()).replace(/\+/g,&quot; &quot;)));&#xD;
			newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
			newLic.setAuditDate(sysDate);&#xD;
			newLic.setAuditID(currentUserID);&#xD;
			newLic.setAuditStatus(&quot;A&quot;);&#xD;
			newLic.setLicenseType(rlpType);&#xD;
			newLic.setLicState(&quot;CA&quot;);  // hardcode CA&#xD;
			newLic.setStateLicense(licNum);&#xD;
&#xD;
			if (lpBiz.getChild(&quot;IssueDt&quot;).getText()) newLic.setLicenseIssueDate(aa.date.parseDate(lpBiz.getChild(&quot;IssueDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ExpireDt&quot;).getText()) newLic.setLicenseExpirationDate(aa.date.parseDate(lpBiz.getChild(&quot;ExpireDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ReissueDt&quot;).getText()) newLic.setLicenseLastRenewalDate(aa.date.parseDate(lpBiz.getChild(&quot;ReissueDt&quot;).getText()));&#xD;
&#xD;
			var wcs = root.getChild(&quot;WorkersComp&quot;).getChildren();&#xD;
&#xD;
			for (var j=0 ; j&lt;wcs.size(); j++) {&#xD;
				wc = wcs.get(j);&#xD;
&#xD;
				if (wc.getAttribute(&quot;PolicyNo&quot;).getValue()) newLic.setWcPolicyNo(wc.getAttribute(&quot;PolicyNo&quot;).getValue());&#xD;
				if (wc.getAttribute(&quot;InsCoCde&quot;).getValue()) newLic.setWcInsCoCode(unescape(wc.getAttribute(&quot;InsCoCde&quot;).getValue()));&#xD;
				if (wc.getAttribute(&quot;WCEffDt&quot;).getValue()) newLic.setWcEffDate(aa.date.parseDate(wc.getAttribute(&quot;WCEffDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCExpDt&quot;).getValue()) newLic.setWcExpDate(aa.date.parseDate(wc.getAttribute(&quot;WCExpDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCCancDt&quot;).getValue()) newLic.setWcCancDate(aa.date.parseDate(wc.getAttribute(&quot;WCCancDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;Exempt&quot;).getValue() == &quot;E&quot;) newLic.setWcExempt(&quot;Y&quot;); else newLic.setWcExempt(&quot;N&quot;);&#xD;
&#xD;
				break; // only use first&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// Do the refresh/create and get the sequence number&#xD;
			//&#xD;
			if (updating)&#xD;
				{&#xD;
				var myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
				var licSeqNbr = newLic.getLicSeqNbr();&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
				if (!myResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;**WARNING: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
					continue;&#xD;
					}&#xD;
&#xD;
				var licSeqNbr = myResult.getOutput()&#xD;
				}&#xD;
&#xD;
			logDebug(&quot;Successfully added/updated License No. &quot; + licNum + &quot;, Type: &quot; + rlpType + &quot; Sequence Number &quot; + licSeqNbr);&#xD;
&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data -- first copy from the transactional LP if it exists&#xD;
			/////&#xD;
&#xD;
&#xD;
			if (isObject)  // update the reference LP with attributes from the transactional, if we have some.&#xD;
				{&#xD;
				var attrArray = licObj.getAttributes();&#xD;
&#xD;
				if (attrArray)&#xD;
					{&#xD;
					for (var k in attrArray)&#xD;
						{&#xD;
						var attr = attrArray[k];&#xD;
						editRefLicProfAttribute(licNum,attr.getAttributeName(),attr.getAttributeValue());&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data&#xD;
			/////&#xD;
			/////  NOTE!  Agencies may have to configure template data below based on their configuration.  Please note all edits&#xD;
			/////&#xD;
&#xD;
			var cbs = root.getChild(&quot;Classifications&quot;).getChildren();&#xD;
			for (var m=0 ; m&lt;cbs.size(); m++) {&#xD;
				cb = cbs.get(m);&#xD;
&#xD;
				if (m == 0)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 1&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 1&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 1)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 2&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 2&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				if (m == 2)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 3&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 3&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 3)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 4&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 4&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				}&#xD;
&#xD;
			var bos = root.getChild(&quot;ContractorBond&quot;).getChildren();&#xD;
&#xD;
			for (var n=0 ; n&lt;bos.size(); n++) {&#xD;
				var bo = bos.get(n);&#xD;
				if (bo.getAttribute(&quot;BondAmt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND AMOUNT&quot;,unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()));&#xD;
				if (bo.getAttribute(&quot;BondCancDt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND EXPIRATION&quot;,unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()));&#xD;
&#xD;
				// Currently unused but could be loaded into custom attributes.&#xD;
/*&#xD;
				aa.print(&quot;Bond Surety Type       : &quot; + unescape(bo.getAttribute(&quot;SuretyTp&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Code              : &quot; + unescape(bo.getAttribute(&quot;InsCoCde&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Insurance Company : &quot; + unescape(bo.getAttribute(&quot;InsCoName&quot;).getValue()).replace(/\+/g,&quot; &quot;))&#xD;
				aa.print(&quot;Bond Number            : &quot; + unescape(bo.getAttribute(&quot;BondNo&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Amount            : &quot; + unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Effective Date    : &quot; + unescape(bo.getAttribute(&quot;BondEffDt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Cancel Date       : &quot; + unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()))&#xD;
*/&#xD;
				break; // only use first bond&#xD;
				}&#xD;
&#xD;
			if (doPopulateTrx)&#xD;
				{&#xD;
				var lpsmResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,licSeqNbr)&#xD;
					if (!lpsmResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING error retrieving the LP just created &quot; + lpsmResult.getErrorMessage()) ; }&#xD;
&#xD;
				var lpsm = lpsmResult.getOutput();&#xD;
&#xD;
				// Remove from CAP&#xD;
&#xD;
				var isPrimary = false;&#xD;
&#xD;
				for (var currLic in capLicenseArr)&#xD;
					{&#xD;
					var thisLP = capLicenseArr[currLic];&#xD;
					if (thisLP.getLicenseType() == rlpType &amp;&amp; thisLP.getLicenseNbr() == licNum)&#xD;
						{&#xD;
						logDebug(&quot;Removing license: &quot; + thisLP.getLicenseNbr() + &quot; from CAP.  We will link the new reference LP&quot;);&#xD;
						if (thisLP.getPrintFlag() == &quot;Y&quot;)&#xD;
							{&#xD;
							logDebug(&quot;...remove primary status...&quot;);&#xD;
							isPrimary = true;&#xD;
							thisLP.setPrintFlag(&quot;N&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisLP);&#xD;
							}&#xD;
						var remCapResult = aa.licenseProfessional.removeLicensedProfessional(thisLP);&#xD;
						if (capLicenseResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;...Success.&quot;); }&#xD;
						else&#xD;
							{ logDebug(&quot;**WARNING removing lic prof: &quot; + remCapResult.getErrorMessage()); }&#xD;
						}&#xD;
					}&#xD;
&#xD;
				// add the LP to the CAP&#xD;
				var asCapResult= aa.licenseScript.associateLpWithCap(itemCap,lpsm)&#xD;
				if (!asCapResult.getSuccess())&#xD;
				{ logDebug(&quot;**WARNING error associating CAP to LP: &quot; + asCapResult.getErrorMessage()) }&#xD;
				else&#xD;
					{ logDebug(&quot;Associated the CAP to the new LP&quot;) }&#xD;
&#xD;
				// Now make the LP primary again&#xD;
				if (isPrimary)&#xD;
					{&#xD;
					var capLps = getLicenseProfessional(itemCap);&#xD;
&#xD;
					for (var thisCapLpNum in capLps)&#xD;
						{&#xD;
						if (capLps[thisCapLpNum].getLicenseNbr().equals(licNum))&#xD;
							{&#xD;
							var thisCapLp = capLps[thisCapLpNum];&#xD;
							thisCapLp.setPrintFlag(&quot;Y&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisCapLp);&#xD;
							logDebug(&quot;Updated primary flag on Cap LP : &quot; + licNum);&#xD;
&#xD;
							// adding this return will cause the test script to work without error, even though this is the last statement executed&#xD;
							//if (returnMessage.length &gt; 0) return returnMessage;&#xD;
							//else return null;&#xD;
&#xD;
							}&#xD;
						}&#xD;
				}&#xD;
			} // do populate on the CAP&#xD;
		} // do populate on the REF&#xD;
	} // for each license&#xD;
&#xD;
	if (returnMessage.length &gt; 0) return returnMessage;&#xD;
	else return null;&#xD;
&#xD;
} // end function&#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	}&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
function feeCopyByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			 addFee(ffeObjArr[ff].getFeeCod(),  ffeObjArr[ff].getFeeSchudle() ,  ffeObjArr[ff].getPaymentPeriod() ,  ffeObjArr[ff].getFeeUnit() ,    'Y') &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
function getChildTasks(taskName) {&#xD;
    var childTasks = new Array();&#xD;
    var childId = null;&#xD;
    var itemCap = capId&#xD;
    if (arguments.length &gt; 1)&#xD;
        itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
    var wfObj = workflowResult.getOutput();&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getTaskDescription().equals(taskName)) {&#xD;
            var relationArray = aa.workflow.getProcessRelationByCapID(itemCap, null).getOutput()&#xD;
            for (thisRel in relationArray) {&#xD;
                y = relationArray[thisRel]&#xD;
                if (y.getParentTaskName() &amp;&amp; y.getParentTaskName().equals(fTaskSM.getTaskDescription()))&#xD;
                    childId = y.getProcessID()&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getProcessID() == childId)&#xD;
            childTasks.push(fTaskSM)&#xD;
    }&#xD;
&#xD;
    return childTasks;&#xD;
&#xD;
}&#xD;
&#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0];&#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // we are in a page flow script so use the capModel to get contacts&#xD;
		{&#xD;
		capContactArray = cap.getContactsGroup().toArray() ;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var capContactArray = capContactResult.getOutput();&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	if (capContactArray)&#xD;
		{&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;middleName&quot;] = capContactArray[yy].getPeople().middleName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;&#xD;
&#xD;
			if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // using capModel to get contacts&#xD;
				var pa = capContactArray[yy].getPeople().getAttributes().toArray();&#xD;
			else&#xD;
				var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);&#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}&#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
  function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
function getLastScheduledInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector that is assigned to the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function getLicenseProfessional(itemcapId)&#xD;
{&#xD;
	capLicenseArr = null;&#xD;
	var s_result = aa.licenseProfessional.getLicenseProf(itemcapId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capLicenseArr = s_result.getOutput();&#xD;
		if (capLicenseArr == null || capLicenseArr.length == 0)&#xD;
		{&#xD;
			aa.print(&quot;WARNING: no licensed professionals on this CAP:&quot; + itemcapId);&#xD;
			capLicenseArr = null;&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to license professional: &quot; + s_result.getErrorMessage());&#xD;
		capLicenseArr = null;&#xD;
	}&#xD;
	return capLicenseArr;&#xD;
}&#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; newLicArray[thisLic] &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    }&#xD;
&#xD;
function isReadyRenew(capid) {&#xD;
    if (capid == null || aa.util.instanceOfString(capid)) {&#xD;
        return false;&#xD;
    }&#xD;
    var result = aa.expiration.isExpiredLicenses(capid);&#xD;
    if (result.getSuccess()) {&#xD;
        return true;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Failed to get expiration with CAP(&quot; + capid + &quot;): &quot; + result.getErrorMessage());&#xD;
    }&#xD;
    return false;&#xD;
}&#xD;
&#xD;
function isRenewProcess(parentCapID, partialCapID) {&#xD;
    //1. Check to see parent CAP ID is null.&#xD;
    if (parentCapID == null || partialCapID == null)&#xD;
    { logDebug(&quot;ERROR: the parentCapID or the partialCap ID is null&quot;); return false; }&#xD;
    //2. Get CAPModel by PK for partialCAP.&#xD;
    var result = aa.cap.getCap(partialCapID);&#xD;
    if (result.getSuccess()) {&#xD;
        capScriptModel = result.getOutput();&#xD;
        //2.1. Check to see if it is partial CAP.&#xD;
        if (capScriptModel.isCompleteCap()) {&#xD;
            logDebug(&quot;ERROR: It is not partial CAP(&quot; + capScriptModel.getCapID() + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Fail to get CAPModel (&quot; + partialCapID + &quot;): &quot; + result.getErrorMessage());&#xD;
        return false;&#xD;
    }&#xD;
    //3.  Check to see if the renewal was initiated before.&#xD;
    result = aa.cap.getProjectByMasterID(parentCapID, &quot;Renewal&quot;, &quot;Incomplete&quot;);&#xD;
    if (result.getSuccess()) {&#xD;
        partialProjects = result.getOutput();&#xD;
        if (partialProjects != null &amp;&amp; partialProjects.length &gt; 0) {&#xD;
            //Avoid to initiate renewal process multiple times.&#xD;
            logDebug(&quot;Warning: Renewal process was initiated before. ( &quot; + parentCapID + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
&#xD;
    }&#xD;
    //4 . Check to see if parent CAP is ready for renew.&#xD;
    return isReadyRenew(parentCapID);&#xD;
}&#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function licenseObject(licnumber)  // optional renewal Cap ID -- uses the expiration on the renewal CAP.&#xD;
	{&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
&#xD;
   	b1ExpResult = aa.expiration.getLicensesByCapID(itemCap)&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
			tmpDate = this.b1Exp.getExpDate();&#xD;
			if (tmpDate)&#xD;
				this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
			this.b1Status = this.b1Exp.getExpStatus();&#xD;
			logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + b1ExpResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function loadAddressAttributes(thisArr)&#xD;
{&#xD;
	//&#xD;
	// Returns an associative array of Address Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
   	var capAddressResult = aa.address.getAddressWithAttributeByCapId(itemCap);&#xD;
   	if (capAddressResult.getSuccess())&#xD;
   		var fcapAddressObj = capAddressResult.getOutput();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddressResult.getErrorType() + &quot;:&quot; + capAddressResult.getErrorMessage())&#xD;
&#xD;
  	for (i in fcapAddressObj)&#xD;
  	{&#xD;
  		addressAttrObj = fcapAddressObj[i].getAttributes().toArray();&#xD;
  		for (z in addressAttrObj)&#xD;
			thisArr[&quot;AddressAttribute.&quot; + addressAttrObj[z].getB1AttributeName()]=addressAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;AddressAttribute.PrimaryFlag&quot;] = fcapAddressObj[i].getPrimaryFlag();&#xD;
		thisArr[&quot;AddressAttribute.HouseNumberStart&quot;] = fcapAddressObj[i].getHouseNumberStart();&#xD;
		thisArr[&quot;AddressAttribute.StreetDirection&quot;] = fcapAddressObj[i].getStreetDirection();&#xD;
		thisArr[&quot;AddressAttribute.StreetName&quot;] = fcapAddressObj[i].getStreetName();&#xD;
		thisArr[&quot;AddressAttribute.StreetSuffix&quot;] = fcapAddressObj[i].getStreetSuffix();&#xD;
		thisArr[&quot;AddressAttribute.City&quot;] = fcapAddressObj[i].getCity();&#xD;
		thisArr[&quot;AddressAttribute.State&quot;] = fcapAddressObj[i].getState();&#xD;
		thisArr[&quot;AddressAttribute.Zip&quot;] = fcapAddressObj[i].getZip();&#xD;
		thisArr[&quot;AddressAttribute.AddressStatus&quot;] = fcapAddressObj[i].getAddressStatus();&#xD;
		thisArr[&quot;AddressAttribute.County&quot;] = fcapAddressObj[i].getCounty();&#xD;
		thisArr[&quot;AddressAttribute.Country&quot;] = fcapAddressObj[i].getCountry();&#xD;
		thisArr[&quot;AddressAttribute.AddressDescription&quot;] = fcapAddressObj[i].getAddressDescription();&#xD;
		thisArr[&quot;AddressAttribute.XCoordinate&quot;] = fcapAddressObj[i].getXCoordinator();&#xD;
		thisArr[&quot;AddressAttribute.YCoordinate&quot;] = fcapAddressObj[i].getYCoordinator();&#xD;
  	}&#xD;
}&#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
      var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		var readOnly = 'N';&#xD;
		if (readOnlyi.hasNext()) {&#xD;
			readOnly = readOnlyi.next();&#xD;
		}&#xD;
		var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
		tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
		}&#xD;
		tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	}&#xD;
&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
	  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
				}&#xD;
&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
			//tempObject[tcol.getColumnName()] = tval;&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadASITablesBefore() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	//&#xD;
&#xD;
	var gm =  aa.env.getValue(&quot;AppSpecificTableGroupModel&quot;);&#xD;
	var ta = gm.getTablesMap().values()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
		  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator();&#xD;
&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
			}&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
          eval(copyStr);  // move to table name&#xD;
&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
&#xD;
function loadGuideSheetItems(inspId) {&#xD;
	//&#xD;
	// Returns an associative array of Guide Sheet Items&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var retArray = new Array()&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var r = aa.inspection.getInspections(itemCap)&#xD;
&#xD;
	if (r.getSuccess())&#xD;
	 	{&#xD;
		var inspArray = r.getOutput();&#xD;
&#xD;
		for (i in inspArray)&#xD;
			{&#xD;
			if (inspArray[i].getIdNumber() == inspId)&#xD;
				{&#xD;
				var inspModel = inspArray[i].getInspection();&#xD;
&#xD;
				var gs = inspModel.getGuideSheets()&#xD;
&#xD;
				if (gs)&#xD;
					{&#xD;
					gsArray = gs.toArray();&#xD;
					for (var loopk in gsArray)&#xD;
						{&#xD;
						var gsItems = gsArray[loopk].getItems().toArray()&#xD;
						for (var loopi in gsItems)&#xD;
							retArray[gsItems[loopi].getGuideItemText()] = gsItems[loopi].getGuideItemStatus();&#xD;
						}&#xD;
					} // if there are guidesheets&#xD;
				else&#xD;
					logDebug(&quot;No guidesheets for this inspection&quot;);&#xD;
				} // if this is the right inspection&#xD;
			} // for each inspection&#xD;
		} // if there are inspections&#xD;
&#xD;
	logDebug(&quot;loaded &quot; + retArray.length + &quot; guidesheet items&quot;);&#xD;
	return retArray;&#xD;
	}&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + (fTask.getStatusDate().getMonth() + 1) + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
function logDebug(dstr) {&#xD;
&#xD;
    if (!aa.calendar.getNextWorkDay) {&#xD;
&#xD;
		vLevel = 1&#xD;
		if (arguments.length &gt; 1)&#xD;
			vLevel = arguments[1]&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
			debug += dstr + br;&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel)&#xD;
			aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr)&#xD;
		}&#xD;
	else {&#xD;
			debug+=dstr + br;&#xD;
		}&#xD;
&#xD;
}&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
function lookupFeesByValuationSlidingScale(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 2;&#xD;
	if (arguments.length == 4) valNumber = (arguments[3] + 1);&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
                        &#xD;
                        &#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 2)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					var divisor = workVals[1];&#xD;
					saveVal = parseInt((capval - workVals[0])/divisor);&#xD;
					if ((capval - workVals[0]) % divisor &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function prepareRenewal() {&#xD;
&#xD;
    if (isRenewProcess(parentCapId, capId)) {&#xD;
        logDebug(&quot;CAPID(&quot; + parentCapId + &quot;) is ready for renew. PartialCap (&quot; + capId + &quot;)&quot;);&#xD;
&#xD;
        //Associate partial cap with parent CAP.&#xD;
        var result = aa.cap.createRenewalCap(parentCapId, capId, true);&#xD;
        if (result.getSuccess()) {&#xD;
            // Set B1PERMIT.B1_ACCESS_BY_ACA to &quot;N&quot; for partial CAP to not allow that it is searched by ACA user.&#xD;
            aa.cap.updateAccessByACA(capId, &quot;N&quot;);&#xD;
        }&#xD;
        else&#xD;
        { logDebug(&quot;ERROR: Associate partial cap with parent CAP. &quot; + result.getErrorMessage()); return false };&#xD;
&#xD;
        return true;&#xD;
    }&#xD;
    else&#xD;
    { logDebug(&quot;Renewal Process did not finish properly&quot;); return false; }&#xD;
}&#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function removeAllFees(itemCap) // Removes all non-invoiced fee items for a CAP ID&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByCapID(itemCap);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
&#xD;
				var editResult = aa.finance.removeFeeItem(itemCap, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + feeList[feeNum].getFeeCod());&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+feeList[feeNum].getFeeCod()+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
	}&#xD;
&#xD;
	function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.removeAppSpecificTableInfos(tableName,itemCap,currentUserID)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ aa.print(&quot;**WARNING: error removing ASI table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
        else&#xD;
	logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function replaceMessageTokens(m)&#xD;
	{&#xD;
	//  tokens in pipes will attempt to interpret as script variables&#xD;
	//  tokens in curly braces will attempt to replace from AInfo (ASI, etc)&#xD;
	//&#xD;
	//  e.g.   |capId|  or |wfTask|  or |wfStatus|&#xD;
	//&#xD;
	//  e.g.   {Expiration Date}  or  {Number of Electrical Outlets}&#xD;
	//&#xD;
	//  e.g.   m = &quot;Your recent license application (|capIdString|) has successfully passed |wfTask| with a status of |wfStatus|&quot;&#xD;
&#xD;
	while (m.indexOf(&quot;|&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;|&quot;)&#xD;
	  var e = m.indexOf(&quot;|&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;typeof(&quot; + r + &quot;) != \&quot;undefined\&quot; ? &quot; + r + &quot; : \&quot;undefined\&quot;&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\|&quot; + r + &quot;\\|&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
	  }&#xD;
&#xD;
	while (m.indexOf(&quot;{&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;{&quot;)&#xD;
	  var e = m.indexOf(&quot;}&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;AInfo[\&quot;&quot; + r + &quot;\&quot;]&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\{&quot; + r + &quot;\\}&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
&#xD;
	  }&#xD;
&#xD;
	 return m&#xD;
	 }&#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID.&#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm&#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3)&#xD;
		if (arguments[2] != null)&#xD;
			{&#xD;
			var inspRes = aa.person.getUser(arguments[2]);&#xD;
			if (inspRes.getSuccess())&#xD;
				inspectorObj = inspRes.getOutput();&#xD;
			}&#xD;
&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
&#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
function stripNN(fullStr) {&#xD;
    var allowed = &quot;0123456789.&quot;;&#xD;
    var stripped = &quot;&quot;;&#xD;
    for (i = 0; i &lt; fullStr.length(); i++)&#xD;
        if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
        stripped += String.fromCharCode(fullStr.charAt(i))&#xD;
    return stripped;&#xD;
}&#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*&#xD;
DQ 09/03/2009 - Added Check to ensure Task status date is not null prior to getting status date&#xD;
Function will return false on fail&#xD;
*/&#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
	            if (fTask.getStatusDate() != null)&#xD;
	                return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
	            else&#xD;
	                { logMessage(&quot;**ERROR: NULL workflow task &quot;+fTask.getTaskDescription()+&quot; status date. &quot;); return false; }&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap, &quot;APPLICATION&quot;, stat, sysDate, cmt, systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
}&#xD;
&#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq)&#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
    // 12/22/2008 - DQ - Correct Invoice loop to accumulate instead of reset each iteration&#xD;
&#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)&#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
&#xD;
    var invFeeFound=false;&#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = adjustedQty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) )&#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
&#xD;
	return feeSeq;&#xD;
	}&#xD;
&#xD;
&#xD;
function updateRefParcelToCap() //Takes Optional CapId&#xD;
{&#xD;
	var vCapId = null;&#xD;
	if (arguments.length &gt; 0)&#xD;
		vCapId = arguments[0];&#xD;
	else&#xD;
		vCapId = capId;&#xD;
&#xD;
    var capPrclArr = aa.parcel.getParcelDailyByCapID(vCapId,null).getOutput();&#xD;
    if(capPrclArr != null)&#xD;
    {&#xD;
        for (x in capPrclArr)&#xD;
        {&#xD;
	        var prclObj = aa.parcel.getParceListForAdmin(capPrclArr[x].getParcelNumber(), null, null, null, null, null, null, null, null, null);&#xD;
	        if (prclObj.getSuccess() )&#xD;
	        {&#xD;
		        var prclArr = prclObj.getOutput();&#xD;
		        if (prclArr.length)&#xD;
		        {&#xD;
			        var prcl = prclArr[0].getParcelModel();&#xD;
			        var capPrclObj = aa.parcel.warpCapIdParcelModel2CapParcelModel(vCapId, prcl);&#xD;
&#xD;
			        if (capPrclObj.getSuccess())&#xD;
			        {&#xD;
&#xD;
				        var capPrcl = capPrclObj.getOutput();&#xD;
				        aa.parcel.updateDailyParcelWithAPOAttribute(capPrcl);	&#xD;
				        logDebug(&quot;Updated Parcel &quot; + capPrclArr[x].getParcelNumber() + &quot; with Reference Data&quot;);&#xD;
			        }&#xD;
			        else&#xD;
				        logDebug(&quot;Failed to Wrap Parcel Model for &quot; + capPrclArr[x].getParcelNumber());&#xD;
&#xD;
		        }&#xD;
		        else&#xD;
			        logDebug(&quot;No matching reference Parcels found for &quot; + capPrclArr[x].getParcelNumber());&#xD;
	        }&#xD;
	        else&#xD;
		        logDebug(&quot;Failed to get reference Parcel for &quot; + capPrclArr[x].getParcelNumber())&#xD;
	    }&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskDepartment(wfstr,wfDepartment) // optional process name&#xD;
	{&#xD;
	// Update the task assignment department&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
        var assignBureau = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[2];&#xD;
	var assignDivision = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[3];&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
        for (var i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
                if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
 			{&#xD;
			if (wfDepartment)&#xD;
				{&#xD;
				var taskUserObj = fTask.getTaskItem().getAssignedUser()&#xD;
				taskUserObj.setBureauCode(assignBureau);&#xD;
				taskUserObj.setDivisionCode(assignDivision);&#xD;
				fTask.setAssignedUser(taskUserObj);&#xD;
        			var taskItem = fTask.getTaskItem();&#xD;
&#xD;
				var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Department Set to &quot; + assignBureau);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update Department.  Invalid department : &quot; + assignBureau);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel()&#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
&#xD;
	}&#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><initializer></initializer><title>FeeAssessBefore</title></script><scriptName>FeeAssessBefore</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>InspectionMultipleScheduleAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:51:39.240-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>InspectionMultipleScheduleAfter</name><auditModel><auditDate>2010-04-06T07:15:06.890-06:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after one or multiple inspections are scheduled for Manage Inspection.</description></event><scriptName>InspectionMultipleScheduleAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>InspectionMultipleScheduleBefore</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:51:54.707-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>InspectionMultipleScheduleBefore</name><auditModel><auditDate>2010-04-06T07:15:06.890-06:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs before one or multiple inspections are scheduled for Manage Inspection.</description></event><scriptName>InspectionMultipleScheduleBefore</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>InspectionResultSubmitAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:52:11.587-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>InspectionResultSubmitAfter</name><auditModel><auditDate>2002-03-15T14:09:23-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after inspection result is entered.</description></event><script><name>INSPECTIONRESULTSUBMITAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2010-01-18T16:48:27-07:00</auditDate><auditID>JCIPRIANO</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: InspectionResultSubmitAfter.js 3600 2008-10-27 21:36:24Z dane.quatacker $&#xD;
| Program : InspectionResultSubmitAfterV1.5.js&#xD;
| Event   : InspectionResultSubmitAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
| Script Modified by: McKenzie Johnson/TruePointSoluions  01/05/2010 - Replaced dateAdd function with previous 1.4 version.&#xD;
|                     Current funtction as not returning the correct number of working days when added to a date.&#xD;
|                     Joseph Cipriano/TruePoint Solutions  12/29/2009 - Added new function: &quot;getGuideSheetTotalScore&quot;&#xD;
|                     to return Guidesheet Total Score.&#xD;
|                     Joseph Cipriano/TruePoint Solutions  1/18/2140 - Added variable and code to pull first Cap Address.&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;InspectionResultSubmitAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup;&#xD;
var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;MM/DD/YYYY&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
// get first address for emails&#xD;
var CapAddress = &quot;&quot;;&#xD;
capAddressResult1 = aa.address.getAddressByCapId(capId);&#xD;
if (capAddressResult1.getSuccess())&#xD;
            {&#xD;
            Address = capAddressResult1.getOutput();&#xD;
            for (yy in Address)&#xD;
                        {&#xD;
                        CapAddress = Address[yy].getHouseNumberStart();&#xD;
                        if (Address[yy].getStreetDirection())&#xD;
                                    CapAddress += &quot; &quot; + Address[yy].getStreetDirection();&#xD;
                        CapAddress += &quot; &quot; + Address[yy].getStreetName();&#xD;
                        if (Address[yy].getStreetSuffix())&#xD;
                                    CapAddress += &quot; &quot; + Address[yy].getStreetSuffix();&#xD;
                        if (Address[yy].getUnitStart())&#xD;
                                    CapAddress += &quot; &quot; + Address[yy].getUnitStart();&#xD;
                        CapAddress += &quot;, &quot; + Address[yy].getCity();&#xD;
                        CapAddress += &quot; &quot; + Address[yy].getZip();&#xD;
                        }&#xD;
            }           &#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;CapAddress = &quot; + CapAddress);&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;sysDateMMDDYYYY = &quot; + sysDateMMDDYYYY);&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var inspTypeArr = aa.env.getValue(&quot;InspectionType&quot;).split(&quot;,&quot;);   	// Submitted Inspection Type Array&#xD;
var inspResultArr = aa.env.getValue(&quot;InspectionResult&quot;).split(&quot;,&quot;);   	// Submitted Inspection Result Array&#xD;
var inspIdArr = aa.env.getValue(&quot;InspectionId&quot;).split(&quot;,&quot;);		// Inspection identifier Array&#xD;
// Main Loop is affected by number of inspections, see below&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
for (inspCount in inspIdArr)&#xD;
	{&#xD;
	inspId = inspIdArr[inspCount];&#xD;
	inspResult = inspResultArr[inspCount];&#xD;
	inspType = inspTypeArr[inspCount];&#xD;
	inspObj = aa.inspection.getInspection(capId,inspId).getOutput();  // current inspection object&#xD;
	inspGroup = inspObj.getInspection().getInspectionGroup();&#xD;
	inspResultComment = inspObj.getInspection().getResultComment();&#xD;
	inspResultDate = inspObj.getInspectionStatusDate().getMonth() + &quot;/&quot; + inspObj.getInspectionStatusDate().getDayOfMonth() + &quot;/&quot; + inspObj.getInspectionStatusDate().getYear();&#xD;
	inspSchedDate = inspObj.getScheduledDate().getMonth() + &quot;/&quot; + inspObj.getScheduledDate().getDayOfMonth() + &quot;/&quot; + inspObj.getScheduledDate().getYear();&#xD;
	logDebug(&quot;Inspection #&quot; + inspCount);&#xD;
	logDebug(&quot;inspId &quot; + inspIdArr[inspCount]);&#xD;
	logDebug(&quot;inspResult = &quot; + inspResultArr[inspCount]);&#xD;
	logDebug(&quot;inspResultComment = &quot; + inspResultComment);&#xD;
	logDebug(&quot;inspResultDate = &quot; + inspResultDate);&#xD;
	logDebug(&quot;inspGroup = &quot; + inspGroup);&#xD;
	logDebug(&quot;inspType = &quot; + inspType);&#xD;
	logDebug(&quot;inspSchedDate = &quot; + inspSchedDate);&#xD;
	doStandardChoiceActions(controlString,true,0);&#xD;
	}&#xD;
&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Internal Functions and Classes (Used by this script)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
function loadAppSpecific(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
		{&#xD;
		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
		var parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
		}&#xD;
	}&#xD;
&#xD;
function loadTaskSpecific(thisArr)&#xD;
	{&#xD;
 	//&#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent)&#xD;
	{&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	var lastEvalTrue = false;&#xD;
	logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);&#xD;
	for (xx in pairObjArray)&#xD;
		{&#xD;
		doObj = pairObjArray[xx];&#xD;
		if (doExecution)&#xD;
			{&#xD;
			if (doObj.enabled)&#xD;
				if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation))&#xD;
					{&#xD;
					eval(token(doObj.act));&#xD;
					lastEvalTrue = true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					if (doObj.elseact)&#xD;
						eval(token(doObj.elseact));&#xD;
					lastEvalTrue = false;&#xD;
					}&#xD;
			}&#xD;
		else // just document&#xD;
			{&#xD;
			docWrite(&quot;|  &quot;,false,docIndent);&#xD;
			var disableString = &quot;&quot;;&#xD;
			if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
			if (doObj.elseact)&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact ,false,docIndent);&#xD;
			else&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act,false,docIndent);&#xD;
&#xD;
			for (yy in doObj.branch)&#xD;
				{&#xD;
				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);&#xD;
				}&#xD;
			}&#xD;
		} // next sAction&#xD;
	if (!doExecution) docWrite(null,true,docIndent);&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
&#xD;
function logDebug(dstr)&#xD;
	{&#xD;
	debug+=dstr + br;&#xD;
	}&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
 &#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
 &#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValueArray is an array of associative array values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
&#xD;
	for (thisrow in tableValueArray)&#xD;
		{&#xD;
		var col = tsm.getColumns()&#xD;
		var coli = col.iterator();&#xD;
&#xD;
		while (coli.hasNext())&#xD;
			{&#xD;
			var colname = coli.next();&#xD;
			fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			logDebug(&quot;Table: &quot; + tableName + &quot; Row:&quot; + thisrow + &quot; Column: &quot; + colname.getColumnName() + &quot; Value: &quot; + tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			}&#xD;
&#xD;
		tsm.setTableField(fld);&#xD;
&#xD;
		if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
		}&#xD;
&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
&#xD;
	// Even when this works it gives an index out of range error&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
 &#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
	        	if (addCapCondResult.getSuccess())&#xD;
	        		{&#xD;
				logMessage(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
	var col = tsm.getColumns()&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
		fld.add(tableValues[colname.getColumnName()]);&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
&#xD;
	if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
 &#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
 &#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
 &#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
 &#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
 &#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	} &#xD;
function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	} &#xD;
function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	} &#xD;
function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	} &#xD;
function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	 &#xD;
function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
 &#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
} &#xD;
function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
 &#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	//check if target CAP has primary address	&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
		&#xD;
	//get addresses from originating CAP	&#xD;
	var capAddressResult = aa.address.getAddressByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddress(newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional fields to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
 &#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
 &#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
 &#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
 &#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	 &#xD;
function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
 &#xD;
function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAdd(td,amt)   &#xD;
	// perform date arithmetic on a string &#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days &#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
	&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3) &#xD;
		useWorking = true;&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		while (i &lt; Math.abs(amt)) &#xD;
			{&#xD;
			dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
			if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
				i++&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
 &#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
 &#xD;
function deactivateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logMessage(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
		{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
		}&#xD;
   	&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
			{&#xD;
				while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
				{&#xD;
					if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
					{&#xD;
						appspecObj[i].setChecklistComment(itemValue);&#xD;
						var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
						if (actionResult.getSuccess()) {&#xD;
							logMessage(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
							logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
						} else {&#xD;
							logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
						}&#xD;
						updated = true;&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
					}&#xD;
					i++;&#xD;
				} // while loop&#xD;
			} // item name blank&#xD;
		} // got app specific object	&#xD;
		else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
} &#xD;
function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	} &#xD;
function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
 &#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
	&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
   	&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = Contacts[yy].getEmail();&#xD;
		}	&#xD;
&#xD;
	if (emailAddress.length) &#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no email address&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	} &#xD;
&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
 &#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0]; &#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var capContactArray = capContactResult.getOutput();&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;			&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;			&#xD;
			aArray[&quot;email&quot;] = capContactArray[yy].getPeople().email;&#xD;
			aArray[&quot;addressLine1&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine1();&#xD;
			aArray[&quot;addressLine2&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine2();&#xD;
			aArray[&quot;city&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCity();&#xD;
			aArray[&quot;state&quot;] = capContactArray[yy].getPeople().getCompactAddress().getState();&#xD;
			aArray[&quot;zip&quot;] = capContactArray[yy].getPeople().getCompactAddress().getZip();&#xD;
			aArray[&quot;fax&quot;] = capContactArray[yy].getPeople().fax;&#xD;
			aArray[&quot;notes&quot;] = capContactArray[yy].getPeople().notes;&#xD;
			aArray[&quot;country&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCountry();&#xD;
			aArray[&quot;fullName&quot;] = capContactArray[yy].getPeople().fullName;&#xD;
&#xD;
&#xD;
			var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);                &#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}	&#xD;
&#xD;
 &#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
 &#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
   &#xD;
function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
 &#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
 &#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	} &#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
 &#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
 &#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))  &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    } &#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
 &#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	} &#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
&#xD;
function licenseObject(licnumber)&#xD;
	{&#xD;
	// available statuses (from various R1_SERVER_CONSTANT values&#xD;
	var licenseStatus = new Array(&quot;&quot;,&quot;Active&quot;,&quot;About To Expire&quot;,&quot;Delinquent&quot;,&quot;Expired&quot;,&quot;Invalid&quot;,&quot;Pending&quot;);&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
   	// The only way to pull up a renewal is to supply a status.  I don't understand since it has a 1 to 1 relationship with b1permit, but oh well.&#xD;
   	// the silly thing returns a blank record, so have to check the B1expirationModel to see if it's valid&#xD;
&#xD;
   	for (myStatus in licenseStatus)&#xD;
   		{&#xD;
   		b1ExpResult = aa.expiration.getLicensesByCapID(capId,licenseStatus[myStatus]);&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
   			exptest = this.b1Exp.getB1Expiration();&#xD;
    			if (exptest)&#xD;
    				{&#xD;
    				tmpDate = this.b1Exp.getExpDate();&#xD;
    				if (tmpDate)&#xD;
    					this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
    				this.b1Status = this.b1Exp.getExpStatus();&#xD;
    				logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
    				break&#xD;
    				}&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
		}&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	} &#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
 &#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
 &#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr); &#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
  	&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + fTask.getStatusDate().getMonth() + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}			&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}	&#xD;
 &#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
 &#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
 &#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
 &#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;SCRIPT LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
 &#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	} &#xD;
  function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
	&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
		&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	&#xD;
	tsm.getColumns().clear();&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	&#xD;
	// Even when this works it gives an error of &quot;0&quot;&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error removing all rows from ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
 &#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID. &#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm &#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
	&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
		        &#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
 &#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    &#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
		}&#xD;
	} &#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
	{&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap,&quot;APPLICATION&quot;,stat, sysDate, cmt ,systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq) &#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
        &#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)        &#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
        &#xD;
    var invFeeFound=false;    &#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = fqty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) ) &#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
			&#xD;
	return feeSeq;&#xD;
	} &#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
	&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
	&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel() &#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
	&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
		&#xD;
	}	&#xD;
 &#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	 &#xD;
function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}&#xD;
&#xD;
function getGuideSheetTotalScore(guideSheetName)&#xD;
//Function created by: Joseph Cipriano/TruePoint Solutions 12/28/2009&#xD;
//Description: Will return the Total Score for a Guidesheet.&#xD;
{&#xD;
         var totalScore = 0;&#xD;
         //get Inspections associated to Cap&#xD;
         var capInspResult = aa.inspection.getInspections(capId);&#xD;
         if (capInspResult.getSuccess())&#xD;
         {&#xD;
             var inspList = capInspResult.getOutput();&#xD;
             for (x in inspList)&#xD;
             {&#xD;
                 //find associating inspection&#xD;
                 if (inspList[x].getIdNumber() == inspId)&#xD;
                 {&#xD;
                    //get Guidesheet associated to inspection&#xD;
                    var guideSheetList = inspList[x].getInspection().getGuideSheets().toArray();&#xD;
&#xD;
                    if (guideSheetList.length == 0)&#xD;
                    {logDebug(&quot;**ERROR: no associating Guidesheets on Inspection: &quot; + inspType + &quot;, Completed on: &quot;+ inspResultDate); return false;}&#xD;
                    else&#xD;
                    {&#xD;
                        for (g in guideSheetList)&#xD;
                        {&#xD;
                            //find associating Guidesheet&#xD;
                            if (guideSheetList[g].getGuideType() == guideSheetName)&#xD;
                            {&#xD;
                               //get guidesheet items associated to Guidesheet&#xD;
                               var guideSheetItems = guideSheetList[g].getItems().toArray();&#xD;
    &#xD;
                               if (guideSheetItems.length == 0)&#xD;
                               {logDebug(&quot;**ERROR: no associating Guidesheet with the name of: &quot; +  guideSheetName + &quot; on Inspection: &quot; + inspType + &quot;, Completed on: &quot;+ inspResultDate); return false;}&#xD;
                               else&#xD;
                               {&#xD;
                                   for (i in guideSheetItems)&#xD;
                                   {&#xD;
                                       //get guidesheet items score values&#xD;
                                       var itemScore = guideSheetItems[i].getGuideItemScore();&#xD;
                                       //check if guidesheet item score is a valid number&#xD;
                                       if (!isNaN(itemScore))&#xD;
                                       {&#xD;
                                           //total up guidesheet item score values&#xD;
                                           totalScore = totalScore + Number(itemScore);&#xD;
                                       }&#xD;
                                   }&#xD;
                                   return totalScore;&#xD;
                               }&#xD;
                            }&#xD;
                        }&#xD;
                    }&#xD;
                 }&#xD;
             }&#xD;
         }&#xD;
         else&#xD;
         {logDebug(&quot;**ERROR: getting Inspections for Cap.: &quot; + capInspResult.getErrorMessage()); return false;}&#xD;
}&#xD;
&#xD;
</content><title>InspectionResultSubmitAfter</title></script><scriptName>InspectionResultSubmitAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>InspectionScheduleAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:52:41.750-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>InspectionScheduleAfter</name><auditModel><auditDate>2002-03-15T14:09:32-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after one or multiple inspections are scheduled.</description></event><script><name>INSPECTIONSCHEDULEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2011-02-27T15:24:11.790-07:00</auditDate><auditID>KHOBDAY</auditID><auditStatus>A</auditStatus></auditModel><content>&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: InspectionScheduleAfter.js 4781 2009-10-01 05:55:23Z roland.vonschoech $&#xD;
| Program : InspectionScheduleAfterV1.6.js&#xD;
| Event   : InspectionScheduleAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   : REQUIRES the InspectionIdList event parameter.  Executes once for each scheduled inspection.&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;InspectionScheduleAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
if (!systemUserObj) systemUserObj = aa.person.getUser(&quot;ADMIN&quot;).getOutput(); // for IVR&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup = null;&#xD;
if(appTypeArray[0].substr(0,1) !=&quot;_&quot;) //Model Home Check&#xD;
{&#xD;
	var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
	if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
}&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var InspectionDate = aa.env.getValue(&quot;InspectionDate&quot;);		logDebug(&quot;InspectionDate = &quot; + InspectionDate  );&#xD;
var InspectionMode = aa.env.getValue(&quot;InspectionMode&quot;);		logDebug(&quot;InspectionMode = &quot; +  InspectionMode  );&#xD;
var InspectionTime = aa.env.getValue(&quot;InspectionTime&quot;);		logDebug(&quot;InspectionTime = &quot; + InspectionTime  );&#xD;
var InspectionType = aa.env.getValue(&quot;InspectionType&quot;);		logDebug(&quot;InspectionType = &quot; + InspectionType);&#xD;
var InspectionTypeList = aa.env.getValue(&quot;InspectionTypeList&quot;);	logDebug(&quot;InspectionTypeList = &quot; + InspectionTypeList   );&#xD;
var InspectionIdList = aa.env.getValue(&quot;InspectionIdList&quot;);	logDebug(&quot;InspectionIdList = &quot; + InspectionIdList   );&#xD;
var InspectorFirstName = aa.env.getValue(&quot;InspectorFirstName&quot;);	logDebug(&quot;InspectorFirstName = &quot; + InspectorFirstName   );&#xD;
var InspectorLastName = aa.env.getValue(&quot;InspectorLastName&quot;);	logDebug(&quot;InspectorLastName = &quot; +  InspectorLastName  );&#xD;
var InspectorMiddleName = aa.env.getValue(&quot;InspectorMiddleName&quot;);logDebug(&quot;InspectorMiddleName = &quot; + InspectorMiddleName  );&#xD;
var NumberOfInspections = aa.env.getValue(&quot;NumberOfInspections&quot;);logDebug(&quot;NumberOfInspections = &quot; +   NumberOfInspections );&#xD;
var inspTypeArr = String(InspectionTypeList).split(&quot;|&quot;);   		// Submitted Inspection Type Array&#xD;
var inspIdArr = String(InspectionIdList).split(&quot;|&quot;);			// Inspection identifier Array&#xD;
&#xD;
// Main Loop is affected by number of inspections, see below&#xD;
&#xD;
if (inspIdArr.length == 0) logDebug(&quot;WARNING: Inspection ID List is zero length.  No actions will be performed.  To rectify, the system administrator must add the InspectionIdList parameter to this event&quot;);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
for (inspCount in inspIdArr)&#xD;
	{&#xD;
	inspId = inspIdArr[inspCount];&#xD;
	inspType = inspTypeArr[inspCount];&#xD;
	inspObj = aa.inspection.getInspection(capId,inspId).getOutput();  // current inspection object&#xD;
	inspGroup = inspObj.getInspection().getInspectionGroup();&#xD;
	inspSchedDate = inspObj.getScheduledDate().getMonth() + &quot;/&quot; + inspObj.getScheduledDate().getDayOfMonth() + &quot;/&quot; + inspObj.getScheduledDate().getYear();&#xD;
	logDebug(&quot;Inspection #&quot; + inspCount);&#xD;
	logDebug(&quot;inspType = &quot; + inspType);&#xD;
	logDebug(&quot;inspObj = &quot; + inspObj.getClass());&#xD;
	logDebug(&quot;inspId =  &quot; + inspIdArr[inspCount]);&#xD;
	logDebug(&quot;inspGroup = &quot; + inspGroup);&#xD;
	logDebug(&quot;inspSchedDate = &quot; + inspSchedDate);&#xD;
	doStandardChoiceActions(controlString,true,0);&#xD;
	}&#xD;
&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
  &#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
    	{&#xD;
  	//  tableName is the name of the ASI table&#xD;
  	//  tableValueArray is an array of associative array values.  All elements MUST be either a string or asiTableVal object&#xD;
    	var itemCap = capId&#xD;
  	if (arguments.length &gt; 2)&#xD;
  		itemCap = arguments[2]; // use cap ID specified in args&#xD;
  &#xD;
  	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
  &#xD;
  	if (!tssmResult.getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
  &#xD;
  	var tssm = tssmResult.getOutput();&#xD;
  	var tsm = tssm.getAppSpecificTableModel();&#xD;
  	var fld = tsm.getTableField();&#xD;
        var fld_readonly = tsm.getReadonlyField(); // get Readonly field&#xD;
  &#xD;
         	for (thisrow in tableValueArray)&#xD;
  		{&#xD;
  &#xD;
  		var col = tsm.getColumns()&#xD;
  		var coli = col.iterator();&#xD;
  &#xD;
  		while (coli.hasNext())&#xD;
  			{&#xD;
  			var colname = coli.next();&#xD;
  &#xD;
			if (typeof(tableValueArray[thisrow][colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
				{&#xD;
	  			fld.add(tableValueArray[thisrow][colname.getColumnName()].fieldValue);&#xD;
	  			fld_readonly.add(tableValueArray[thisrow][colname.getColumnName()].readOnly);&#xD;
				}&#xD;
			else // we are passed a string&#xD;
				{&#xD;
  				fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
  				fld_readonly.add(null);&#xD;
				}&#xD;
  			}&#xD;
  &#xD;
  		tsm.setTableField(fld);&#xD;
  &#xD;
  		tsm.setReadonlyField(fld_readonly);&#xD;
  &#xD;
  		}&#xD;
  &#xD;
  	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
  &#xD;
  	 if (!addResult .getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
  	else&#xD;
  		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
  &#xD;
  	}&#xD;
  &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
&#xD;
function addFeeWithExtraData(fcode, fsched, fperiod, fqty, finvoice, feeCap, feeComment, UDF1, UDF2) {&#xD;
    var feeCapMessage = &quot;&quot;;&#xD;
    var feeSeq_L = new Array(); 			// invoicing fee for CAP in args&#xD;
    var paymentPeriod_L = new Array(); 		// invoicing pay periods for CAP in args&#xD;
&#xD;
    assessFeeResult = aa.finance.createFeeItem(feeCap, fsched, fcode, fperiod, fqty);&#xD;
    if (assessFeeResult.getSuccess()) {&#xD;
        feeSeq = assessFeeResult.getOutput();&#xD;
        logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
        logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
        fsm = aa.finance.getFeeItemByPK(feeCap, feeSeq).getOutput().getF4FeeItem();&#xD;
&#xD;
        if (feeComment) fsm.setFeeNotes(feeComment);&#xD;
        if (UDF1) fsm.setUdf1(UDF1);&#xD;
        if (UDF2) fsm.setUdf2(UDF2);&#xD;
&#xD;
        aa.finance.editFeeItem(fsm)&#xD;
&#xD;
&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
        {&#xD;
            feeSeqList.push(feeSeq);&#xD;
            paymentPeriodList.push(fperiod);&#xD;
        }&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
        {&#xD;
            feeSeq_L.push(feeSeq);&#xD;
            paymentPeriod_L.push(fperiod);&#xD;
            var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
            if (invoiceResult_L.getSuccess())&#xD;
                logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
            else&#xD;
                logDebug(&quot;**ERROR: Invoicing the fee items assessed was not successful.  Reason: &quot; + invoiceResult.getErrorMessage());&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
        return null;&#xD;
    }&#xD;
&#xD;
    return feeSeq;&#xD;
&#xD;
}&#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
function addParcelAndOwnerFromRefAddress(refAddress)  // optional capID&#xD;
	{&#xD;
&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	// first add the primary parcel&#xD;
	//&#xD;
	var primaryParcelResult = aa.parcel.getPrimaryParcelByRefAddressID(refAddress,&quot;Y&quot;);&#xD;
	if (primaryParcelResult.getSuccess())&#xD;
		var primaryParcel = primaryParcelResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get primary parcel for ref Address &quot; + refAddress + &quot; , &quot; + primaryParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var capParModel = aa.parcel.warpCapIdParcelModel2CapParcelModel(capId,primaryParcel).getOutput()&#xD;
&#xD;
	var createPMResult = aa.parcel.createCapParcel(capParModel);&#xD;
	if (createPMResult.getSuccess())&#xD;
		logDebug(&quot;created CAP Parcel&quot;);&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Failed to create the cap Parcel &quot; + createPMResult.getErrorMessage()); }&#xD;
&#xD;
&#xD;
	// Now the owners&#xD;
	//&#xD;
&#xD;
	var parcelListResult = aa.parcel.getParcelDailyByCapID(capId,null);&#xD;
	if (parcelListResult.getSuccess())&#xD;
		var parcelList = parcelListResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel List &quot; + parcelListResult.getErrorMessage()); return false; }&#xD;
&#xD;
&#xD;
	for (var thisP in parcelList)&#xD;
  		{&#xD;
  		var ownerListResult = aa.owner.getOwnersByParcel(parcelList[thisP]);&#xD;
		if (ownerListResult.getSuccess())&#xD;
			var ownerList = ownerListResult.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Failed to get Owner List &quot; + ownerListResult.getErrorMessage()); return false; }&#xD;
&#xD;
  		for (var thisO in ownerList)&#xD;
      			{&#xD;
      			ownerList[thisO].setCapID(capId);&#xD;
      			createOResult = aa.owner.createCapOwnerWithAPOAttribute(ownerList[thisO]);&#xD;
&#xD;
			if (createOResult.getSuccess())&#xD;
				logDebug(&quot;Created CAP Owner&quot;);&#xD;
			else&#xD;
				{ logDebug(&quot;**WARNING: Failed to create CAP Owner &quot; + createOResult.getErrorMessage()); }&#xD;
			}&#xD;
	      	}&#xD;
     }&#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
&#xD;
function addReferenceContactByName(vFirst, vMiddle, vLast)&#xD;
{&#xD;
	var userFirst = vFirst;&#xD;
	var userMiddle = vMiddle;&#xD;
	var userLast = vLast;&#xD;
&#xD;
	//Find PeopleModel object for user&#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
	//Add the reference contact record to the current CAP&#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
}&#xD;
function addressExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
	var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
	if (capAddResult.getSuccess())&#xD;
		var fcapAddressObj = capAddResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddResult.getErrorType() + &quot;:&quot; + capAddResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapAddressObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
			if (addCapCondResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements must be either a string or asiTableVal object&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	var col = tsm.getColumns();&#xD;
	var fld_readonly = tsm.getReadonlyField(); //get ReadOnly property&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
&#xD;
		if (typeof(tableValues[colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()].fieldValue);&#xD;
			fld_readonly.add(tableValues[colname.getColumnName()].readOnly);&#xD;
			}&#xD;
		else // we are passed a string&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()]);&#xD;
			fld_readonly.add(null);&#xD;
			}&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	tsm.setReadonlyField(fld_readonly); // set readonly field&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
&#xD;
function asiTableValObj(columnName, fieldValue, readOnly) {&#xD;
	this.columnName = columnName;&#xD;
	this.fieldValue = fieldValue;&#xD;
	this.readOnly = readOnly;&#xD;
&#xD;
	asiTableValObj.prototype.toString=function(){ return this.fieldValue }&#xD;
};&#xD;
&#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	}function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	}function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	}function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	}function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	function checkCapForLicensedProfessionalType( licProfType )&#xD;
{&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	&#xD;
	if( capLicenseResult.getSuccess() )&#xD;
	{ &#xD;
		var capLicenseArr = capLicenseResult.getOutput();&#xD;
		&#xD;
		if (!capLicenseArr)&#xD;
			{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
		&#xD;
		for( licProf in capLicenseArr )&#xD;
		{&#xD;
			if( licProfType.equals(capLicenseArr[licProf].getLicenseType()) )&#xD;
			{&#xD;
				aa.print( &quot;Found License Professional with Type= &quot; + licProfType );&#xD;
				return true; //Found Licensed Prof of specified type&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		return false;&#xD;
	}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
}function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
function closeSubWorkflow(thisProcessID,wfStat) // optional capId&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var isCompleted = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTaskSM = wfObj[i];&#xD;
		if (fTaskSM.getProcessID() == thisProcessID &amp;&amp; fTaskSM.getCompleteFlag() != &quot;Y&quot;)&#xD;
			{&#xD;
			logDebug(&quot;closeSubWorkflow: found an incomplete task processID #&quot; + thisProcessID + &quot; , Step# &quot; + fTaskSM.getStepNumber(),3);&#xD;
			isCompleted = false&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (!isCompleted) return false;&#xD;
&#xD;
&#xD;
	// get the parent task&#xD;
&#xD;
	var relationArray = aa.workflow.getProcessRelationByCapID(itemCap,null).getOutput()&#xD;
&#xD;
	var relRecord = null;&#xD;
&#xD;
	for (thisRel in relationArray)&#xD;
		if (relationArray[thisRel].getProcessID() == thisProcessID)&#xD;
			relRecord = relationArray[thisRel];&#xD;
&#xD;
	if (!relRecord)&#xD;
		{&#xD;
		logDebug(&quot;closeSubWorkflow: did not find a process relation, exiting&quot;,3);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	logDebug(&quot;executing handleDisposition:&quot; + relRecord.getStepNumber() + &quot;,&quot; + relRecord.getParentProcessID() + &quot;,&quot; + wfStat,3);&#xD;
&#xD;
	var handleResult = aa.workflow.handleDisposition(itemCap,relRecord.getStepNumber(),relRecord.getParentProcessID(),wfStat,sysDate,&quot;Closed via script&quot;,&quot;Closed via script&quot;,systemUserObj ,&quot;Y&quot;);&#xD;
&#xD;
	if (!handleResult.getSuccess())&#xD;
		logDebug(&quot;**WARNING: closing parent task: &quot; + handleResult.getErrorMessage());&#xD;
	else&#xD;
		logDebug(&quot;Closed parent task&quot;);&#xD;
	}&#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
function comparePeopleGeneric(peop)&#xD;
	{&#xD;
&#xD;
	// this function will be passed as a parameter to the createRefContactsFromCapContactsAndLink function.&#xD;
	//&#xD;
	// takes a single peopleModel as a parameter, and will return the sequence number of the first G6Contact result&#xD;
	//&#xD;
	// returns null if there are no matches&#xD;
	//&#xD;
	// current search method is by email only.  In order to use attributes enhancement 09ACC-05048 must be implemented&#xD;
	//&#xD;
&#xD;
	peop.setAuditDate(null)&#xD;
	peop.setAuditID(null)&#xD;
	peop.setAuditStatus(null)&#xD;
	peop.setBirthDate(null)&#xD;
	peop.setBusName2(null)&#xD;
	peop.setBusinessName(null)&#xD;
	peop.setComment(null)&#xD;
	peop.setCompactAddress(null)&#xD;
	peop.setContactSeqNumber(null)&#xD;
	peop.setContactType(null)&#xD;
	peop.setContactTypeFlag(null)&#xD;
	peop.setCountry(null)&#xD;
	peop.setCountryCode(null)&#xD;
	// peop.setEmail(null)       just as a test we are using email&#xD;
	peop.setEndBirthDate(null)&#xD;
	peop.setFax(null)&#xD;
	peop.setFaxCountryCode(null)&#xD;
	peop.setFein(null)&#xD;
	peop.setFirstName(null)&#xD;
	peop.setFlag(null)&#xD;
	peop.setFullName(null)&#xD;
	peop.setGender(null)&#xD;
	peop.setHoldCode(null)&#xD;
	peop.setHoldDescription(null)&#xD;
	peop.setId(null)&#xD;
	peop.setIvrPinNumber(null)&#xD;
	peop.setIvrUserNumber(null)&#xD;
	peop.setLastName(null)&#xD;
	peop.setMaskedSsn(null)&#xD;
	peop.setMiddleName(null)&#xD;
	peop.setNamesuffix(null)&#xD;
	peop.setPhone1(null)&#xD;
	peop.setPhone1CountryCode(null)&#xD;
	peop.setPhone2(null)&#xD;
	peop.setPhone2CountryCode(null)&#xD;
	peop.setPhone3(null)&#xD;
	peop.setPhone3CountryCode(null)&#xD;
	peop.setPostOfficeBox(null)&#xD;
	peop.setPreferredChannel(null)&#xD;
	peop.setPreferredChannelString(null)&#xD;
	peop.setRate1(null)&#xD;
	peop.setRelation(null)&#xD;
	peop.setSalutation(null)&#xD;
	peop.setServiceProviderCode(null)&#xD;
	peop.setSocialSecurityNumber(null)&#xD;
	peop.setTitle(null)&#xD;
	peop.setTradeName(null)&#xD;
&#xD;
	var r = aa.people.getPeopleByPeopleModel(peop);&#xD;
&#xD;
    if (!r.getSuccess())&#xD;
			{ logDebug(&quot;WARNING: error searching for people : &quot; + r.getErrorMessage()); return false; }&#xD;
&#xD;
	var peopResult = r.getOutput();&#xD;
&#xD;
	if (peopResult.length == 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for REF contact, no matches found, returing null&quot;);&#xD;
		return null;&#xD;
		}&#xD;
&#xD;
	if (peopResult.length &gt; 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for a REF Contact, &quot; + peopResult.length + &quot; matches found! returning the first match : &quot; + peopResult[0].getContactSeqNumber() );&#xD;
		return peopResult[0].getContactSeqNumber()&#xD;
		}&#xD;
&#xD;
}function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
}function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
function convertStringToPhone(theString)&#xD;
	{&#xD;
	var n = &quot;22233344455566677778889999&quot;;&#xD;
&#xD;
	var compString = String(theString.toUpperCase());&#xD;
	var retString = &quot;&quot;;&#xD;
&#xD;
	for (var x=0 ; x&lt; compString.length ; x++)&#xD;
   		{&#xD;
   		if (compString[x] &gt;= &quot;A&quot; &amp;&amp; compString[x] &lt;= &quot;Z&quot;)&#xD;
   			retString += n[compString.charCodeAt(x)-65]&#xD;
  		 else&#xD;
   			retString += compString[x];&#xD;
  		}&#xD;
   	return retString;&#xD;
 	}&#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
&#xD;
	//check if target CAP has primary address&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//get addresses from originating CAP&#xD;
	var capAddressResult = aa.address.getAddressWithAttributeByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddressWithAPOAttribute(vToCapId, newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	return copied;&#xD;
	}&#xD;
&#xD;
&#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional groups to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
&#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
&#xD;
function copyLicensedProf(sCapId, tCapId)&#xD;
{&#xD;
	//Function will copy all licensed professionals from source CapID to target CapID&#xD;
&#xD;
	var licProf = aa.licenseProfessional.getLicensedProfessionalsByCapID(sCapId).getOutput();&#xD;
	if (licProf != null)&#xD;
		for(x in licProf)&#xD;
		{&#xD;
			licProf[x].setCapID(tCapId);&#xD;
			aa.licenseProfessional.createLicensedProfessional(licProf[x]);&#xD;
			logDebug(&quot;Copied &quot; + licProf[x].getLicenseNbr());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;No licensed professional on source&quot;);&#xD;
}&#xD;
&#xD;
//Function will copy all owners from source CAP (sCapID) to target CAP (tCapId)&#xD;
function copyOwner(sCapID, tCapID)&#xD;
{&#xD;
	var ownrReq = aa.owner.getOwnerByCapId(sCapID);&#xD;
	if(ownrReq.getSuccess())&#xD;
	{&#xD;
		var ownrObj = ownrReq.getOutput();&#xD;
		for (xx in ownrObj)&#xD;
		{&#xD;
			ownrObj[xx].setCapID(tCapID);&#xD;
			aa.owner.createCapOwnerWithAPOAttribute(ownrObj[xx]);&#xD;
			logDebug(&quot;Copied Owner: &quot; + ownrObj[xx].getOwnerFullName())&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
		logDebug(&quot;Error Copying Owner : &quot; + ownrObj.getErrorType() + &quot; : &quot; + ownrObj.getErrorMessage());&#xD;
}&#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
&#xD;
function createCapComment(vComment)  //optional CapId&#xD;
{&#xD;
	var vCapId = capId;&#xD;
	if (arguments.length == 2)&#xD;
		vCapId = arguments[1];&#xD;
	var comDate = aa.date.getCurrentDate(); &#xD;
	var capCommentScriptModel= aa.cap.createCapCommentScriptModel(); &#xD;
	capCommentScriptModel.setCapIDModel(vCapId); &#xD;
	capCommentScriptModel.setCommentType(&quot;APP LEVEL COMMENT&quot;); &#xD;
	capCommentScriptModel.setSynopsis(&quot;&quot;); &#xD;
	capCommentScriptModel.setText(vComment); &#xD;
	capCommentScriptModel.setAuditUser(currentUserID); &#xD;
	capCommentScriptModel.setAuditStatus(&quot;A&quot;); &#xD;
	capCommentScriptModel.setAuditDate(comDate); &#xD;
	var capCommentModel=capCommentScriptModel.getCapCommentModel(); &#xD;
	aa.cap.createCapComment(capCommentModel); &#xD;
	logDebug(&quot;Comment Added&quot;);&#xD;
}function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createPublicUserFromContact()   // optional: Contact Type, default Applicant&#xD;
{&#xD;
    var contactType = &quot;Applicant&quot;;&#xD;
    var contact;&#xD;
    if (arguments.length &gt; 0) contactType = arguments[0]; // use contact type specified&#xD;
&#xD;
    var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
    if (capContactResult.getSuccess()) {&#xD;
        var Contacts = capContactResult.getOutput();&#xD;
        for (yy in Contacts) {&#xD;
            aa.print(Contacts[yy].getCapContactModel().getPeople().getContactType())&#xD;
            if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
                contact = Contacts[yy];&#xD;
        }&#xD;
    }&#xD;
&#xD;
    aa.print(contact.getEmail());&#xD;
    if (!contact)&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no such contact&quot;); return false; }&#xD;
&#xD;
    if (!contact.getEmail())&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no email address&quot;); return false; }&#xD;
&#xD;
    // check if exists already&#xD;
&#xD;
    var getUserResult = aa.publicUser.getPublicUserByEmail(contact.getEmail())&#xD;
    if (getUserResult.getSuccess()) {&#xD;
        var userModel = getUserResult.getOutput()&#xD;
        aa.print(&quot;found the user already&quot;);&#xD;
        if (userModel) return userModel;  // send back the existing user&#xD;
    }&#xD;
&#xD;
    // create a new one&#xD;
&#xD;
    var publicUser = aa.publicUser.getPublicUserModel();&#xD;
    publicUser.setFirstName(contact.getFirstName());&#xD;
    publicUser.setLastName(contact.getLastName());&#xD;
    publicUser.setEmail(contact.getEmail());&#xD;
    publicUser.setUserID(contact.getEmail());&#xD;
    publicUser.setPassword(&quot;7d3fe8b8d7ba80addfc296b07de60cc101e4af60&quot;); //password : Gary0813&#xD;
    publicUser.setAuditID(&quot;PublicUser&quot;);&#xD;
    publicUser.setAuditStatus(&quot;A&quot;);&#xD;
    publicUser.setCellPhone(contact.getCapContactModel().getPeople().getPhone2());&#xD;
&#xD;
    var result = aa.publicUser.createPublicUser(publicUser);&#xD;
&#xD;
    if (result.getSuccess()) {&#xD;
        logDebug(&quot;Created public user &quot; + contact.getEmail() + &quot;  sucessfully.&quot;);&#xD;
        var userSeqNum = result.getOutput();&#xD;
        var userModel = aa.publicUser.getPublicUser(userSeqNum).getOutput()&#xD;
&#xD;
        // create for agency&#xD;
        aa.publicUser.createPublicUserForAgency(userModel);&#xD;
&#xD;
        // activate for agency&#xD;
        var userPinBiz = aa.proxyInvoker.newInstance(&quot;com.accela.pa.pin.UserPINBusiness&quot;).getOutput()&#xD;
		userPinBiz.updateActiveStatusAndLicenseIssueDate4PublicUser(servProvCode,userSeqNum,&quot;ADMIN&quot;);&#xD;
		// reset password&#xD;
&#xD;
		var PUB = aa.proxyInvoker.newInstance(&quot;com.accela.v360.publicuser.PublicUserBusiness&quot;).getOutput()&#xD;
		PUB.resetPassword(contact.getEmail());&#xD;
&#xD;
        // send Activate email&#xD;
        aa.publicUser.sendActivateEmail(userModel, true, true);&#xD;
&#xD;
        // send another email&#xD;
        aa.publicUser.sendPasswordEmail(userModel);&#xD;
        return userModel;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**Warning creating public user &quot; + contact.getEmail() + &quot;  failure: &quot; + result.getErrorMessage()); return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
function createRefContactsFromCapContactsAndLink(pCapId, contactTypeArray, ignoreAttributeArray, replaceCapContact, overwriteRefContact, refContactExists)&#xD;
	{&#xD;
&#xD;
	// contactTypeArray is either null (all), or an array or contact types to process&#xD;
	//&#xD;
	// ignoreAttributeArray is either null (none), or an array of attributes to ignore when creating a REF contact&#xD;
	//&#xD;
	// replaceCapContact not implemented yet&#xD;
	//&#xD;
	// overwriteRefContact -- if true, will refresh linked ref contact with CAP contact data&#xD;
	//&#xD;
	// refContactExists is a function for REF contact comparisons.&#xD;
	//&#xD;
	var ingoreArray = new Array();&#xD;
	if (arguments.length &gt; 1) ignoreArray = arguments[1];&#xD;
&#xD;
	var c = aa.people.getCapContactByCapID(pCapId).getOutput()&#xD;
	var cCopy = aa.people.getCapContactByCapID(pCapId).getOutput()  // must have two working datasets&#xD;
&#xD;
	for (var i in c)&#xD;
	   {&#xD;
	   var con = c[i];&#xD;
&#xD;
	   var p = con.getPeople();&#xD;
	   &#xD;
	   if (contactTypeArray &amp;&amp; !exists(p.getContactType(),contactTypeArray))&#xD;
		continue;  // not in the contact type list.  Move along.&#xD;
&#xD;
	   &#xD;
	   var refContactNum = con.getCapContactModel().getRefContactNumber();&#xD;
	   if (refContactNum)  // This is a reference contact.   Let's refresh or overwrite as requested in parms.&#xD;
	   	{&#xD;
	   	if (overwriteRefContact)&#xD;
	   		{&#xD;
	   		p.setContactSeqNumber(refContactNum);  // set the ref seq# to refresh&#xD;
	   		&#xD;
	   		&#xD;
	   						var a = p.getAttributes();&#xD;
			&#xD;
							if (a)&#xD;
								{&#xD;
								var ai = a.iterator();&#xD;
								while (ai.hasNext())&#xD;
									{&#xD;
									var xx = ai.next();&#xD;
									xx.setContactNo(refContactNum);&#xD;
									}&#xD;
					}&#xD;
					&#xD;
					&#xD;
					&#xD;
	   		var r = aa.people.editPeopleWithAttribute(p,p.getAttributes());&#xD;
	   		&#xD;
			if (!r.getSuccess()) &#xD;
				logDebug(&quot;WARNING: couldn't refresh reference people : &quot; + r.getErrorMessage()); &#xD;
			else&#xD;
				logDebug(&quot;Successfully refreshed ref contact #&quot; + refContactNum + &quot; with CAP contact data&quot;); &#xD;
			}&#xD;
			&#xD;
	   	if (replaceCapContact)&#xD;
	   		{&#xD;
				// To Be Implemented later.   Is there a use case?&#xD;
			}&#xD;
			&#xD;
	   	}&#xD;
	   	else  // user entered the contact freehand.   Let's create or link to ref contact.&#xD;
	   	{&#xD;
			var ccmSeq = p.getContactSeqNumber();&#xD;
&#xD;
			var existingContact = refContactExists(p);  // Call the custom function to see if the REF contact exists&#xD;
&#xD;
			var p = cCopy[i].getPeople();  // get a fresh version, had to mangle the first for the search&#xD;
&#xD;
			if (existingContact)  // we found a match with our custom function.  Use this one.&#xD;
				{&#xD;
					refPeopleId = existingContact;&#xD;
				}&#xD;
			else  // did not find a match, let's create one&#xD;
				{&#xD;
&#xD;
				var a = p.getAttributes();&#xD;
&#xD;
				if (a)&#xD;
					{&#xD;
					//&#xD;
					// Clear unwanted attributes&#xD;
					var ai = a.iterator();&#xD;
					while (ai.hasNext())&#xD;
						{&#xD;
						var xx = ai.next();&#xD;
						if (ignoreAttributeArray &amp;&amp; exists(xx.getAttributeName().toUpperCase(),ignoreAttributeArray))&#xD;
							ai.remove();&#xD;
						}&#xD;
					}&#xD;
&#xD;
				var r = aa.people.createPeopleWithAttribute(p,a);&#xD;
&#xD;
				if (!r.getSuccess())&#xD;
					{logDebug(&quot;WARNING: couldn't create reference people : &quot; + r.getErrorMessage()); continue; }&#xD;
&#xD;
				//&#xD;
				// createPeople is nice and updates the sequence number to the ref seq&#xD;
				//&#xD;
&#xD;
				var p = cCopy[i].getPeople();&#xD;
				var refPeopleId = p.getContactSeqNumber();&#xD;
&#xD;
				logDebug(&quot;Successfully created reference contact #&quot; + refPeopleId);&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// now that we have the reference Id, we can link back to reference&#xD;
			//&#xD;
&#xD;
		    var ccm = aa.people.getCapContactByPK(pCapId,ccmSeq).getOutput().getCapContactModel();&#xD;
&#xD;
		    ccm.setRefContactNumber(refPeopleId);&#xD;
		    r = aa.people.editCapContact(ccm);&#xD;
&#xD;
		    if (!r.getSuccess())&#xD;
				{ logDebug(&quot;WARNING: error updating cap contact model : &quot; + r.getErrorMessage()); }&#xD;
			else&#xD;
				{ logDebug(&quot;Successfully linked ref contact &quot; + refPeopleId + &quot; to cap contact &quot; + ccmSeq);}&#xD;
&#xD;
&#xD;
	    }  // end if user hand entered contact &#xD;
	}  // end for each CAP contact&#xD;
} // end function&#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
function deactivateTask(wfstr) // optional process name&#xD;
{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
	{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
	}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
	{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
		{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
		}			&#xD;
	}&#xD;
}&#xD;
&#xD;
function deleteTask(targetCapId,deleteTaskName)&#xD;
{&#xD;
	//&#xD;
	// Get the target Task&#xD;
	//&#xD;
	var workflowResult = aa.workflow.getTasks(targetCapId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var tTask = null;&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(deleteTaskName.toUpperCase()))&#xD;
  			{&#xD;
			var tTask = wfObj[i];&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	if (!tTask)&#xD;
  	  	{ logDebug(&quot;**WARNING: Task not found: &quot; + deleteTaskName); return false; }&#xD;
&#xD;
&#xD;
	logDebug(&quot;Removing task &quot; + tTask.getTaskDescription());&#xD;
	var result = aa.workflow.removeTask(tTask)&#xD;
&#xD;
	if (!result.getSuccess())&#xD;
		{ logDebug(&quot;error &quot; + result.getErrorMessage()); return false; }&#xD;
&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	&#xD;
	itemCap = capId;&#xD;
	&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
   	&#xD;
   	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
			{&#xD;
				if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
				{&#xD;
					appspecObj[i].setChecklistComment(itemValue);&#xD;
						&#xD;
					var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
					if (actionResult.getSuccess()) &#xD;
					{							&#xD;
						logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
					} &#xD;
					else &#xD;
					{&#xD;
						logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
					}&#xD;
						&#xD;
					updated = true;&#xD;
					AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
				}&#xD;
				&#xD;
				i++;&#xD;
				&#xD;
			} // while loop&#xD;
		} // item name blank&#xD;
	} // got app specific object	&#xD;
	else&#xD;
	{ &#xD;
		logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage());&#xD;
	}&#xD;
}//End Function&#xD;
&#xD;
function editBuildingCount(numBuild) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setBuildingCount(parseFloat(numBuild));&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated building count to &quot; + numBuild); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
}function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editInspectionRequiredFlag(inspType,reqFlag)&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var result = aa.inspection.getInspMilestoneByCapID(itemCap);&#xD;
&#xD;
	if(!result.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection milestones: &quot;  + result.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspMilestones= result.getOutput();&#xD;
&#xD;
	if (!inspMilestones)&#xD;
		{ logDebug(&quot;No Inspection Milestones found&quot;) ; return false ; }&#xD;
&#xD;
	for (thisM in inspMilestones)&#xD;
		{&#xD;
		var obj= inspMilestones[thisM];&#xD;
		if (inspType.equals(obj.getInspType()))&#xD;
			{&#xD;
			if (reqFlag) obj.setInspRequired(&quot;Y&quot;);&#xD;
			else obj.setInspRequired(&quot;N&quot;);&#xD;
&#xD;
			result = aa.inspection.updateInspectionMilestone(inspMilestones);&#xD;
			if(result.getSuccess())&#xD;
				logDebug(&quot;inspection milestone updated sucessfully.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: could not update inpsection milestone &quot; +result.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	}function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editScheduledDate(scheduledDate) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	vScheduledDate = aa.date.parseDate(scheduledDate);&#xD;
	&#xD;
	//cd.setScheduledDate(vScheduledDate); //bug, doesn't work&#xD;
	cdScriptObj.setScheduledDate(vScheduledDate);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated scheduled date to &quot; + scheduledDate) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR updating scheduled date: &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = &quot;&quot; + Contacts[yy].getEmail();&#xD;
		}&#xD;
&#xD;
	if (emailAddress.indexOf(&quot;@&quot;) &gt; 0)&#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no valid email address&quot;);&#xD;
	}function endBranch() {&#xD;
	// stop execution of the current std choice&#xD;
	stopBranch = false;&#xD;
	}function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
&#xD;
function externalLP_CA(licNum,rlpType,doPopulateRef,doPopulateTrx,itemCap)&#xD;
	{&#xD;
&#xD;
	/*&#xD;
	Version: 3.2&#xD;
&#xD;
	Usage:&#xD;
&#xD;
		licNum			:  Valid CA license number.   Non-alpha, max 8 characters.  If null, function will use the LPs on the supplied CAP ID&#xD;
		rlpType			:  License professional type to use when validating and creating new LPs&#xD;
		doPopulateRef 	:  If true, will create/refresh a reference LP of this number/type&#xD;
		doPopulateTrx 	:  If true, will copy create/refreshed reference LPs to the supplied Cap ID.   doPopulateRef must be true for this to work&#xD;
		itemCap			:  If supplied, licenses on the CAP will be validated.  Also will be refreshed if doPopulateRef and doPopulateTrx are true&#xD;
&#xD;
	returns: non-null string of status codes for invalid licenses&#xD;
&#xD;
	examples:&#xD;
&#xD;
	appsubmitbefore   (will validate the LP entered, if any, and cancel the event if the LP is inactive, cancelled, expired, etc.)&#xD;
	===============&#xD;
	true ^ cslbMessage = &quot;&quot;;&#xD;
	CAELienseNumber ^ cslbMessage = externalLP_CA(CAELienseNumber,false,false,CAELienseType,null);&#xD;
	cslbMessage.length &gt; 0 ^ cancel = true ; showMessage = true ; comment(cslbMessage)&#xD;
&#xD;
	appsubmitafter  (update all CONTRACTOR LPs on the CAP and REFERENCE with data from CSLB.  Link the CAP LPs to REFERENCE.   Pop up a message if any are inactive...)&#xD;
	==============&#xD;
	true ^ 	cslbMessage = externalLP_CA(null,true,true,&quot;CONTRACTOR&quot;,capId)&#xD;
	cslbMessage.length &gt; 0 ^ showMessage = true ; comment(cslbMessage);&#xD;
&#xD;
	Note;  Custom LP Template Field Mappings can be edited in the script below&#xD;
	*/&#xD;
&#xD;
	var returnMessage = &quot;&quot;;&#xD;
&#xD;
	var workArray = new Array();&#xD;
	if (licNum)&#xD;
		workArray.push(String(licNum));&#xD;
&#xD;
	if (itemCap)&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(itemCap);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{&#xD;
			var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
		if (capLicenseArr == null || !capLicenseArr.length)&#xD;
			{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); }&#xD;
		else&#xD;
			{&#xD;
			for (var thisLic in capLicenseArr)&#xD;
				if (capLicenseArr[thisLic].getLicenseType() == rlpType)&#xD;
					workArray.push(capLicenseArr[thisLic]);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		doPopulateTrx = false; // can't do this without a CAP;&#xD;
&#xD;
	for (var thisLic = 0; thisLic &lt; workArray.length; thisLic++)&#xD;
		{&#xD;
		var licNum = workArray[thisLic];&#xD;
		var licObj = null;&#xD;
		var isObject = false;&#xD;
&#xD;
		if (typeof(licNum) == &quot;object&quot;)  // is this one an object or string?&#xD;
			{&#xD;
			licObj = licNum;&#xD;
			licNum = licObj.getLicenseNbr();&#xD;
			isObject = true;&#xD;
			}&#xD;
&#xD;
		// Make the call to the California State License Board&#xD;
&#xD;
        var saxBuilder = aa.proxyInvoker.newInstance(&quot;org.jdom.input.SAXBuilder&quot;).getOutput();&#xD;
        var aURLArgList = new Array()&#xD;
        aURLArgList[0] = &quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum;&#xD;
        var oURL = aa.proxyInvoker.newInstance(&quot;java.net.URL&quot;,aURLArgList).getOutput();&#xD;
        var document = saxBuilder.build(oURL); //(&quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum);&#xD;
        var root = document.getRootElement();&#xD;
&#xD;
		var errorNode = root.getChild(&quot;Error&quot;);&#xD;
		if (errorNode)&#xD;
			{&#xD;
			logDebug(&quot;Error for license &quot; + licNum + &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;));&#xD;
			returnMessage+=&quot;License &quot; + licNum +  &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;) + &quot; &quot;;&#xD;
			continue;&#xD;
			}&#xD;
&#xD;
		var lpBiz = root.getChild(&quot;BusinessInfo&quot;);&#xD;
		var lpStatus = root.getChild(&quot;PrimaryStatus&quot;);&#xD;
		var lpClass = root.getChild(&quot;Classifications&quot;);&#xD;
		var lpBonds = root.getChild(&quot;ContractorBond&quot;);&#xD;
		var lpWC = root.getChild(&quot;WorkersComp&quot;);&#xD;
&#xD;
		// Primary Status&#xD;
		// 3 = expired, 10 = good, 11 = inactive, 1 = canceled.   We will ignore all but 10 and return text.&#xD;
		var stas = lpStatus.getChildren();&#xD;
		for (var i=0 ; i&lt;stas.size(); i++) {&#xD;
			var sta = stas.get(i);&#xD;
&#xD;
			if (sta.getAttribute(&quot;Code&quot;).getValue() != &quot;10&quot;)&#xD;
				returnMessage+=&quot;License:&quot; + licNum + &quot;, &quot; + sta.getAttribute(&quot;Desc&quot;).getValue() + &quot; &quot;;&#xD;
		}&#xD;
&#xD;
		if (doPopulateRef)  // refresh or create a reference LP&#xD;
			{&#xD;
			var updating = false;&#xD;
&#xD;
			// check to see if the licnese already exists...if not, create.&#xD;
&#xD;
			var newLic = getRefLicenseProf(licNum)&#xD;
&#xD;
			if (newLic)&#xD;
				{&#xD;
				updating = true;&#xD;
				logDebug(&quot;Updating existing Ref Lic Prof : &quot; + licNum);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
				}&#xD;
&#xD;
			if (isObject)  // update the reference LP with data from the transactional, if we have some.&#xD;
				{&#xD;
				if (licObj.getAddress1()) newLic.setAddress1(licObj.getAddress1());&#xD;
				if (licObj.getAddress2()) newLic.setAddress2(licObj.getAddress2());&#xD;
				if (licObj.getAddress3()) newLic.setAddress3(licObj.getAddress3());&#xD;
				if (licObj.getAgencyCode()) newLic.setAgencyCode(licObj.getAgencyCode());&#xD;
				if (licObj.getBusinessLicense()) newLic.setBusinessLicense(licObj.getBusinessLicense());&#xD;
				if (licObj.getBusinessName()) newLic.setBusinessName(licObj.getBusinessName());&#xD;
				if (licObj.getBusName2()) newLic.setBusinessName2(licObj.getBusName2());&#xD;
				if (licObj.getCity()) newLic.setCity(licObj.getCity());&#xD;
				if (licObj.getCityCode()) newLic.setCityCode(licObj.getCityCode());&#xD;
				if (licObj.getContactFirstName()) newLic.setContactFirstName(licObj.getContactFirstName());&#xD;
				if (licObj.getContactLastName()) newLic.setContactLastName(licObj.getContactLastName());&#xD;
				if (licObj.getContactMiddleName()) newLic.setContactMiddleName(licObj.getContactMiddleName());&#xD;
				if (licObj.getCountryCode()) newLic.setContryCode(licObj.getCountryCode());&#xD;
				if (licObj.getEmail()) newLic.setEMailAddress(licObj.getEmail());&#xD;
				if (licObj.getCountry()) newLic.setCountry(licObj.getCountry());&#xD;
				if (licObj.getEinSs()) newLic.setEinSs(licObj.getEinSs());&#xD;
				if (licObj.getFax()) newLic.setFax(licObj.getFax());&#xD;
				if (licObj.getFaxCountryCode()) newLic.setFaxCountryCode(licObj.getFaxCountryCode());&#xD;
				if (licObj.getHoldCode()) newLic.setHoldCode(licObj.getHoldCode());&#xD;
				if (licObj.getHoldDesc()) newLic.setHoldDesc(licObj.getHoldDesc());&#xD;
				if (licObj.getLicenseExpirDate()) newLic.setLicenseExpirationDate(licObj.getLicenseExpirDate());&#xD;
				if (licObj.getLastRenewalDate()) newLic.setLicenseLastRenewalDate(licObj.getLastRenewalDate());&#xD;
				if (licObj.getLicesnseOrigIssueDate()) newLic.setLicOrigIssDate(licObj.getLicesnseOrigIssueDate());&#xD;
				if (licObj.getPhone1()) newLic.setPhone1(licObj.getPhone1());&#xD;
				if (licObj.getPhone1CountryCode()) newLic.setPhone1CountryCode(licObj.getPhone1CountryCode());&#xD;
				if (licObj.getPhone2()) newLic.setPhone2(licObj.getPhone2());&#xD;
				if (licObj.getPhone2CountryCode()) newLic.setPhone2CountryCode(licObj.getPhone2CountryCode());&#xD;
				if (licObj.getSelfIns()) newLic.setSelfIns(licObj.getSelfIns());&#xD;
				if (licObj.getState()) newLic.setState(licObj.getState());&#xD;
				if (licObj.getSuffixName()) newLic.setSuffixName(licObj.getSuffixName());&#xD;
				if (licObj.getZip()) newLic.setZip(licObj.getZip());&#xD;
				}&#xD;
&#xD;
			// Now set data from the CSLB&#xD;
&#xD;
			if (lpBiz.getChild(&quot;Name&quot;).getText() != &quot;&quot;) newLic.setBusinessName(unescape(lpBiz.getChild(&quot;Name&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr1&quot;).getText() != &quot;&quot;) newLic.setAddress1(unescape(lpBiz.getChild(&quot;Addr1&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr2&quot;).getText() != &quot;&quot;) newLic.setAddress2(unescape(lpBiz.getChild(&quot;Addr2&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;City&quot;).getText() != &quot;&quot;) newLic.setCity(unescape(lpBiz.getChild(&quot;City&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;State&quot;).getText() != &quot;&quot;) newLic.setState(unescape(lpBiz.getChild(&quot;State&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Zip&quot;).getText() != &quot;&quot;) newLic.setZip(unescape(lpBiz.getChild(&quot;Zip&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText() != &quot;&quot;) newLic.setPhone1(unescape(stripNN(lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText()).replace(/\+/g,&quot; &quot;)));&#xD;
			newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
			newLic.setAuditDate(sysDate);&#xD;
			newLic.setAuditID(currentUserID);&#xD;
			newLic.setAuditStatus(&quot;A&quot;);&#xD;
			newLic.setLicenseType(rlpType);&#xD;
			newLic.setLicState(&quot;CA&quot;);  // hardcode CA&#xD;
			newLic.setStateLicense(licNum);&#xD;
&#xD;
			if (lpBiz.getChild(&quot;IssueDt&quot;).getText()) newLic.setLicenseIssueDate(aa.date.parseDate(lpBiz.getChild(&quot;IssueDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ExpireDt&quot;).getText()) newLic.setLicenseExpirationDate(aa.date.parseDate(lpBiz.getChild(&quot;ExpireDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ReissueDt&quot;).getText()) newLic.setLicenseLastRenewalDate(aa.date.parseDate(lpBiz.getChild(&quot;ReissueDt&quot;).getText()));&#xD;
&#xD;
			var wcs = root.getChild(&quot;WorkersComp&quot;).getChildren();&#xD;
&#xD;
			for (var j=0 ; j&lt;wcs.size(); j++) {&#xD;
				wc = wcs.get(j);&#xD;
&#xD;
				if (wc.getAttribute(&quot;PolicyNo&quot;).getValue()) newLic.setWcPolicyNo(wc.getAttribute(&quot;PolicyNo&quot;).getValue());&#xD;
				if (wc.getAttribute(&quot;InsCoCde&quot;).getValue()) newLic.setWcInsCoCode(unescape(wc.getAttribute(&quot;InsCoCde&quot;).getValue()));&#xD;
				if (wc.getAttribute(&quot;WCEffDt&quot;).getValue()) newLic.setWcEffDate(aa.date.parseDate(wc.getAttribute(&quot;WCEffDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCExpDt&quot;).getValue()) newLic.setWcExpDate(aa.date.parseDate(wc.getAttribute(&quot;WCExpDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCCancDt&quot;).getValue()) newLic.setWcCancDate(aa.date.parseDate(wc.getAttribute(&quot;WCCancDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;Exempt&quot;).getValue() == &quot;E&quot;) newLic.setWcExempt(&quot;Y&quot;); else newLic.setWcExempt(&quot;N&quot;);&#xD;
&#xD;
				break; // only use first&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// Do the refresh/create and get the sequence number&#xD;
			//&#xD;
			if (updating)&#xD;
				{&#xD;
				var myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
				var licSeqNbr = newLic.getLicSeqNbr();&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
				if (!myResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;**WARNING: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
					continue;&#xD;
					}&#xD;
&#xD;
				var licSeqNbr = myResult.getOutput()&#xD;
				}&#xD;
&#xD;
			logDebug(&quot;Successfully added/updated License No. &quot; + licNum + &quot;, Type: &quot; + rlpType + &quot; Sequence Number &quot; + licSeqNbr);&#xD;
&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data -- first copy from the transactional LP if it exists&#xD;
			/////&#xD;
&#xD;
&#xD;
			if (isObject)  // update the reference LP with attributes from the transactional, if we have some.&#xD;
				{&#xD;
				var attrArray = licObj.getAttributes();&#xD;
&#xD;
				if (attrArray)&#xD;
					{&#xD;
					for (var k in attrArray)&#xD;
						{&#xD;
						var attr = attrArray[k];&#xD;
						editRefLicProfAttribute(licNum,attr.getAttributeName(),attr.getAttributeValue());&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data&#xD;
			/////&#xD;
			/////  NOTE!  Agencies may have to configure template data below based on their configuration.  Please note all edits&#xD;
			/////&#xD;
&#xD;
			var cbs = root.getChild(&quot;Classifications&quot;).getChildren();&#xD;
			for (var m=0 ; m&lt;cbs.size(); m++) {&#xD;
				cb = cbs.get(m);&#xD;
&#xD;
				if (m == 0)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 1&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 1&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 1)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 2&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 2&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				if (m == 2)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 3&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 3&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 3)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 4&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 4&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				}&#xD;
&#xD;
			var bos = root.getChild(&quot;ContractorBond&quot;).getChildren();&#xD;
&#xD;
			for (var n=0 ; n&lt;bos.size(); n++) {&#xD;
				var bo = bos.get(n);&#xD;
				if (bo.getAttribute(&quot;BondAmt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND AMOUNT&quot;,unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()));&#xD;
				if (bo.getAttribute(&quot;BondCancDt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND EXPIRATION&quot;,unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()));&#xD;
&#xD;
				// Currently unused but could be loaded into custom attributes.&#xD;
/*&#xD;
				aa.print(&quot;Bond Surety Type       : &quot; + unescape(bo.getAttribute(&quot;SuretyTp&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Code              : &quot; + unescape(bo.getAttribute(&quot;InsCoCde&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Insurance Company : &quot; + unescape(bo.getAttribute(&quot;InsCoName&quot;).getValue()).replace(/\+/g,&quot; &quot;))&#xD;
				aa.print(&quot;Bond Number            : &quot; + unescape(bo.getAttribute(&quot;BondNo&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Amount            : &quot; + unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Effective Date    : &quot; + unescape(bo.getAttribute(&quot;BondEffDt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Cancel Date       : &quot; + unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()))&#xD;
*/&#xD;
				break; // only use first bond&#xD;
				}&#xD;
&#xD;
			if (doPopulateTrx)&#xD;
				{&#xD;
				var lpsmResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,licSeqNbr)&#xD;
					if (!lpsmResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING error retrieving the LP just created &quot; + lpsmResult.getErrorMessage()) ; }&#xD;
&#xD;
				var lpsm = lpsmResult.getOutput();&#xD;
&#xD;
				// Remove from CAP&#xD;
&#xD;
				var isPrimary = false;&#xD;
&#xD;
				for (var currLic in capLicenseArr)&#xD;
					{&#xD;
					var thisLP = capLicenseArr[currLic];&#xD;
					if (thisLP.getLicenseType() == rlpType &amp;&amp; thisLP.getLicenseNbr() == licNum)&#xD;
						{&#xD;
						logDebug(&quot;Removing license: &quot; + thisLP.getLicenseNbr() + &quot; from CAP.  We will link the new reference LP&quot;);&#xD;
						if (thisLP.getPrintFlag() == &quot;Y&quot;)&#xD;
							{&#xD;
							logDebug(&quot;...remove primary status...&quot;);&#xD;
							isPrimary = true;&#xD;
							thisLP.setPrintFlag(&quot;N&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisLP);&#xD;
							}&#xD;
						var remCapResult = aa.licenseProfessional.removeLicensedProfessional(thisLP);&#xD;
						if (capLicenseResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;...Success.&quot;); }&#xD;
						else&#xD;
							{ logDebug(&quot;**WARNING removing lic prof: &quot; + remCapResult.getErrorMessage()); }&#xD;
						}&#xD;
					}&#xD;
&#xD;
				// add the LP to the CAP&#xD;
				var asCapResult= aa.licenseScript.associateLpWithCap(itemCap,lpsm)&#xD;
				if (!asCapResult.getSuccess())&#xD;
				{ logDebug(&quot;**WARNING error associating CAP to LP: &quot; + asCapResult.getErrorMessage()) }&#xD;
				else&#xD;
					{ logDebug(&quot;Associated the CAP to the new LP&quot;) }&#xD;
&#xD;
				// Now make the LP primary again&#xD;
				if (isPrimary)&#xD;
					{&#xD;
					var capLps = getLicenseProfessional(itemCap);&#xD;
&#xD;
					for (var thisCapLpNum in capLps)&#xD;
						{&#xD;
						if (capLps[thisCapLpNum].getLicenseNbr().equals(licNum))&#xD;
							{&#xD;
							var thisCapLp = capLps[thisCapLpNum];&#xD;
							thisCapLp.setPrintFlag(&quot;Y&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisCapLp);&#xD;
							logDebug(&quot;Updated primary flag on Cap LP : &quot; + licNum);&#xD;
&#xD;
							// adding this return will cause the test script to work without error, even though this is the last statement executed&#xD;
							//if (returnMessage.length &gt; 0) return returnMessage;&#xD;
							//else return null;&#xD;
&#xD;
							}&#xD;
						}&#xD;
				}&#xD;
			} // do populate on the CAP&#xD;
		} // do populate on the REF&#xD;
	} // for each license&#xD;
&#xD;
	if (returnMessage.length &gt; 0) return returnMessage;&#xD;
	else return null;&#xD;
&#xD;
} // end function&#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	}&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
function feeCopyByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			 addFee(ffeObjArr[ff].getFeeCod(),  ffeObjArr[ff].getFeeSchudle() ,  ffeObjArr[ff].getPaymentPeriod() ,  ffeObjArr[ff].getFeeUnit() ,    'Y') &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
function getChildTasks(taskName) {&#xD;
    var childTasks = new Array();&#xD;
    var childId = null;&#xD;
    var itemCap = capId&#xD;
    if (arguments.length &gt; 1)&#xD;
        itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
    var wfObj = workflowResult.getOutput();&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getTaskDescription().equals(taskName)) {&#xD;
            var relationArray = aa.workflow.getProcessRelationByCapID(itemCap, null).getOutput()&#xD;
            for (thisRel in relationArray) {&#xD;
                y = relationArray[thisRel]&#xD;
                if (y.getParentTaskName() &amp;&amp; y.getParentTaskName().equals(fTaskSM.getTaskDescription()))&#xD;
                    childId = y.getProcessID()&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getProcessID() == childId)&#xD;
            childTasks.push(fTaskSM)&#xD;
    }&#xD;
&#xD;
    return childTasks;&#xD;
&#xD;
}&#xD;
&#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0];&#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // we are in a page flow script so use the capModel to get contacts&#xD;
		{&#xD;
		capContactArray = cap.getContactsGroup().toArray() ;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var capContactArray = capContactResult.getOutput();&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	if (capContactArray)&#xD;
		{&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;middleName&quot;] = capContactArray[yy].getPeople().middleName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;&#xD;
&#xD;
			if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // using capModel to get contacts&#xD;
				var pa = capContactArray[yy].getPeople().getAttributes().toArray();&#xD;
			else&#xD;
				var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);&#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}&#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
  function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
function getLastScheduledInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector that is assigned to the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function getLicenseProfessional(itemcapId)&#xD;
{&#xD;
	capLicenseArr = null;&#xD;
	var s_result = aa.licenseProfessional.getLicenseProf(itemcapId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capLicenseArr = s_result.getOutput();&#xD;
		if (capLicenseArr == null || capLicenseArr.length == 0)&#xD;
		{&#xD;
			aa.print(&quot;WARNING: no licensed professionals on this CAP:&quot; + itemcapId);&#xD;
			capLicenseArr = null;&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to license professional: &quot; + s_result.getErrorMessage());&#xD;
		capLicenseArr = null;&#xD;
	}&#xD;
	return capLicenseArr;&#xD;
}&#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; newLicArray[thisLic] &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    }&#xD;
&#xD;
function isReadyRenew(capid) {&#xD;
    if (capid == null || aa.util.instanceOfString(capid)) {&#xD;
        return false;&#xD;
    }&#xD;
    var result = aa.expiration.isExpiredLicenses(capid);&#xD;
    if (result.getSuccess()) {&#xD;
        return true;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Failed to get expiration with CAP(&quot; + capid + &quot;): &quot; + result.getErrorMessage());&#xD;
    }&#xD;
    return false;&#xD;
}&#xD;
&#xD;
function isRenewProcess(parentCapID, partialCapID) {&#xD;
    //1. Check to see parent CAP ID is null.&#xD;
    if (parentCapID == null || partialCapID == null)&#xD;
    { logDebug(&quot;ERROR: the parentCapID or the partialCap ID is null&quot;); return false; }&#xD;
    //2. Get CAPModel by PK for partialCAP.&#xD;
    var result = aa.cap.getCap(partialCapID);&#xD;
    if (result.getSuccess()) {&#xD;
        capScriptModel = result.getOutput();&#xD;
        //2.1. Check to see if it is partial CAP.&#xD;
        if (capScriptModel.isCompleteCap()) {&#xD;
            logDebug(&quot;ERROR: It is not partial CAP(&quot; + capScriptModel.getCapID() + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Fail to get CAPModel (&quot; + partialCapID + &quot;): &quot; + result.getErrorMessage());&#xD;
        return false;&#xD;
    }&#xD;
    //3.  Check to see if the renewal was initiated before.&#xD;
    result = aa.cap.getProjectByMasterID(parentCapID, &quot;Renewal&quot;, &quot;Incomplete&quot;);&#xD;
    if (result.getSuccess()) {&#xD;
        partialProjects = result.getOutput();&#xD;
        if (partialProjects != null &amp;&amp; partialProjects.length &gt; 0) {&#xD;
            //Avoid to initiate renewal process multiple times.&#xD;
            logDebug(&quot;Warning: Renewal process was initiated before. ( &quot; + parentCapID + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
&#xD;
    }&#xD;
    //4 . Check to see if parent CAP is ready for renew.&#xD;
    return isReadyRenew(parentCapID);&#xD;
}&#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function licenseObject(licnumber)  // optional renewal Cap ID -- uses the expiration on the renewal CAP.&#xD;
	{&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
&#xD;
   	b1ExpResult = aa.expiration.getLicensesByCapID(itemCap)&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
			tmpDate = this.b1Exp.getExpDate();&#xD;
			if (tmpDate)&#xD;
				this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
			this.b1Status = this.b1Exp.getExpStatus();&#xD;
			logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + b1ExpResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function loadAddressAttributes(thisArr)&#xD;
{&#xD;
	//&#xD;
	// Returns an associative array of Address Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
   	var capAddressResult = aa.address.getAddressWithAttributeByCapId(itemCap);&#xD;
   	if (capAddressResult.getSuccess())&#xD;
   		var fcapAddressObj = capAddressResult.getOutput();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddressResult.getErrorType() + &quot;:&quot; + capAddressResult.getErrorMessage())&#xD;
&#xD;
  	for (i in fcapAddressObj)&#xD;
  	{&#xD;
  		addressAttrObj = fcapAddressObj[i].getAttributes().toArray();&#xD;
  		for (z in addressAttrObj)&#xD;
			thisArr[&quot;AddressAttribute.&quot; + addressAttrObj[z].getB1AttributeName()]=addressAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;AddressAttribute.PrimaryFlag&quot;] = fcapAddressObj[i].getPrimaryFlag();&#xD;
		thisArr[&quot;AddressAttribute.HouseNumberStart&quot;] = fcapAddressObj[i].getHouseNumberStart();&#xD;
		thisArr[&quot;AddressAttribute.StreetDirection&quot;] = fcapAddressObj[i].getStreetDirection();&#xD;
		thisArr[&quot;AddressAttribute.StreetName&quot;] = fcapAddressObj[i].getStreetName();&#xD;
		thisArr[&quot;AddressAttribute.StreetSuffix&quot;] = fcapAddressObj[i].getStreetSuffix();&#xD;
		thisArr[&quot;AddressAttribute.City&quot;] = fcapAddressObj[i].getCity();&#xD;
		thisArr[&quot;AddressAttribute.State&quot;] = fcapAddressObj[i].getState();&#xD;
		thisArr[&quot;AddressAttribute.Zip&quot;] = fcapAddressObj[i].getZip();&#xD;
		thisArr[&quot;AddressAttribute.AddressStatus&quot;] = fcapAddressObj[i].getAddressStatus();&#xD;
		thisArr[&quot;AddressAttribute.County&quot;] = fcapAddressObj[i].getCounty();&#xD;
		thisArr[&quot;AddressAttribute.Country&quot;] = fcapAddressObj[i].getCountry();&#xD;
		thisArr[&quot;AddressAttribute.AddressDescription&quot;] = fcapAddressObj[i].getAddressDescription();&#xD;
		thisArr[&quot;AddressAttribute.XCoordinate&quot;] = fcapAddressObj[i].getXCoordinator();&#xD;
		thisArr[&quot;AddressAttribute.YCoordinate&quot;] = fcapAddressObj[i].getYCoordinator();&#xD;
  	}&#xD;
}&#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
      var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		var readOnly = 'N';&#xD;
		if (readOnlyi.hasNext()) {&#xD;
			readOnly = readOnlyi.next();&#xD;
		}&#xD;
		var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
		tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
		}&#xD;
		tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	}&#xD;
&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
	  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
				}&#xD;
&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
			//tempObject[tcol.getColumnName()] = tval;&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadASITablesBefore() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	//&#xD;
&#xD;
	var gm =  aa.env.getValue(&quot;AppSpecificTableGroupModel&quot;);&#xD;
	var ta = gm.getTablesMap().values()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
		  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator();&#xD;
&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
			}&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
          eval(copyStr);  // move to table name&#xD;
&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
&#xD;
function loadGuideSheetItems(inspId) {&#xD;
	//&#xD;
	// Returns an associative array of Guide Sheet Items&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var retArray = new Array()&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var r = aa.inspection.getInspections(itemCap)&#xD;
&#xD;
	if (r.getSuccess())&#xD;
	 	{&#xD;
		var inspArray = r.getOutput();&#xD;
&#xD;
		for (i in inspArray)&#xD;
			{&#xD;
			if (inspArray[i].getIdNumber() == inspId)&#xD;
				{&#xD;
				var inspModel = inspArray[i].getInspection();&#xD;
&#xD;
				var gs = inspModel.getGuideSheets()&#xD;
&#xD;
				if (gs)&#xD;
					{&#xD;
					gsArray = gs.toArray();&#xD;
					for (var loopk in gsArray)&#xD;
						{&#xD;
						var gsItems = gsArray[loopk].getItems().toArray()&#xD;
						for (var loopi in gsItems)&#xD;
							retArray[gsItems[loopi].getGuideItemText()] = gsItems[loopi].getGuideItemStatus();&#xD;
						}&#xD;
					} // if there are guidesheets&#xD;
				else&#xD;
					logDebug(&quot;No guidesheets for this inspection&quot;);&#xD;
				} // if this is the right inspection&#xD;
			} // for each inspection&#xD;
		} // if there are inspections&#xD;
&#xD;
	logDebug(&quot;loaded &quot; + retArray.length + &quot; guidesheet items&quot;);&#xD;
	return retArray;&#xD;
	}&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + (fTask.getStatusDate().getMonth() + 1) + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
function logDebug(dstr) {&#xD;
&#xD;
    if (!aa.calendar.getNextWorkDay) {&#xD;
&#xD;
		vLevel = 1&#xD;
		if (arguments.length &gt; 1)&#xD;
			vLevel = arguments[1]&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
			debug += dstr + br;&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel)&#xD;
			aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr)&#xD;
		}&#xD;
	else {&#xD;
			debug+=dstr + br;&#xD;
		}&#xD;
&#xD;
}&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
function lookupFeesByValuationSlidingScale(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 2;&#xD;
	if (arguments.length == 4) valNumber = (arguments[3] + 1);&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
                        &#xD;
                        &#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 2)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					var divisor = workVals[1];&#xD;
					saveVal = parseInt((capval - workVals[0])/divisor);&#xD;
					if ((capval - workVals[0]) % divisor &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function prepareRenewal() {&#xD;
&#xD;
    if (isRenewProcess(parentCapId, capId)) {&#xD;
        logDebug(&quot;CAPID(&quot; + parentCapId + &quot;) is ready for renew. PartialCap (&quot; + capId + &quot;)&quot;);&#xD;
&#xD;
        //Associate partial cap with parent CAP.&#xD;
        var result = aa.cap.createRenewalCap(parentCapId, capId, true);&#xD;
        if (result.getSuccess()) {&#xD;
            // Set B1PERMIT.B1_ACCESS_BY_ACA to &quot;N&quot; for partial CAP to not allow that it is searched by ACA user.&#xD;
            aa.cap.updateAccessByACA(capId, &quot;N&quot;);&#xD;
        }&#xD;
        else&#xD;
        { logDebug(&quot;ERROR: Associate partial cap with parent CAP. &quot; + result.getErrorMessage()); return false };&#xD;
&#xD;
        return true;&#xD;
    }&#xD;
    else&#xD;
    { logDebug(&quot;Renewal Process did not finish properly&quot;); return false; }&#xD;
}&#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function removeAllFees(itemCap) // Removes all non-invoiced fee items for a CAP ID&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByCapID(itemCap);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
&#xD;
				var editResult = aa.finance.removeFeeItem(itemCap, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + feeList[feeNum].getFeeCod());&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+feeList[feeNum].getFeeCod()+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
	}&#xD;
&#xD;
	function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.removeAppSpecificTableInfos(tableName,itemCap,currentUserID)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ aa.print(&quot;**WARNING: error removing ASI table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
        else&#xD;
	logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function replaceMessageTokens(m)&#xD;
	{&#xD;
	//  tokens in pipes will attempt to interpret as script variables&#xD;
	//  tokens in curly braces will attempt to replace from AInfo (ASI, etc)&#xD;
	//&#xD;
	//  e.g.   |capId|  or |wfTask|  or |wfStatus|&#xD;
	//&#xD;
	//  e.g.   {Expiration Date}  or  {Number of Electrical Outlets}&#xD;
	//&#xD;
	//  e.g.   m = &quot;Your recent license application (|capIdString|) has successfully passed |wfTask| with a status of |wfStatus|&quot;&#xD;
&#xD;
	while (m.indexOf(&quot;|&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;|&quot;)&#xD;
	  var e = m.indexOf(&quot;|&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;typeof(&quot; + r + &quot;) != \&quot;undefined\&quot; ? &quot; + r + &quot; : \&quot;undefined\&quot;&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\|&quot; + r + &quot;\\|&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
	  }&#xD;
&#xD;
	while (m.indexOf(&quot;{&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;{&quot;)&#xD;
	  var e = m.indexOf(&quot;}&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;AInfo[\&quot;&quot; + r + &quot;\&quot;]&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\{&quot; + r + &quot;\\}&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
&#xD;
	  }&#xD;
&#xD;
	 return m&#xD;
	 }&#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID.&#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm&#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3)&#xD;
		if (arguments[2] != null)&#xD;
			{&#xD;
			var inspRes = aa.person.getUser(arguments[2]);&#xD;
			if (inspRes.getSuccess())&#xD;
				inspectorObj = inspRes.getOutput();&#xD;
			}&#xD;
&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
&#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
function stripNN(fullStr) {&#xD;
    var allowed = &quot;0123456789.&quot;;&#xD;
    var stripped = &quot;&quot;;&#xD;
    for (i = 0; i &lt; fullStr.length(); i++)&#xD;
        if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
        stripped += String.fromCharCode(fullStr.charAt(i))&#xD;
    return stripped;&#xD;
}&#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*&#xD;
DQ 09/03/2009 - Added Check to ensure Task status date is not null prior to getting status date&#xD;
Function will return false on fail&#xD;
*/&#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
	            if (fTask.getStatusDate() != null)&#xD;
	                return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
	            else&#xD;
	                { logMessage(&quot;**ERROR: NULL workflow task &quot;+fTask.getTaskDescription()+&quot; status date. &quot;); return false; }&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap, &quot;APPLICATION&quot;, stat, sysDate, cmt, systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
}&#xD;
&#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq)&#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
    // 12/22/2008 - DQ - Correct Invoice loop to accumulate instead of reset each iteration&#xD;
&#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)&#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
&#xD;
    var invFeeFound=false;&#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = adjustedQty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) )&#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
&#xD;
	return feeSeq;&#xD;
	}&#xD;
&#xD;
&#xD;
function updateRefParcelToCap() //Takes Optional CapId&#xD;
{&#xD;
	var vCapId = null;&#xD;
	if (arguments.length &gt; 0)&#xD;
		vCapId = arguments[0];&#xD;
	else&#xD;
		vCapId = capId;&#xD;
&#xD;
    var capPrclArr = aa.parcel.getParcelDailyByCapID(vCapId,null).getOutput();&#xD;
    if(capPrclArr != null)&#xD;
    {&#xD;
        for (x in capPrclArr)&#xD;
        {&#xD;
	        var prclObj = aa.parcel.getParceListForAdmin(capPrclArr[x].getParcelNumber(), null, null, null, null, null, null, null, null, null);&#xD;
	        if (prclObj.getSuccess() )&#xD;
	        {&#xD;
		        var prclArr = prclObj.getOutput();&#xD;
		        if (prclArr.length)&#xD;
		        {&#xD;
			        var prcl = prclArr[0].getParcelModel();&#xD;
			        var capPrclObj = aa.parcel.warpCapIdParcelModel2CapParcelModel(vCapId, prcl);&#xD;
&#xD;
			        if (capPrclObj.getSuccess())&#xD;
			        {&#xD;
&#xD;
				        var capPrcl = capPrclObj.getOutput();&#xD;
				        aa.parcel.updateDailyParcelWithAPOAttribute(capPrcl);	&#xD;
				        logDebug(&quot;Updated Parcel &quot; + capPrclArr[x].getParcelNumber() + &quot; with Reference Data&quot;);&#xD;
			        }&#xD;
			        else&#xD;
				        logDebug(&quot;Failed to Wrap Parcel Model for &quot; + capPrclArr[x].getParcelNumber());&#xD;
&#xD;
		        }&#xD;
		        else&#xD;
			        logDebug(&quot;No matching reference Parcels found for &quot; + capPrclArr[x].getParcelNumber());&#xD;
	        }&#xD;
	        else&#xD;
		        logDebug(&quot;Failed to get reference Parcel for &quot; + capPrclArr[x].getParcelNumber())&#xD;
	    }&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskDepartment(wfstr,wfDepartment) // optional process name&#xD;
	{&#xD;
	// Update the task assignment department&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
        var assignBureau = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[2];&#xD;
	var assignDivision = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[3];&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
        for (var i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
                if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
 			{&#xD;
			if (wfDepartment)&#xD;
				{&#xD;
				var taskUserObj = fTask.getTaskItem().getAssignedUser()&#xD;
				taskUserObj.setBureauCode(assignBureau);&#xD;
				taskUserObj.setDivisionCode(assignDivision);&#xD;
				fTask.setAssignedUser(taskUserObj);&#xD;
        			var taskItem = fTask.getTaskItem();&#xD;
&#xD;
				var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Department Set to &quot; + assignBureau);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update Department.  Invalid department : &quot; + assignBureau);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel()&#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
&#xD;
	}&#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><initializer></initializer><title>InspectionScheduleAfter</title></script><scriptName>InspectionScheduleAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>InspectionScheduleBefore</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:52:56.430-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>InspectionScheduleBefore</name><auditModel><auditDate>2002-03-15T14:09:33-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs before one or multiple inspections are scheduled.</description></event><script><name>INSPECTIONSCHEDULEBEFORE</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2011-05-04T07:35:24.853-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: InspectionScheduleBefore.js 3600 2008-10-27 21:36:24Z dane.quatacker $&#xD;
| Program : InspectionScheduleBeforeV1.5.js&#xD;
| Event   : InspectionScheduleBefore&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;			// Set to true to see results in popup window&#xD;
var showDebug = true;				// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;InspectionScheduleBefore&quot;; // Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForBeforeEvents&quot;&#xD;
var cancel = false ; 				// Setting cancel to true in standard choices will cancel the event&#xD;
var documentOnly = false;			// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;			// turn off tokenizing of App Specific and Parcel Attributes&#xD;
var useAppSpecificGroupName = false;		// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;		// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;				// Maximum number of std choice entries.  Must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup;&#xD;
var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var InspectionDate = aa.env.getValue(&quot;InspectionDate&quot;);&#xD;
var InspectionMode = aa.env.getValue(&quot;InspectionMode&quot;);&#xD;
var InspectionTime = aa.env.getValue(&quot;InspectionTime&quot;);&#xD;
var InspectionTypeList = aa.env.getValue(&quot;InspectionTypeList&quot;)&#xD;
var inspTypeArr = InspectionTypeList.toString().split(&quot;\\|&quot;);&#xD;
var InspectorFirstName = aa.env.getValue(&quot;InspectorFirstName&quot;);&#xD;
var InspectorLastName = aa.env.getValue(&quot;InspectorLastName&quot;);&#xD;
var InspectorMiddleName = aa.env.getValue(&quot;InspectorMiddleName&quot;);&#xD;
var NumberOfInspections = aa.env.getValue(&quot;NumberOfInspections&quot;);&#xD;
&#xD;
logDebug(&quot;InspectionDate = &quot; + InspectionDate);&#xD;
logDebug(&quot;InspectionMode = &quot; + InspectionMode);&#xD;
logDebug(&quot;InspectionTime = &quot; + InspectionTime);&#xD;
logDebug(&quot;NumberOfInspections = &quot; + NumberOfInspections);&#xD;
logDebug(&quot;InspectionTypeList = &quot; + InspectionTypeList);&#xD;
logDebug(&quot;InspectorLastName = &quot; + InspectorLastName);&#xD;
logDebug(&quot;InspectorFirstName = &quot; + InspectorFirstName);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var inspIdArr&#xD;
&#xD;
for (inspCount in inspTypeArr)&#xD;
	{&#xD;
	var InspectionType = inspTypeArr[inspCount];&#xD;
	var inspType = InspectionType&#xD;
	logDebug(&quot;InspectionType = &quot; + inspTypeArr[inspCount]);  // Kept for old scripts&#xD;
	logDebug(&quot;inspType = &quot; + InspectionType);&#xD;
	doStandardChoiceActions(controlString,true,0);&#xD;
	}&#xD;
&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + appId + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	if (cancel)&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + debug);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Internal Functions and Classes (Used by this script)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent)&#xD;
	{&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	var lastEvalTrue = false;&#xD;
	logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);&#xD;
	for (xx in pairObjArray)&#xD;
		{&#xD;
		doObj = pairObjArray[xx];&#xD;
		if (doExecution)&#xD;
			{&#xD;
			if (doObj.enabled)&#xD;
				if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation))&#xD;
					{&#xD;
					eval(token(doObj.act));&#xD;
					lastEvalTrue = true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					if (doObj.elseact)&#xD;
						eval(token(doObj.elseact));&#xD;
					lastEvalTrue = false;&#xD;
					}&#xD;
			}&#xD;
		else // just document&#xD;
			{&#xD;
			docWrite(&quot;|  &quot;,false,docIndent);&#xD;
			var disableString = &quot;&quot;;&#xD;
			if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
			if (doObj.elseact)&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact ,false,docIndent);&#xD;
			else&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act,false,docIndent);&#xD;
&#xD;
			for (yy in doObj.branch)&#xD;
				{&#xD;
				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);&#xD;
				}&#xD;
			}&#xD;
		} // next sAction&#xD;
	if (!doExecution) docWrite(null,true,docIndent);&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
&#xD;
function logDebug(dstr)&#xD;
	{&#xD;
	debug+=dstr + br;&#xD;
	}&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
 &#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
 &#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValueArray is an array of associative array values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
&#xD;
	for (thisrow in tableValueArray)&#xD;
		{&#xD;
		var col = tsm.getColumns()&#xD;
		var coli = col.iterator();&#xD;
&#xD;
		while (coli.hasNext())&#xD;
			{&#xD;
			var colname = coli.next();&#xD;
			fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			logDebug(&quot;Table: &quot; + tableName + &quot; Row:&quot; + thisrow + &quot; Column: &quot; + colname.getColumnName() + &quot; Value: &quot; + tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			}&#xD;
&#xD;
		tsm.setTableField(fld);&#xD;
&#xD;
		if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
		}&#xD;
&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
&#xD;
	// Even when this works it gives an index out of range error&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
 &#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
	        	if (addCapCondResult.getSuccess())&#xD;
	        		{&#xD;
				logMessage(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
	var col = tsm.getColumns()&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
		fld.add(tableValues[colname.getColumnName()]);&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
&#xD;
	if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
 &#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
 &#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
 &#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
 &#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
 &#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	} &#xD;
function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				var businessName = licProfList[i].getBusinessName();&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; Business Name &quot;+businessName+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	} &#xD;
function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	} &#xD;
function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	} &#xD;
function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	 &#xD;
function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
 &#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
} &#xD;
function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
 &#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	//check if target CAP has primary address	&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
		&#xD;
	//get addresses from originating CAP	&#xD;
	var capAddressResult = aa.address.getAddressByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddress(newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional fields to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
 &#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
 &#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
 &#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
 &#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	 &#xD;
function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
 &#xD;
function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
 &#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
 &#xD;
function deactivateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logMessage(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
		{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
		}&#xD;
   	&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
			{&#xD;
				while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
				{&#xD;
					if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
					{&#xD;
						appspecObj[i].setChecklistComment(itemValue);&#xD;
						var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
						if (actionResult.getSuccess()) {&#xD;
							logMessage(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
							logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
						} else {&#xD;
							logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
						}&#xD;
						updated = true;&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
					}&#xD;
					i++;&#xD;
				} // while loop&#xD;
			} // item name blank&#xD;
		} // got app specific object	&#xD;
		else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
} &#xD;
function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	} &#xD;
function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
 &#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
	&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
   	&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = Contacts[yy].getEmail();&#xD;
		}	&#xD;
&#xD;
	if (emailAddress.length) &#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no email address&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	} &#xD;
&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
 &#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0]; &#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var capContactArray = capContactResult.getOutput();&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;			&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;			&#xD;
			aArray[&quot;email&quot;] = capContactArray[yy].getPeople().email;&#xD;
			aArray[&quot;addressLine1&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine1();&#xD;
			aArray[&quot;addressLine2&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine2();&#xD;
			aArray[&quot;city&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCity();&#xD;
			aArray[&quot;state&quot;] = capContactArray[yy].getPeople().getCompactAddress().getState();&#xD;
			aArray[&quot;zip&quot;] = capContactArray[yy].getPeople().getCompactAddress().getZip();&#xD;
			aArray[&quot;fax&quot;] = capContactArray[yy].getPeople().fax;&#xD;
			aArray[&quot;notes&quot;] = capContactArray[yy].getPeople().notes;&#xD;
			aArray[&quot;country&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCountry();&#xD;
			aArray[&quot;fullName&quot;] = capContactArray[yy].getPeople().fullName;&#xD;
&#xD;
&#xD;
			var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);                &#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}	&#xD;
&#xD;
 &#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
 &#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
   &#xD;
function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
 &#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
 &#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	} &#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
 &#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
 &#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))  &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    } &#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
 &#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	} &#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
&#xD;
function licenseObject(licnumber)&#xD;
	{&#xD;
	// available statuses (from various R1_SERVER_CONSTANT values&#xD;
	var licenseStatus = new Array(&quot;&quot;,&quot;Active&quot;,&quot;About To Expire&quot;,&quot;Delinquent&quot;,&quot;Expired&quot;,&quot;Invalid&quot;,&quot;Pending&quot;);&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
   	// The only way to pull up a renewal is to supply a status.  I don't understand since it has a 1 to 1 relationship with b1permit, but oh well.&#xD;
   	// the silly thing returns a blank record, so have to check the B1expirationModel to see if it's valid&#xD;
&#xD;
   	for (myStatus in licenseStatus)&#xD;
   		{&#xD;
   		b1ExpResult = aa.expiration.getLicensesByCapID(capId,licenseStatus[myStatus]);&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
   			exptest = this.b1Exp.getB1Expiration();&#xD;
    			if (exptest)&#xD;
    				{&#xD;
    				tmpDate = this.b1Exp.getExpDate();&#xD;
    				if (tmpDate)&#xD;
    					this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
    				this.b1Status = this.b1Exp.getExpStatus();&#xD;
    				logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
    				break&#xD;
    				}&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
		}&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	} &#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
 &#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
 &#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr); &#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
  	&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + fTask.getStatusDate().getMonth() + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}			&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}	&#xD;
 &#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
 &#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
 &#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
 &#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
 &#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	} &#xD;
  function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
	&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
		&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	&#xD;
	tsm.getColumns().clear();&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	&#xD;
	// Even when this works it gives an error of &quot;0&quot;&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error removing all rows from ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
 &#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID. &#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm &#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
	&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
		        &#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
 &#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    &#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
		}&#xD;
	} &#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
	{&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap,&quot;APPLICATION&quot;,stat, sysDate, cmt ,systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq) &#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
        &#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)        &#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
        &#xD;
    var invFeeFound=false;    &#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = fqty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) ) &#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
			&#xD;
	return feeSeq;&#xD;
	} &#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
	&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
	&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel() &#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
	&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
		&#xD;
	}	&#xD;
 &#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	 &#xD;
function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><initializer></initializer><title>InspectionScheduleBefore</title></script><scriptName>InspectionScheduleBefore</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>InvoiceFeeAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:53:28.277-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>InvoiceFeeAfter</name><auditModel><auditDate>2006-12-06T11:33:17-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after invoicing fee(manually or automatically)</description></event><script><name>INVOICEFEEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-05-02T14:39:37.800-06:00</auditDate><auditID>DBROWN</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: InvoiceFeeAfter.js 4781 2009-10-01 05:55:23Z roland.vonschoech $&#xD;
| Program : InvoiceFeeAfterV1.6.js&#xD;
| Event   : InvoiceFeeAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   : REQUIRES the InspectionIdList event parameter.  Executes once for each scheduled inspection.&#xD;
|&#xD;
| Modified: 05/01/2013 - TruePoint Solutions - Altered function emailContact(). Changed variable replyTo to valid email address.&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = false;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;InvoiceFeeAfter&quot;; 					// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup = null;&#xD;
if(appTypeArray[0].substr(0,1) !=&quot;_&quot;) //Model Home Check&#xD;
{&#xD;
	var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
	if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
}&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var CFID = aa.env.getValue(&quot;CFID&quot;);		logDebug(&quot;CFID = &quot; + CFID);&#xD;
var CFTOKEN = aa.env.getValue(&quot;CFTOKEN&quot;);	logDebug(&quot;CFTOKEN = &quot; + CFTOKEN);&#xD;
var StatusDate = aa.env.getValue(&quot;StatusDate&quot;); logDebug(&quot;StatusDate = &quot; + StatusDate);&#xD;
&#xD;
var FeeObjs = new Array();&#xD;
var FeeItemsSeqNbrArray = aa.env.getValue(&quot;FeeItemsSeqNbrArray&quot;)&#xD;
var InvoiceNbrArray = aa.env.getValue(&quot;InvoiceNbrArray&quot;)&#xD;
&#xD;
for (xyz in FeeItemsSeqNbrArray)&#xD;
	{&#xD;
	logDebug(&quot;FeeItemSeqNbrArray[&quot; + xyz + &quot;] = &quot; + FeeItemsSeqNbrArray[xyz]);&#xD;
	FeeObjs.push(aa.finance.getFeeItemByPK(capId, FeeItemsSeqNbrArray[xyz]).getOutput());&#xD;
	logDebug(&quot;FeeObjs[&quot; + xyz + &quot;] = &quot; + FeeObjs[xyz].getClass());&#xD;
	}&#xD;
&#xD;
for (xyz in InvoiceNbrArray)&#xD;
	logDebug(&quot;InvoiceNbrArray[&quot; + xyz + &quot;] = &quot; + InvoiceNbrArray[xyz]);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
  &#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
    	{&#xD;
  	//  tableName is the name of the ASI table&#xD;
  	//  tableValueArray is an array of associative array values.  All elements MUST be either a string or asiTableVal object&#xD;
    	var itemCap = capId&#xD;
  	if (arguments.length &gt; 2)&#xD;
  		itemCap = arguments[2]; // use cap ID specified in args&#xD;
  &#xD;
  	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
  &#xD;
  	if (!tssmResult.getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
  &#xD;
  	var tssm = tssmResult.getOutput();&#xD;
  	var tsm = tssm.getAppSpecificTableModel();&#xD;
  	var fld = tsm.getTableField();&#xD;
        var fld_readonly = tsm.getReadonlyField(); // get Readonly field&#xD;
  &#xD;
         	for (thisrow in tableValueArray)&#xD;
  		{&#xD;
  &#xD;
  		var col = tsm.getColumns()&#xD;
  		var coli = col.iterator();&#xD;
  &#xD;
  		while (coli.hasNext())&#xD;
  			{&#xD;
  			var colname = coli.next();&#xD;
  &#xD;
			if (typeof(tableValueArray[thisrow][colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
				{&#xD;
	  			fld.add(tableValueArray[thisrow][colname.getColumnName()].fieldValue);&#xD;
	  			fld_readonly.add(tableValueArray[thisrow][colname.getColumnName()].readOnly);&#xD;
				}&#xD;
			else // we are passed a string&#xD;
				{&#xD;
  				fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
  				fld_readonly.add(null);&#xD;
				}&#xD;
  			}&#xD;
  &#xD;
  		tsm.setTableField(fld);&#xD;
  &#xD;
  		tsm.setReadonlyField(fld_readonly);&#xD;
  &#xD;
  		}&#xD;
  &#xD;
  	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
  &#xD;
  	 if (!addResult .getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
  	else&#xD;
  		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
  &#xD;
  	}&#xD;
  &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
&#xD;
function addFeeWithExtraData(fcode, fsched, fperiod, fqty, finvoice, feeCap, feeComment, UDF1, UDF2) {&#xD;
    var feeCapMessage = &quot;&quot;;&#xD;
    var feeSeq_L = new Array(); 			// invoicing fee for CAP in args&#xD;
    var paymentPeriod_L = new Array(); 		// invoicing pay periods for CAP in args&#xD;
&#xD;
    assessFeeResult = aa.finance.createFeeItem(feeCap, fsched, fcode, fperiod, fqty);&#xD;
    if (assessFeeResult.getSuccess()) {&#xD;
        feeSeq = assessFeeResult.getOutput();&#xD;
        logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
        logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
        fsm = aa.finance.getFeeItemByPK(feeCap, feeSeq).getOutput().getF4FeeItem();&#xD;
&#xD;
        if (feeComment) fsm.setFeeNotes(feeComment);&#xD;
        if (UDF1) fsm.setUdf1(UDF1);&#xD;
        if (UDF2) fsm.setUdf2(UDF2);&#xD;
&#xD;
        aa.finance.editFeeItem(fsm)&#xD;
&#xD;
&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
        {&#xD;
            feeSeqList.push(feeSeq);&#xD;
            paymentPeriodList.push(fperiod);&#xD;
        }&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
        {&#xD;
            feeSeq_L.push(feeSeq);&#xD;
            paymentPeriod_L.push(fperiod);&#xD;
            var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
            if (invoiceResult_L.getSuccess())&#xD;
                logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
            else&#xD;
                logDebug(&quot;**ERROR: Invoicing the fee items assessed was not successful.  Reason: &quot; + invoiceResult.getErrorMessage());&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
        return null;&#xD;
    }&#xD;
&#xD;
    return feeSeq;&#xD;
&#xD;
}&#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
function addParcelAndOwnerFromRefAddress(refAddress)  // optional capID&#xD;
	{&#xD;
&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	// first add the primary parcel&#xD;
	//&#xD;
	var primaryParcelResult = aa.parcel.getPrimaryParcelByRefAddressID(refAddress,&quot;Y&quot;);&#xD;
	if (primaryParcelResult.getSuccess())&#xD;
		var primaryParcel = primaryParcelResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get primary parcel for ref Address &quot; + refAddress + &quot; , &quot; + primaryParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var capParModel = aa.parcel.warpCapIdParcelModel2CapParcelModel(capId,primaryParcel).getOutput()&#xD;
&#xD;
	var createPMResult = aa.parcel.createCapParcel(capParModel);&#xD;
	if (createPMResult.getSuccess())&#xD;
		logDebug(&quot;created CAP Parcel&quot;);&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Failed to create the cap Parcel &quot; + createPMResult.getErrorMessage()); }&#xD;
&#xD;
&#xD;
	// Now the owners&#xD;
	//&#xD;
&#xD;
	var parcelListResult = aa.parcel.getParcelDailyByCapID(capId,null);&#xD;
	if (parcelListResult.getSuccess())&#xD;
		var parcelList = parcelListResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel List &quot; + parcelListResult.getErrorMessage()); return false; }&#xD;
&#xD;
&#xD;
	for (var thisP in parcelList)&#xD;
  		{&#xD;
  		var ownerListResult = aa.owner.getOwnersByParcel(parcelList[thisP]);&#xD;
		if (ownerListResult.getSuccess())&#xD;
			var ownerList = ownerListResult.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Failed to get Owner List &quot; + ownerListResult.getErrorMessage()); return false; }&#xD;
&#xD;
  		for (var thisO in ownerList)&#xD;
      			{&#xD;
      			ownerList[thisO].setCapID(capId);&#xD;
      			createOResult = aa.owner.createCapOwnerWithAPOAttribute(ownerList[thisO]);&#xD;
&#xD;
			if (createOResult.getSuccess())&#xD;
				logDebug(&quot;Created CAP Owner&quot;);&#xD;
			else&#xD;
				{ logDebug(&quot;**WARNING: Failed to create CAP Owner &quot; + createOResult.getErrorMessage()); }&#xD;
			}&#xD;
	      	}&#xD;
     }&#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
&#xD;
function addReferenceContactByName(vFirst, vMiddle, vLast)&#xD;
{&#xD;
	var userFirst = vFirst;&#xD;
	var userMiddle = vMiddle;&#xD;
	var userLast = vLast;&#xD;
&#xD;
	//Find PeopleModel object for user&#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
	//Add the reference contact record to the current CAP&#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
}&#xD;
function addressExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
	var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
	if (capAddResult.getSuccess())&#xD;
		var fcapAddressObj = capAddResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddResult.getErrorType() + &quot;:&quot; + capAddResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapAddressObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
			if (addCapCondResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements must be either a string or asiTableVal object&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	var col = tsm.getColumns();&#xD;
	var fld_readonly = tsm.getReadonlyField(); //get ReadOnly property&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
&#xD;
		if (typeof(tableValues[colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()].fieldValue);&#xD;
			fld_readonly.add(tableValues[colname.getColumnName()].readOnly);&#xD;
			}&#xD;
		else // we are passed a string&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()]);&#xD;
			fld_readonly.add(null);&#xD;
			}&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	tsm.setReadonlyField(fld_readonly); // set readonly field&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
&#xD;
function asiTableValObj(columnName, fieldValue, readOnly) {&#xD;
	this.columnName = columnName;&#xD;
	this.fieldValue = fieldValue;&#xD;
	this.readOnly = readOnly;&#xD;
&#xD;
	asiTableValObj.prototype.toString=function(){ return this.fieldValue }&#xD;
};&#xD;
&#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	}function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	}function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	}function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	}function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	function checkCapForLicensedProfessionalType( licProfType )&#xD;
{&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	&#xD;
	if( capLicenseResult.getSuccess() )&#xD;
	{ &#xD;
		var capLicenseArr = capLicenseResult.getOutput();&#xD;
		&#xD;
		if (!capLicenseArr)&#xD;
			{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
		&#xD;
		for( licProf in capLicenseArr )&#xD;
		{&#xD;
			if( licProfType.equals(capLicenseArr[licProf].getLicenseType()) )&#xD;
			{&#xD;
				aa.print( &quot;Found License Professional with Type= &quot; + licProfType );&#xD;
				return true; //Found Licensed Prof of specified type&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		return false;&#xD;
	}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
}function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
function closeSubWorkflow(thisProcessID,wfStat) // optional capId&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var isCompleted = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTaskSM = wfObj[i];&#xD;
		if (fTaskSM.getProcessID() == thisProcessID &amp;&amp; fTaskSM.getCompleteFlag() != &quot;Y&quot;)&#xD;
			{&#xD;
			logDebug(&quot;closeSubWorkflow: found an incomplete task processID #&quot; + thisProcessID + &quot; , Step# &quot; + fTaskSM.getStepNumber(),3);&#xD;
			isCompleted = false&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (!isCompleted) return false;&#xD;
&#xD;
&#xD;
	// get the parent task&#xD;
&#xD;
	var relationArray = aa.workflow.getProcessRelationByCapID(itemCap,null).getOutput()&#xD;
&#xD;
	var relRecord = null;&#xD;
&#xD;
	for (thisRel in relationArray)&#xD;
		if (relationArray[thisRel].getProcessID() == thisProcessID)&#xD;
			relRecord = relationArray[thisRel];&#xD;
&#xD;
	if (!relRecord)&#xD;
		{&#xD;
		logDebug(&quot;closeSubWorkflow: did not find a process relation, exiting&quot;,3);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	logDebug(&quot;executing handleDisposition:&quot; + relRecord.getStepNumber() + &quot;,&quot; + relRecord.getParentProcessID() + &quot;,&quot; + wfStat,3);&#xD;
&#xD;
	var handleResult = aa.workflow.handleDisposition(itemCap,relRecord.getStepNumber(),relRecord.getParentProcessID(),wfStat,sysDate,&quot;Closed via script&quot;,&quot;Closed via script&quot;,systemUserObj ,&quot;Y&quot;);&#xD;
&#xD;
	if (!handleResult.getSuccess())&#xD;
		logDebug(&quot;**WARNING: closing parent task: &quot; + handleResult.getErrorMessage());&#xD;
	else&#xD;
		logDebug(&quot;Closed parent task&quot;);&#xD;
	}&#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
function comparePeopleGeneric(peop)&#xD;
	{&#xD;
&#xD;
	// this function will be passed as a parameter to the createRefContactsFromCapContactsAndLink function.&#xD;
	//&#xD;
	// takes a single peopleModel as a parameter, and will return the sequence number of the first G6Contact result&#xD;
	//&#xD;
	// returns null if there are no matches&#xD;
	//&#xD;
	// current search method is by email only.  In order to use attributes enhancement 09ACC-05048 must be implemented&#xD;
	//&#xD;
&#xD;
	peop.setAuditDate(null)&#xD;
	peop.setAuditID(null)&#xD;
	peop.setAuditStatus(null)&#xD;
	peop.setBirthDate(null)&#xD;
	peop.setBusName2(null)&#xD;
	peop.setBusinessName(null)&#xD;
	peop.setComment(null)&#xD;
	peop.setCompactAddress(null)&#xD;
	peop.setContactSeqNumber(null)&#xD;
	peop.setContactType(null)&#xD;
	peop.setContactTypeFlag(null)&#xD;
	peop.setCountry(null)&#xD;
	peop.setCountryCode(null)&#xD;
	// peop.setEmail(null)       just as a test we are using email&#xD;
	peop.setEndBirthDate(null)&#xD;
	peop.setFax(null)&#xD;
	peop.setFaxCountryCode(null)&#xD;
	peop.setFein(null)&#xD;
	peop.setFirstName(null)&#xD;
	peop.setFlag(null)&#xD;
	peop.setFullName(null)&#xD;
	peop.setGender(null)&#xD;
	peop.setHoldCode(null)&#xD;
	peop.setHoldDescription(null)&#xD;
	peop.setId(null)&#xD;
	peop.setIvrPinNumber(null)&#xD;
	peop.setIvrUserNumber(null)&#xD;
	peop.setLastName(null)&#xD;
	peop.setMaskedSsn(null)&#xD;
	peop.setMiddleName(null)&#xD;
	peop.setNamesuffix(null)&#xD;
	peop.setPhone1(null)&#xD;
	peop.setPhone1CountryCode(null)&#xD;
	peop.setPhone2(null)&#xD;
	peop.setPhone2CountryCode(null)&#xD;
	peop.setPhone3(null)&#xD;
	peop.setPhone3CountryCode(null)&#xD;
	peop.setPostOfficeBox(null)&#xD;
	peop.setPreferredChannel(null)&#xD;
	peop.setPreferredChannelString(null)&#xD;
	peop.setRate1(null)&#xD;
	peop.setRelation(null)&#xD;
	peop.setSalutation(null)&#xD;
	peop.setServiceProviderCode(null)&#xD;
	peop.setSocialSecurityNumber(null)&#xD;
	peop.setTitle(null)&#xD;
	peop.setTradeName(null)&#xD;
&#xD;
	var r = aa.people.getPeopleByPeopleModel(peop);&#xD;
&#xD;
    if (!r.getSuccess())&#xD;
			{ logDebug(&quot;WARNING: error searching for people : &quot; + r.getErrorMessage()); return false; }&#xD;
&#xD;
	var peopResult = r.getOutput();&#xD;
&#xD;
	if (peopResult.length == 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for REF contact, no matches found, returing null&quot;);&#xD;
		return null;&#xD;
		}&#xD;
&#xD;
	if (peopResult.length &gt; 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for a REF Contact, &quot; + peopResult.length + &quot; matches found! returning the first match : &quot; + peopResult[0].getContactSeqNumber() );&#xD;
		return peopResult[0].getContactSeqNumber()&#xD;
		}&#xD;
&#xD;
}function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
}function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
function convertStringToPhone(theString)&#xD;
	{&#xD;
	var n = &quot;22233344455566677778889999&quot;;&#xD;
&#xD;
	var compString = String(theString.toUpperCase());&#xD;
	var retString = &quot;&quot;;&#xD;
&#xD;
	for (var x=0 ; x&lt; compString.length ; x++)&#xD;
   		{&#xD;
   		if (compString[x] &gt;= &quot;A&quot; &amp;&amp; compString[x] &lt;= &quot;Z&quot;)&#xD;
   			retString += n[compString.charCodeAt(x)-65]&#xD;
  		 else&#xD;
   			retString += compString[x];&#xD;
  		}&#xD;
   	return retString;&#xD;
 	}&#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
&#xD;
	//check if target CAP has primary address&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//get addresses from originating CAP&#xD;
	var capAddressResult = aa.address.getAddressWithAttributeByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddressWithAPOAttribute(vToCapId, newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	return copied;&#xD;
	}&#xD;
&#xD;
&#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional groups to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
&#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
&#xD;
function copyLicensedProf(sCapId, tCapId)&#xD;
{&#xD;
	//Function will copy all licensed professionals from source CapID to target CapID&#xD;
&#xD;
	var licProf = aa.licenseProfessional.getLicensedProfessionalsByCapID(sCapId).getOutput();&#xD;
	if (licProf != null)&#xD;
		for(x in licProf)&#xD;
		{&#xD;
			licProf[x].setCapID(tCapId);&#xD;
			aa.licenseProfessional.createLicensedProfessional(licProf[x]);&#xD;
			logDebug(&quot;Copied &quot; + licProf[x].getLicenseNbr());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;No licensed professional on source&quot;);&#xD;
}&#xD;
&#xD;
//Function will copy all owners from source CAP (sCapID) to target CAP (tCapId)&#xD;
function copyOwner(sCapID, tCapID)&#xD;
{&#xD;
	var ownrReq = aa.owner.getOwnerByCapId(sCapID);&#xD;
	if(ownrReq.getSuccess())&#xD;
	{&#xD;
		var ownrObj = ownrReq.getOutput();&#xD;
		for (xx in ownrObj)&#xD;
		{&#xD;
			ownrObj[xx].setCapID(tCapID);&#xD;
			aa.owner.createCapOwnerWithAPOAttribute(ownrObj[xx]);&#xD;
			logDebug(&quot;Copied Owner: &quot; + ownrObj[xx].getOwnerFullName())&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
		logDebug(&quot;Error Copying Owner : &quot; + ownrObj.getErrorType() + &quot; : &quot; + ownrObj.getErrorMessage());&#xD;
}&#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
&#xD;
function createCapComment(vComment)  //optional CapId&#xD;
{&#xD;
	var vCapId = capId;&#xD;
	if (arguments.length == 2)&#xD;
		vCapId = arguments[1];&#xD;
	var comDate = aa.date.getCurrentDate(); &#xD;
	var capCommentScriptModel= aa.cap.createCapCommentScriptModel(); &#xD;
	capCommentScriptModel.setCapIDModel(vCapId); &#xD;
	capCommentScriptModel.setCommentType(&quot;APP LEVEL COMMENT&quot;); &#xD;
	capCommentScriptModel.setSynopsis(&quot;&quot;); &#xD;
	capCommentScriptModel.setText(vComment); &#xD;
	capCommentScriptModel.setAuditUser(currentUserID); &#xD;
	capCommentScriptModel.setAuditStatus(&quot;A&quot;); &#xD;
	capCommentScriptModel.setAuditDate(comDate); &#xD;
	var capCommentModel=capCommentScriptModel.getCapCommentModel(); &#xD;
	aa.cap.createCapComment(capCommentModel); &#xD;
	logDebug(&quot;Comment Added&quot;);&#xD;
}function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createPublicUserFromContact()   // optional: Contact Type, default Applicant&#xD;
{&#xD;
    var contactType = &quot;Applicant&quot;;&#xD;
    var contact;&#xD;
    if (arguments.length &gt; 0) contactType = arguments[0]; // use contact type specified&#xD;
&#xD;
    var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
    if (capContactResult.getSuccess()) {&#xD;
        var Contacts = capContactResult.getOutput();&#xD;
        for (yy in Contacts) {&#xD;
            aa.print(Contacts[yy].getCapContactModel().getPeople().getContactType())&#xD;
            if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
                contact = Contacts[yy];&#xD;
        }&#xD;
    }&#xD;
&#xD;
    aa.print(contact.getEmail());&#xD;
    if (!contact)&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no such contact&quot;); return false; }&#xD;
&#xD;
    if (!contact.getEmail())&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no email address&quot;); return false; }&#xD;
&#xD;
    // check if exists already&#xD;
&#xD;
    var getUserResult = aa.publicUser.getPublicUserByEmail(contact.getEmail())&#xD;
    if (getUserResult.getSuccess()) {&#xD;
        var userModel = getUserResult.getOutput()&#xD;
        aa.print(&quot;found the user already&quot;);&#xD;
        if (userModel) return userModel;  // send back the existing user&#xD;
    }&#xD;
&#xD;
    // create a new one&#xD;
&#xD;
    var publicUser = aa.publicUser.getPublicUserModel();&#xD;
    publicUser.setFirstName(contact.getFirstName());&#xD;
    publicUser.setLastName(contact.getLastName());&#xD;
    publicUser.setEmail(contact.getEmail());&#xD;
    publicUser.setUserID(contact.getEmail());&#xD;
    publicUser.setPassword(&quot;7d3fe8b8d7ba80addfc296b07de60cc101e4af60&quot;); //password : Gary0813&#xD;
    publicUser.setAuditID(&quot;PublicUser&quot;);&#xD;
    publicUser.setAuditStatus(&quot;A&quot;);&#xD;
    publicUser.setCellPhone(contact.getCapContactModel().getPeople().getPhone2());&#xD;
&#xD;
    var result = aa.publicUser.createPublicUser(publicUser);&#xD;
&#xD;
    if (result.getSuccess()) {&#xD;
        logDebug(&quot;Created public user &quot; + contact.getEmail() + &quot;  sucessfully.&quot;);&#xD;
        var userSeqNum = result.getOutput();&#xD;
        var userModel = aa.publicUser.getPublicUser(userSeqNum).getOutput()&#xD;
&#xD;
        // create for agency&#xD;
        aa.publicUser.createPublicUserForAgency(userModel);&#xD;
&#xD;
        // activate for agency&#xD;
        var userPinBiz = aa.proxyInvoker.newInstance(&quot;com.accela.pa.pin.UserPINBusiness&quot;).getOutput()&#xD;
		userPinBiz.updateActiveStatusAndLicenseIssueDate4PublicUser(servProvCode,userSeqNum,&quot;ADMIN&quot;);&#xD;
		// reset password&#xD;
&#xD;
		var PUB = aa.proxyInvoker.newInstance(&quot;com.accela.v360.publicuser.PublicUserBusiness&quot;).getOutput()&#xD;
		PUB.resetPassword(contact.getEmail());&#xD;
&#xD;
        // send Activate email&#xD;
        aa.publicUser.sendActivateEmail(userModel, true, true);&#xD;
&#xD;
        // send another email&#xD;
        aa.publicUser.sendPasswordEmail(userModel);&#xD;
        return userModel;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**Warning creating public user &quot; + contact.getEmail() + &quot;  failure: &quot; + result.getErrorMessage()); return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
function createRefContactsFromCapContactsAndLink(pCapId, contactTypeArray, ignoreAttributeArray, replaceCapContact, overwriteRefContact, refContactExists)&#xD;
	{&#xD;
&#xD;
	// contactTypeArray is either null (all), or an array or contact types to process&#xD;
	//&#xD;
	// ignoreAttributeArray is either null (none), or an array of attributes to ignore when creating a REF contact&#xD;
	//&#xD;
	// replaceCapContact not implemented yet&#xD;
	//&#xD;
	// overwriteRefContact -- if true, will refresh linked ref contact with CAP contact data&#xD;
	//&#xD;
	// refContactExists is a function for REF contact comparisons.&#xD;
	//&#xD;
	var ingoreArray = new Array();&#xD;
	if (arguments.length &gt; 1) ignoreArray = arguments[1];&#xD;
&#xD;
	var c = aa.people.getCapContactByCapID(pCapId).getOutput()&#xD;
	var cCopy = aa.people.getCapContactByCapID(pCapId).getOutput()  // must have two working datasets&#xD;
&#xD;
	for (var i in c)&#xD;
	   {&#xD;
	   var con = c[i];&#xD;
&#xD;
	   var p = con.getPeople();&#xD;
	   &#xD;
	   if (contactTypeArray &amp;&amp; !exists(p.getContactType(),contactTypeArray))&#xD;
		continue;  // not in the contact type list.  Move along.&#xD;
&#xD;
	   &#xD;
	   var refContactNum = con.getCapContactModel().getRefContactNumber();&#xD;
	   if (refContactNum)  // This is a reference contact.   Let's refresh or overwrite as requested in parms.&#xD;
	   	{&#xD;
	   	if (overwriteRefContact)&#xD;
	   		{&#xD;
	   		p.setContactSeqNumber(refContactNum);  // set the ref seq# to refresh&#xD;
	   		&#xD;
	   		&#xD;
	   						var a = p.getAttributes();&#xD;
			&#xD;
							if (a)&#xD;
								{&#xD;
								var ai = a.iterator();&#xD;
								while (ai.hasNext())&#xD;
									{&#xD;
									var xx = ai.next();&#xD;
									xx.setContactNo(refContactNum);&#xD;
									}&#xD;
					}&#xD;
					&#xD;
					&#xD;
					&#xD;
	   		var r = aa.people.editPeopleWithAttribute(p,p.getAttributes());&#xD;
	   		&#xD;
			if (!r.getSuccess()) &#xD;
				logDebug(&quot;WARNING: couldn't refresh reference people : &quot; + r.getErrorMessage()); &#xD;
			else&#xD;
				logDebug(&quot;Successfully refreshed ref contact #&quot; + refContactNum + &quot; with CAP contact data&quot;); &#xD;
			}&#xD;
			&#xD;
	   	if (replaceCapContact)&#xD;
	   		{&#xD;
				// To Be Implemented later.   Is there a use case?&#xD;
			}&#xD;
			&#xD;
	   	}&#xD;
	   	else  // user entered the contact freehand.   Let's create or link to ref contact.&#xD;
	   	{&#xD;
			var ccmSeq = p.getContactSeqNumber();&#xD;
&#xD;
			var existingContact = refContactExists(p);  // Call the custom function to see if the REF contact exists&#xD;
&#xD;
			var p = cCopy[i].getPeople();  // get a fresh version, had to mangle the first for the search&#xD;
&#xD;
			if (existingContact)  // we found a match with our custom function.  Use this one.&#xD;
				{&#xD;
					refPeopleId = existingContact;&#xD;
				}&#xD;
			else  // did not find a match, let's create one&#xD;
				{&#xD;
&#xD;
				var a = p.getAttributes();&#xD;
&#xD;
				if (a)&#xD;
					{&#xD;
					//&#xD;
					// Clear unwanted attributes&#xD;
					var ai = a.iterator();&#xD;
					while (ai.hasNext())&#xD;
						{&#xD;
						var xx = ai.next();&#xD;
						if (ignoreAttributeArray &amp;&amp; exists(xx.getAttributeName().toUpperCase(),ignoreAttributeArray))&#xD;
							ai.remove();&#xD;
						}&#xD;
					}&#xD;
&#xD;
				var r = aa.people.createPeopleWithAttribute(p,a);&#xD;
&#xD;
				if (!r.getSuccess())&#xD;
					{logDebug(&quot;WARNING: couldn't create reference people : &quot; + r.getErrorMessage()); continue; }&#xD;
&#xD;
				//&#xD;
				// createPeople is nice and updates the sequence number to the ref seq&#xD;
				//&#xD;
&#xD;
				var p = cCopy[i].getPeople();&#xD;
				var refPeopleId = p.getContactSeqNumber();&#xD;
&#xD;
				logDebug(&quot;Successfully created reference contact #&quot; + refPeopleId);&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// now that we have the reference Id, we can link back to reference&#xD;
			//&#xD;
&#xD;
		    var ccm = aa.people.getCapContactByPK(pCapId,ccmSeq).getOutput().getCapContactModel();&#xD;
&#xD;
		    ccm.setRefContactNumber(refPeopleId);&#xD;
		    r = aa.people.editCapContact(ccm);&#xD;
&#xD;
		    if (!r.getSuccess())&#xD;
				{ logDebug(&quot;WARNING: error updating cap contact model : &quot; + r.getErrorMessage()); }&#xD;
			else&#xD;
				{ logDebug(&quot;Successfully linked ref contact &quot; + refPeopleId + &quot; to cap contact &quot; + ccmSeq);}&#xD;
&#xD;
&#xD;
	    }  // end if user hand entered contact &#xD;
	}  // end for each CAP contact&#xD;
} // end function&#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
function deactivateTask(wfstr) // optional process name&#xD;
{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
	{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
	}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
	{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
		{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
		}			&#xD;
	}&#xD;
}&#xD;
&#xD;
function deleteTask(targetCapId,deleteTaskName)&#xD;
{&#xD;
	//&#xD;
	// Get the target Task&#xD;
	//&#xD;
	var workflowResult = aa.workflow.getTasks(targetCapId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var tTask = null;&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(deleteTaskName.toUpperCase()))&#xD;
  			{&#xD;
			var tTask = wfObj[i];&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	if (!tTask)&#xD;
  	  	{ logDebug(&quot;**WARNING: Task not found: &quot; + deleteTaskName); return false; }&#xD;
&#xD;
&#xD;
	logDebug(&quot;Removing task &quot; + tTask.getTaskDescription());&#xD;
	var result = aa.workflow.removeTask(tTask)&#xD;
&#xD;
	if (!result.getSuccess())&#xD;
		{ logDebug(&quot;error &quot; + result.getErrorMessage()); return false; }&#xD;
&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	&#xD;
	itemCap = capId;&#xD;
	&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
   	&#xD;
   	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
			{&#xD;
				if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
				{&#xD;
					appspecObj[i].setChecklistComment(itemValue);&#xD;
						&#xD;
					var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
					if (actionResult.getSuccess()) &#xD;
					{							&#xD;
						logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
					} &#xD;
					else &#xD;
					{&#xD;
						logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
					}&#xD;
						&#xD;
					updated = true;&#xD;
					AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
				}&#xD;
				&#xD;
				i++;&#xD;
				&#xD;
			} // while loop&#xD;
		} // item name blank&#xD;
	} // got app specific object	&#xD;
	else&#xD;
	{ &#xD;
		logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage());&#xD;
	}&#xD;
}//End Function&#xD;
&#xD;
function editBuildingCount(numBuild) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setBuildingCount(parseFloat(numBuild));&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated building count to &quot; + numBuild); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
}function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editInspectionRequiredFlag(inspType,reqFlag)&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var result = aa.inspection.getInspMilestoneByCapID(itemCap);&#xD;
&#xD;
	if(!result.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection milestones: &quot;  + result.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspMilestones= result.getOutput();&#xD;
&#xD;
	if (!inspMilestones)&#xD;
		{ logDebug(&quot;No Inspection Milestones found&quot;) ; return false ; }&#xD;
&#xD;
	for (thisM in inspMilestones)&#xD;
		{&#xD;
		var obj= inspMilestones[thisM];&#xD;
		if (inspType.equals(obj.getInspType()))&#xD;
			{&#xD;
			if (reqFlag) obj.setInspRequired(&quot;Y&quot;);&#xD;
			else obj.setInspRequired(&quot;N&quot;);&#xD;
&#xD;
			result = aa.inspection.updateInspectionMilestone(inspMilestones);&#xD;
			if(result.getSuccess())&#xD;
				logDebug(&quot;inspection milestone updated sucessfully.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: could not update inpsection milestone &quot; +result.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	}function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editScheduledDate(scheduledDate) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	vScheduledDate = aa.date.parseDate(scheduledDate);&#xD;
	&#xD;
	//cd.setScheduledDate(vScheduledDate); //bug, doesn't work&#xD;
	cdScriptObj.setScheduledDate(vScheduledDate);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated scheduled date to &quot; + scheduledDate) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR updating scheduled date: &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
//Modified for El Paso. Set replyTo variable to equal valid email address for El Paso email server.&#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
&#xD;
        //var replyTo = &quot;noreply@accela.com&quot;;&#xD;
        var replyTo = &quot;accela@elpasotexas.gov&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = &quot;&quot; + Contacts[yy].getEmail();&#xD;
		}&#xD;
&#xD;
	if (emailAddress.indexOf(&quot;@&quot;) &gt; 0)&#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no valid email address&quot;);&#xD;
	}function endBranch() {&#xD;
	// stop execution of the current std choice&#xD;
	stopBranch = false;&#xD;
	}function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
&#xD;
function externalLP_CA(licNum,rlpType,doPopulateRef,doPopulateTrx,itemCap)&#xD;
	{&#xD;
&#xD;
	/*&#xD;
	Version: 3.2&#xD;
&#xD;
	Usage:&#xD;
&#xD;
		licNum			:  Valid CA license number.   Non-alpha, max 8 characters.  If null, function will use the LPs on the supplied CAP ID&#xD;
		rlpType			:  License professional type to use when validating and creating new LPs&#xD;
		doPopulateRef 	:  If true, will create/refresh a reference LP of this number/type&#xD;
		doPopulateTrx 	:  If true, will copy create/refreshed reference LPs to the supplied Cap ID.   doPopulateRef must be true for this to work&#xD;
		itemCap			:  If supplied, licenses on the CAP will be validated.  Also will be refreshed if doPopulateRef and doPopulateTrx are true&#xD;
&#xD;
	returns: non-null string of status codes for invalid licenses&#xD;
&#xD;
	examples:&#xD;
&#xD;
	appsubmitbefore   (will validate the LP entered, if any, and cancel the event if the LP is inactive, cancelled, expired, etc.)&#xD;
	===============&#xD;
	true ^ cslbMessage = &quot;&quot;;&#xD;
	CAELienseNumber ^ cslbMessage = externalLP_CA(CAELienseNumber,false,false,CAELienseType,null);&#xD;
	cslbMessage.length &gt; 0 ^ cancel = true ; showMessage = true ; comment(cslbMessage)&#xD;
&#xD;
	appsubmitafter  (update all CONTRACTOR LPs on the CAP and REFERENCE with data from CSLB.  Link the CAP LPs to REFERENCE.   Pop up a message if any are inactive...)&#xD;
	==============&#xD;
	true ^ 	cslbMessage = externalLP_CA(null,true,true,&quot;CONTRACTOR&quot;,capId)&#xD;
	cslbMessage.length &gt; 0 ^ showMessage = true ; comment(cslbMessage);&#xD;
&#xD;
	Note;  Custom LP Template Field Mappings can be edited in the script below&#xD;
	*/&#xD;
&#xD;
	var returnMessage = &quot;&quot;;&#xD;
&#xD;
	var workArray = new Array();&#xD;
	if (licNum)&#xD;
		workArray.push(String(licNum));&#xD;
&#xD;
	if (itemCap)&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(itemCap);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{&#xD;
			var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
		if (capLicenseArr == null || !capLicenseArr.length)&#xD;
			{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); }&#xD;
		else&#xD;
			{&#xD;
			for (var thisLic in capLicenseArr)&#xD;
				if (capLicenseArr[thisLic].getLicenseType() == rlpType)&#xD;
					workArray.push(capLicenseArr[thisLic]);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		doPopulateTrx = false; // can't do this without a CAP;&#xD;
&#xD;
	for (var thisLic = 0; thisLic &lt; workArray.length; thisLic++)&#xD;
		{&#xD;
		var licNum = workArray[thisLic];&#xD;
		var licObj = null;&#xD;
		var isObject = false;&#xD;
&#xD;
		if (typeof(licNum) == &quot;object&quot;)  // is this one an object or string?&#xD;
			{&#xD;
			licObj = licNum;&#xD;
			licNum = licObj.getLicenseNbr();&#xD;
			isObject = true;&#xD;
			}&#xD;
&#xD;
		// Make the call to the California State License Board&#xD;
&#xD;
        var saxBuilder = aa.proxyInvoker.newInstance(&quot;org.jdom.input.SAXBuilder&quot;).getOutput();&#xD;
        var aURLArgList = new Array()&#xD;
        aURLArgList[0] = &quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum;&#xD;
        var oURL = aa.proxyInvoker.newInstance(&quot;java.net.URL&quot;,aURLArgList).getOutput();&#xD;
        var document = saxBuilder.build(oURL); //(&quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum);&#xD;
        var root = document.getRootElement();&#xD;
&#xD;
		var errorNode = root.getChild(&quot;Error&quot;);&#xD;
		if (errorNode)&#xD;
			{&#xD;
			logDebug(&quot;Error for license &quot; + licNum + &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;));&#xD;
			returnMessage+=&quot;License &quot; + licNum +  &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;) + &quot; &quot;;&#xD;
			continue;&#xD;
			}&#xD;
&#xD;
		var lpBiz = root.getChild(&quot;BusinessInfo&quot;);&#xD;
		var lpStatus = root.getChild(&quot;PrimaryStatus&quot;);&#xD;
		var lpClass = root.getChild(&quot;Classifications&quot;);&#xD;
		var lpBonds = root.getChild(&quot;ContractorBond&quot;);&#xD;
		var lpWC = root.getChild(&quot;WorkersComp&quot;);&#xD;
&#xD;
		// Primary Status&#xD;
		// 3 = expired, 10 = good, 11 = inactive, 1 = canceled.   We will ignore all but 10 and return text.&#xD;
		var stas = lpStatus.getChildren();&#xD;
		for (var i=0 ; i&lt;stas.size(); i++) {&#xD;
			var sta = stas.get(i);&#xD;
&#xD;
			if (sta.getAttribute(&quot;Code&quot;).getValue() != &quot;10&quot;)&#xD;
				returnMessage+=&quot;License:&quot; + licNum + &quot;, &quot; + sta.getAttribute(&quot;Desc&quot;).getValue() + &quot; &quot;;&#xD;
		}&#xD;
&#xD;
		if (doPopulateRef)  // refresh or create a reference LP&#xD;
			{&#xD;
			var updating = false;&#xD;
&#xD;
			// check to see if the licnese already exists...if not, create.&#xD;
&#xD;
			var newLic = getRefLicenseProf(licNum)&#xD;
&#xD;
			if (newLic)&#xD;
				{&#xD;
				updating = true;&#xD;
				logDebug(&quot;Updating existing Ref Lic Prof : &quot; + licNum);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
				}&#xD;
&#xD;
			if (isObject)  // update the reference LP with data from the transactional, if we have some.&#xD;
				{&#xD;
				if (licObj.getAddress1()) newLic.setAddress1(licObj.getAddress1());&#xD;
				if (licObj.getAddress2()) newLic.setAddress2(licObj.getAddress2());&#xD;
				if (licObj.getAddress3()) newLic.setAddress3(licObj.getAddress3());&#xD;
				if (licObj.getAgencyCode()) newLic.setAgencyCode(licObj.getAgencyCode());&#xD;
				if (licObj.getBusinessLicense()) newLic.setBusinessLicense(licObj.getBusinessLicense());&#xD;
				if (licObj.getBusinessName()) newLic.setBusinessName(licObj.getBusinessName());&#xD;
				if (licObj.getBusName2()) newLic.setBusinessName2(licObj.getBusName2());&#xD;
				if (licObj.getCity()) newLic.setCity(licObj.getCity());&#xD;
				if (licObj.getCityCode()) newLic.setCityCode(licObj.getCityCode());&#xD;
				if (licObj.getContactFirstName()) newLic.setContactFirstName(licObj.getContactFirstName());&#xD;
				if (licObj.getContactLastName()) newLic.setContactLastName(licObj.getContactLastName());&#xD;
				if (licObj.getContactMiddleName()) newLic.setContactMiddleName(licObj.getContactMiddleName());&#xD;
				if (licObj.getCountryCode()) newLic.setContryCode(licObj.getCountryCode());&#xD;
				if (licObj.getEmail()) newLic.setEMailAddress(licObj.getEmail());&#xD;
				if (licObj.getCountry()) newLic.setCountry(licObj.getCountry());&#xD;
				if (licObj.getEinSs()) newLic.setEinSs(licObj.getEinSs());&#xD;
				if (licObj.getFax()) newLic.setFax(licObj.getFax());&#xD;
				if (licObj.getFaxCountryCode()) newLic.setFaxCountryCode(licObj.getFaxCountryCode());&#xD;
				if (licObj.getHoldCode()) newLic.setHoldCode(licObj.getHoldCode());&#xD;
				if (licObj.getHoldDesc()) newLic.setHoldDesc(licObj.getHoldDesc());&#xD;
				if (licObj.getLicenseExpirDate()) newLic.setLicenseExpirationDate(licObj.getLicenseExpirDate());&#xD;
				if (licObj.getLastRenewalDate()) newLic.setLicenseLastRenewalDate(licObj.getLastRenewalDate());&#xD;
				if (licObj.getLicesnseOrigIssueDate()) newLic.setLicOrigIssDate(licObj.getLicesnseOrigIssueDate());&#xD;
				if (licObj.getPhone1()) newLic.setPhone1(licObj.getPhone1());&#xD;
				if (licObj.getPhone1CountryCode()) newLic.setPhone1CountryCode(licObj.getPhone1CountryCode());&#xD;
				if (licObj.getPhone2()) newLic.setPhone2(licObj.getPhone2());&#xD;
				if (licObj.getPhone2CountryCode()) newLic.setPhone2CountryCode(licObj.getPhone2CountryCode());&#xD;
				if (licObj.getSelfIns()) newLic.setSelfIns(licObj.getSelfIns());&#xD;
				if (licObj.getState()) newLic.setState(licObj.getState());&#xD;
				if (licObj.getSuffixName()) newLic.setSuffixName(licObj.getSuffixName());&#xD;
				if (licObj.getZip()) newLic.setZip(licObj.getZip());&#xD;
				}&#xD;
&#xD;
			// Now set data from the CSLB&#xD;
&#xD;
			if (lpBiz.getChild(&quot;Name&quot;).getText() != &quot;&quot;) newLic.setBusinessName(unescape(lpBiz.getChild(&quot;Name&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr1&quot;).getText() != &quot;&quot;) newLic.setAddress1(unescape(lpBiz.getChild(&quot;Addr1&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr2&quot;).getText() != &quot;&quot;) newLic.setAddress2(unescape(lpBiz.getChild(&quot;Addr2&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;City&quot;).getText() != &quot;&quot;) newLic.setCity(unescape(lpBiz.getChild(&quot;City&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;State&quot;).getText() != &quot;&quot;) newLic.setState(unescape(lpBiz.getChild(&quot;State&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Zip&quot;).getText() != &quot;&quot;) newLic.setZip(unescape(lpBiz.getChild(&quot;Zip&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText() != &quot;&quot;) newLic.setPhone1(unescape(stripNN(lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText()).replace(/\+/g,&quot; &quot;)));&#xD;
			newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
			newLic.setAuditDate(sysDate);&#xD;
			newLic.setAuditID(currentUserID);&#xD;
			newLic.setAuditStatus(&quot;A&quot;);&#xD;
			newLic.setLicenseType(rlpType);&#xD;
			newLic.setLicState(&quot;CA&quot;);  // hardcode CA&#xD;
			newLic.setStateLicense(licNum);&#xD;
&#xD;
			if (lpBiz.getChild(&quot;IssueDt&quot;).getText()) newLic.setLicenseIssueDate(aa.date.parseDate(lpBiz.getChild(&quot;IssueDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ExpireDt&quot;).getText()) newLic.setLicenseExpirationDate(aa.date.parseDate(lpBiz.getChild(&quot;ExpireDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ReissueDt&quot;).getText()) newLic.setLicenseLastRenewalDate(aa.date.parseDate(lpBiz.getChild(&quot;ReissueDt&quot;).getText()));&#xD;
&#xD;
			var wcs = root.getChild(&quot;WorkersComp&quot;).getChildren();&#xD;
&#xD;
			for (var j=0 ; j&lt;wcs.size(); j++) {&#xD;
				wc = wcs.get(j);&#xD;
&#xD;
				if (wc.getAttribute(&quot;PolicyNo&quot;).getValue()) newLic.setWcPolicyNo(wc.getAttribute(&quot;PolicyNo&quot;).getValue());&#xD;
				if (wc.getAttribute(&quot;InsCoCde&quot;).getValue()) newLic.setWcInsCoCode(unescape(wc.getAttribute(&quot;InsCoCde&quot;).getValue()));&#xD;
				if (wc.getAttribute(&quot;WCEffDt&quot;).getValue()) newLic.setWcEffDate(aa.date.parseDate(wc.getAttribute(&quot;WCEffDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCExpDt&quot;).getValue()) newLic.setWcExpDate(aa.date.parseDate(wc.getAttribute(&quot;WCExpDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCCancDt&quot;).getValue()) newLic.setWcCancDate(aa.date.parseDate(wc.getAttribute(&quot;WCCancDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;Exempt&quot;).getValue() == &quot;E&quot;) newLic.setWcExempt(&quot;Y&quot;); else newLic.setWcExempt(&quot;N&quot;);&#xD;
&#xD;
				break; // only use first&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// Do the refresh/create and get the sequence number&#xD;
			//&#xD;
			if (updating)&#xD;
				{&#xD;
				var myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
				var licSeqNbr = newLic.getLicSeqNbr();&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
				if (!myResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;**WARNING: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
					continue;&#xD;
					}&#xD;
&#xD;
				var licSeqNbr = myResult.getOutput()&#xD;
				}&#xD;
&#xD;
			logDebug(&quot;Successfully added/updated License No. &quot; + licNum + &quot;, Type: &quot; + rlpType + &quot; Sequence Number &quot; + licSeqNbr);&#xD;
&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data -- first copy from the transactional LP if it exists&#xD;
			/////&#xD;
&#xD;
&#xD;
			if (isObject)  // update the reference LP with attributes from the transactional, if we have some.&#xD;
				{&#xD;
				var attrArray = licObj.getAttributes();&#xD;
&#xD;
				if (attrArray)&#xD;
					{&#xD;
					for (var k in attrArray)&#xD;
						{&#xD;
						var attr = attrArray[k];&#xD;
						editRefLicProfAttribute(licNum,attr.getAttributeName(),attr.getAttributeValue());&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data&#xD;
			/////&#xD;
			/////  NOTE!  Agencies may have to configure template data below based on their configuration.  Please note all edits&#xD;
			/////&#xD;
&#xD;
			var cbs = root.getChild(&quot;Classifications&quot;).getChildren();&#xD;
			for (var m=0 ; m&lt;cbs.size(); m++) {&#xD;
				cb = cbs.get(m);&#xD;
&#xD;
				if (m == 0)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 1&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 1&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 1)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 2&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 2&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				if (m == 2)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 3&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 3&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 3)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 4&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 4&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				}&#xD;
&#xD;
			var bos = root.getChild(&quot;ContractorBond&quot;).getChildren();&#xD;
&#xD;
			for (var n=0 ; n&lt;bos.size(); n++) {&#xD;
				var bo = bos.get(n);&#xD;
				if (bo.getAttribute(&quot;BondAmt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND AMOUNT&quot;,unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()));&#xD;
				if (bo.getAttribute(&quot;BondCancDt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND EXPIRATION&quot;,unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()));&#xD;
&#xD;
				// Currently unused but could be loaded into custom attributes.&#xD;
/*&#xD;
				aa.print(&quot;Bond Surety Type       : &quot; + unescape(bo.getAttribute(&quot;SuretyTp&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Code              : &quot; + unescape(bo.getAttribute(&quot;InsCoCde&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Insurance Company : &quot; + unescape(bo.getAttribute(&quot;InsCoName&quot;).getValue()).replace(/\+/g,&quot; &quot;))&#xD;
				aa.print(&quot;Bond Number            : &quot; + unescape(bo.getAttribute(&quot;BondNo&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Amount            : &quot; + unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Effective Date    : &quot; + unescape(bo.getAttribute(&quot;BondEffDt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Cancel Date       : &quot; + unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()))&#xD;
*/&#xD;
				break; // only use first bond&#xD;
				}&#xD;
&#xD;
			if (doPopulateTrx)&#xD;
				{&#xD;
				var lpsmResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,licSeqNbr)&#xD;
					if (!lpsmResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING error retrieving the LP just created &quot; + lpsmResult.getErrorMessage()) ; }&#xD;
&#xD;
				var lpsm = lpsmResult.getOutput();&#xD;
&#xD;
				// Remove from CAP&#xD;
&#xD;
				var isPrimary = false;&#xD;
&#xD;
				for (var currLic in capLicenseArr)&#xD;
					{&#xD;
					var thisLP = capLicenseArr[currLic];&#xD;
					if (thisLP.getLicenseType() == rlpType &amp;&amp; thisLP.getLicenseNbr() == licNum)&#xD;
						{&#xD;
						logDebug(&quot;Removing license: &quot; + thisLP.getLicenseNbr() + &quot; from CAP.  We will link the new reference LP&quot;);&#xD;
						if (thisLP.getPrintFlag() == &quot;Y&quot;)&#xD;
							{&#xD;
							logDebug(&quot;...remove primary status...&quot;);&#xD;
							isPrimary = true;&#xD;
							thisLP.setPrintFlag(&quot;N&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisLP);&#xD;
							}&#xD;
						var remCapResult = aa.licenseProfessional.removeLicensedProfessional(thisLP);&#xD;
						if (capLicenseResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;...Success.&quot;); }&#xD;
						else&#xD;
							{ logDebug(&quot;**WARNING removing lic prof: &quot; + remCapResult.getErrorMessage()); }&#xD;
						}&#xD;
					}&#xD;
&#xD;
				// add the LP to the CAP&#xD;
				var asCapResult= aa.licenseScript.associateLpWithCap(itemCap,lpsm)&#xD;
				if (!asCapResult.getSuccess())&#xD;
				{ logDebug(&quot;**WARNING error associating CAP to LP: &quot; + asCapResult.getErrorMessage()) }&#xD;
				else&#xD;
					{ logDebug(&quot;Associated the CAP to the new LP&quot;) }&#xD;
&#xD;
				// Now make the LP primary again&#xD;
				if (isPrimary)&#xD;
					{&#xD;
					var capLps = getLicenseProfessional(itemCap);&#xD;
&#xD;
					for (var thisCapLpNum in capLps)&#xD;
						{&#xD;
						if (capLps[thisCapLpNum].getLicenseNbr().equals(licNum))&#xD;
							{&#xD;
							var thisCapLp = capLps[thisCapLpNum];&#xD;
							thisCapLp.setPrintFlag(&quot;Y&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisCapLp);&#xD;
							logDebug(&quot;Updated primary flag on Cap LP : &quot; + licNum);&#xD;
&#xD;
							// adding this return will cause the test script to work without error, even though this is the last statement executed&#xD;
							//if (returnMessage.length &gt; 0) return returnMessage;&#xD;
							//else return null;&#xD;
&#xD;
							}&#xD;
						}&#xD;
				}&#xD;
			} // do populate on the CAP&#xD;
		} // do populate on the REF&#xD;
	} // for each license&#xD;
&#xD;
	if (returnMessage.length &gt; 0) return returnMessage;&#xD;
	else return null;&#xD;
&#xD;
} // end function&#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	}&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
function feeCopyByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			 addFee(ffeObjArr[ff].getFeeCod(),  ffeObjArr[ff].getFeeSchudle() ,  ffeObjArr[ff].getPaymentPeriod() ,  ffeObjArr[ff].getFeeUnit() ,    'Y') &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
function getChildTasks(taskName) {&#xD;
    var childTasks = new Array();&#xD;
    var childId = null;&#xD;
    var itemCap = capId&#xD;
    if (arguments.length &gt; 1)&#xD;
        itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
    var wfObj = workflowResult.getOutput();&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getTaskDescription().equals(taskName)) {&#xD;
            var relationArray = aa.workflow.getProcessRelationByCapID(itemCap, null).getOutput()&#xD;
            for (thisRel in relationArray) {&#xD;
                y = relationArray[thisRel]&#xD;
                if (y.getParentTaskName() &amp;&amp; y.getParentTaskName().equals(fTaskSM.getTaskDescription()))&#xD;
                    childId = y.getProcessID()&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getProcessID() == childId)&#xD;
            childTasks.push(fTaskSM)&#xD;
    }&#xD;
&#xD;
    return childTasks;&#xD;
&#xD;
}&#xD;
&#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0];&#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // we are in a page flow script so use the capModel to get contacts&#xD;
		{&#xD;
		capContactArray = cap.getContactsGroup().toArray() ;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var capContactArray = capContactResult.getOutput();&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	if (capContactArray)&#xD;
		{&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;middleName&quot;] = capContactArray[yy].getPeople().middleName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;&#xD;
&#xD;
			if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // using capModel to get contacts&#xD;
				var pa = capContactArray[yy].getPeople().getAttributes().toArray();&#xD;
			else&#xD;
				var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);&#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}&#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
  function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
function getLastScheduledInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector that is assigned to the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function getLicenseProfessional(itemcapId)&#xD;
{&#xD;
	capLicenseArr = null;&#xD;
	var s_result = aa.licenseProfessional.getLicenseProf(itemcapId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capLicenseArr = s_result.getOutput();&#xD;
		if (capLicenseArr == null || capLicenseArr.length == 0)&#xD;
		{&#xD;
			aa.print(&quot;WARNING: no licensed professionals on this CAP:&quot; + itemcapId);&#xD;
			capLicenseArr = null;&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to license professional: &quot; + s_result.getErrorMessage());&#xD;
		capLicenseArr = null;&#xD;
	}&#xD;
	return capLicenseArr;&#xD;
}&#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; newLicArray[thisLic] &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    }&#xD;
&#xD;
function isReadyRenew(capid) {&#xD;
    if (capid == null || aa.util.instanceOfString(capid)) {&#xD;
        return false;&#xD;
    }&#xD;
    var result = aa.expiration.isExpiredLicenses(capid);&#xD;
    if (result.getSuccess()) {&#xD;
        return true;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Failed to get expiration with CAP(&quot; + capid + &quot;): &quot; + result.getErrorMessage());&#xD;
    }&#xD;
    return false;&#xD;
}&#xD;
&#xD;
function isRenewProcess(parentCapID, partialCapID) {&#xD;
    //1. Check to see parent CAP ID is null.&#xD;
    if (parentCapID == null || partialCapID == null)&#xD;
    { logDebug(&quot;ERROR: the parentCapID or the partialCap ID is null&quot;); return false; }&#xD;
    //2. Get CAPModel by PK for partialCAP.&#xD;
    var result = aa.cap.getCap(partialCapID);&#xD;
    if (result.getSuccess()) {&#xD;
        capScriptModel = result.getOutput();&#xD;
        //2.1. Check to see if it is partial CAP.&#xD;
        if (capScriptModel.isCompleteCap()) {&#xD;
            logDebug(&quot;ERROR: It is not partial CAP(&quot; + capScriptModel.getCapID() + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Fail to get CAPModel (&quot; + partialCapID + &quot;): &quot; + result.getErrorMessage());&#xD;
        return false;&#xD;
    }&#xD;
    //3.  Check to see if the renewal was initiated before.&#xD;
    result = aa.cap.getProjectByMasterID(parentCapID, &quot;Renewal&quot;, &quot;Incomplete&quot;);&#xD;
    if (result.getSuccess()) {&#xD;
        partialProjects = result.getOutput();&#xD;
        if (partialProjects != null &amp;&amp; partialProjects.length &gt; 0) {&#xD;
            //Avoid to initiate renewal process multiple times.&#xD;
            logDebug(&quot;Warning: Renewal process was initiated before. ( &quot; + parentCapID + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
&#xD;
    }&#xD;
    //4 . Check to see if parent CAP is ready for renew.&#xD;
    return isReadyRenew(parentCapID);&#xD;
}&#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function licenseObject(licnumber)  // optional renewal Cap ID -- uses the expiration on the renewal CAP.&#xD;
	{&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
&#xD;
   	b1ExpResult = aa.expiration.getLicensesByCapID(itemCap)&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
			tmpDate = this.b1Exp.getExpDate();&#xD;
			if (tmpDate)&#xD;
				this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
			this.b1Status = this.b1Exp.getExpStatus();&#xD;
			logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + b1ExpResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function loadAddressAttributes(thisArr)&#xD;
{&#xD;
	//&#xD;
	// Returns an associative array of Address Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
   	var capAddressResult = aa.address.getAddressWithAttributeByCapId(itemCap);&#xD;
   	if (capAddressResult.getSuccess())&#xD;
   		var fcapAddressObj = capAddressResult.getOutput();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddressResult.getErrorType() + &quot;:&quot; + capAddressResult.getErrorMessage())&#xD;
&#xD;
  	for (i in fcapAddressObj)&#xD;
  	{&#xD;
  		addressAttrObj = fcapAddressObj[i].getAttributes().toArray();&#xD;
  		for (z in addressAttrObj)&#xD;
			thisArr[&quot;AddressAttribute.&quot; + addressAttrObj[z].getB1AttributeName()]=addressAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;AddressAttribute.PrimaryFlag&quot;] = fcapAddressObj[i].getPrimaryFlag();&#xD;
		thisArr[&quot;AddressAttribute.HouseNumberStart&quot;] = fcapAddressObj[i].getHouseNumberStart();&#xD;
		thisArr[&quot;AddressAttribute.StreetDirection&quot;] = fcapAddressObj[i].getStreetDirection();&#xD;
		thisArr[&quot;AddressAttribute.StreetName&quot;] = fcapAddressObj[i].getStreetName();&#xD;
		thisArr[&quot;AddressAttribute.StreetSuffix&quot;] = fcapAddressObj[i].getStreetSuffix();&#xD;
		thisArr[&quot;AddressAttribute.City&quot;] = fcapAddressObj[i].getCity();&#xD;
		thisArr[&quot;AddressAttribute.State&quot;] = fcapAddressObj[i].getState();&#xD;
		thisArr[&quot;AddressAttribute.Zip&quot;] = fcapAddressObj[i].getZip();&#xD;
		thisArr[&quot;AddressAttribute.AddressStatus&quot;] = fcapAddressObj[i].getAddressStatus();&#xD;
		thisArr[&quot;AddressAttribute.County&quot;] = fcapAddressObj[i].getCounty();&#xD;
		thisArr[&quot;AddressAttribute.Country&quot;] = fcapAddressObj[i].getCountry();&#xD;
		thisArr[&quot;AddressAttribute.AddressDescription&quot;] = fcapAddressObj[i].getAddressDescription();&#xD;
		thisArr[&quot;AddressAttribute.XCoordinate&quot;] = fcapAddressObj[i].getXCoordinator();&#xD;
		thisArr[&quot;AddressAttribute.YCoordinate&quot;] = fcapAddressObj[i].getYCoordinator();&#xD;
  	}&#xD;
}&#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
      var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		var readOnly = 'N';&#xD;
		if (readOnlyi.hasNext()) {&#xD;
			readOnly = readOnlyi.next();&#xD;
		}&#xD;
		var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
		tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
		}&#xD;
		tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	}&#xD;
&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
	  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
				}&#xD;
&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
			//tempObject[tcol.getColumnName()] = tval;&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadASITablesBefore() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	//&#xD;
&#xD;
	var gm =  aa.env.getValue(&quot;AppSpecificTableGroupModel&quot;);&#xD;
	var ta = gm.getTablesMap().values()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
		  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator();&#xD;
&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
			}&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
          eval(copyStr);  // move to table name&#xD;
&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
&#xD;
function loadGuideSheetItems(inspId) {&#xD;
	//&#xD;
	// Returns an associative array of Guide Sheet Items&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var retArray = new Array()&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var r = aa.inspection.getInspections(itemCap)&#xD;
&#xD;
	if (r.getSuccess())&#xD;
	 	{&#xD;
		var inspArray = r.getOutput();&#xD;
&#xD;
		for (i in inspArray)&#xD;
			{&#xD;
			if (inspArray[i].getIdNumber() == inspId)&#xD;
				{&#xD;
				var inspModel = inspArray[i].getInspection();&#xD;
&#xD;
				var gs = inspModel.getGuideSheets()&#xD;
&#xD;
				if (gs)&#xD;
					{&#xD;
					gsArray = gs.toArray();&#xD;
					for (var loopk in gsArray)&#xD;
						{&#xD;
						var gsItems = gsArray[loopk].getItems().toArray()&#xD;
						for (var loopi in gsItems)&#xD;
							retArray[gsItems[loopi].getGuideItemText()] = gsItems[loopi].getGuideItemStatus();&#xD;
						}&#xD;
					} // if there are guidesheets&#xD;
				else&#xD;
					logDebug(&quot;No guidesheets for this inspection&quot;);&#xD;
				} // if this is the right inspection&#xD;
			} // for each inspection&#xD;
		} // if there are inspections&#xD;
&#xD;
	logDebug(&quot;loaded &quot; + retArray.length + &quot; guidesheet items&quot;);&#xD;
	return retArray;&#xD;
	}&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + (fTask.getStatusDate().getMonth() + 1) + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
function logDebug(dstr) {&#xD;
&#xD;
    if (!aa.calendar.getNextWorkDay) {&#xD;
&#xD;
		vLevel = 1&#xD;
		if (arguments.length &gt; 1)&#xD;
			vLevel = arguments[1]&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
			debug += dstr + br;&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel)&#xD;
			aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr)&#xD;
		}&#xD;
	else {&#xD;
			debug+=dstr + br;&#xD;
		}&#xD;
&#xD;
}&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
function lookupFeesByValuationSlidingScale(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 2;&#xD;
	if (arguments.length == 4) valNumber = (arguments[3] + 1);&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
                        &#xD;
                        &#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 2)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					var divisor = workVals[1];&#xD;
					saveVal = parseInt((capval - workVals[0])/divisor);&#xD;
					if ((capval - workVals[0]) % divisor &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function prepareRenewal() {&#xD;
&#xD;
    if (isRenewProcess(parentCapId, capId)) {&#xD;
        logDebug(&quot;CAPID(&quot; + parentCapId + &quot;) is ready for renew. PartialCap (&quot; + capId + &quot;)&quot;);&#xD;
&#xD;
        //Associate partial cap with parent CAP.&#xD;
        var result = aa.cap.createRenewalCap(parentCapId, capId, true);&#xD;
        if (result.getSuccess()) {&#xD;
            // Set B1PERMIT.B1_ACCESS_BY_ACA to &quot;N&quot; for partial CAP to not allow that it is searched by ACA user.&#xD;
            aa.cap.updateAccessByACA(capId, &quot;N&quot;);&#xD;
        }&#xD;
        else&#xD;
        { logDebug(&quot;ERROR: Associate partial cap with parent CAP. &quot; + result.getErrorMessage()); return false };&#xD;
&#xD;
        return true;&#xD;
    }&#xD;
    else&#xD;
    { logDebug(&quot;Renewal Process did not finish properly&quot;); return false; }&#xD;
}&#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function removeAllFees(itemCap) // Removes all non-invoiced fee items for a CAP ID&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByCapID(itemCap);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
&#xD;
				var editResult = aa.finance.removeFeeItem(itemCap, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + feeList[feeNum].getFeeCod());&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+feeList[feeNum].getFeeCod()+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
	}&#xD;
&#xD;
	function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.removeAppSpecificTableInfos(tableName,itemCap,currentUserID)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ aa.print(&quot;**WARNING: error removing ASI table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
        else&#xD;
	logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function replaceMessageTokens(m)&#xD;
	{&#xD;
	//  tokens in pipes will attempt to interpret as script variables&#xD;
	//  tokens in curly braces will attempt to replace from AInfo (ASI, etc)&#xD;
	//&#xD;
	//  e.g.   |capId|  or |wfTask|  or |wfStatus|&#xD;
	//&#xD;
	//  e.g.   {Expiration Date}  or  {Number of Electrical Outlets}&#xD;
	//&#xD;
	//  e.g.   m = &quot;Your recent license application (|capIdString|) has successfully passed |wfTask| with a status of |wfStatus|&quot;&#xD;
&#xD;
	while (m.indexOf(&quot;|&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;|&quot;)&#xD;
	  var e = m.indexOf(&quot;|&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;typeof(&quot; + r + &quot;) != \&quot;undefined\&quot; ? &quot; + r + &quot; : \&quot;undefined\&quot;&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\|&quot; + r + &quot;\\|&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
	  }&#xD;
&#xD;
	while (m.indexOf(&quot;{&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;{&quot;)&#xD;
	  var e = m.indexOf(&quot;}&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;AInfo[\&quot;&quot; + r + &quot;\&quot;]&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\{&quot; + r + &quot;\\}&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
&#xD;
	  }&#xD;
&#xD;
	 return m&#xD;
	 }&#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID.&#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm&#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3)&#xD;
		if (arguments[2] != null)&#xD;
			{&#xD;
			var inspRes = aa.person.getUser(arguments[2]);&#xD;
			if (inspRes.getSuccess())&#xD;
				inspectorObj = inspRes.getOutput();&#xD;
			}&#xD;
&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
&#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	capIDModel.setTrackingID(12345678);&#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
function stripNN(fullStr) {&#xD;
    var allowed = &quot;0123456789.&quot;;&#xD;
    var stripped = &quot;&quot;;&#xD;
    for (i = 0; i &lt; fullStr.length(); i++)&#xD;
        if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
        stripped += String.fromCharCode(fullStr.charAt(i))&#xD;
    return stripped;&#xD;
}&#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*&#xD;
DQ 09/03/2009 - Added Check to ensure Task status date is not null prior to getting status date&#xD;
Function will return false on fail&#xD;
*/&#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
	            if (fTask.getStatusDate() != null)&#xD;
	                return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
	            else&#xD;
	                { logMessage(&quot;**ERROR: NULL workflow task &quot;+fTask.getTaskDescription()+&quot; status date. &quot;); return false; }&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap, &quot;APPLICATION&quot;, stat, sysDate, cmt, systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
}&#xD;
&#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq)&#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
    // 12/22/2008 - DQ - Correct Invoice loop to accumulate instead of reset each iteration&#xD;
&#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)&#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
&#xD;
    var invFeeFound=false;&#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = adjustedQty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) )&#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
&#xD;
	return feeSeq;&#xD;
	}&#xD;
&#xD;
&#xD;
function updateRefParcelToCap() //Takes Optional CapId&#xD;
{&#xD;
	var vCapId = null;&#xD;
	if (arguments.length &gt; 0)&#xD;
		vCapId = arguments[0];&#xD;
	else&#xD;
		vCapId = capId;&#xD;
&#xD;
    var capPrclArr = aa.parcel.getParcelDailyByCapID(vCapId,null).getOutput();&#xD;
    if(capPrclArr != null)&#xD;
    {&#xD;
        for (x in capPrclArr)&#xD;
        {&#xD;
	        var prclObj = aa.parcel.getParceListForAdmin(capPrclArr[x].getParcelNumber(), null, null, null, null, null, null, null, null, null);&#xD;
	        if (prclObj.getSuccess() )&#xD;
	        {&#xD;
		        var prclArr = prclObj.getOutput();&#xD;
		        if (prclArr.length)&#xD;
		        {&#xD;
			        var prcl = prclArr[0].getParcelModel();&#xD;
			        var capPrclObj = aa.parcel.warpCapIdParcelModel2CapParcelModel(vCapId, prcl);&#xD;
&#xD;
			        if (capPrclObj.getSuccess())&#xD;
			        {&#xD;
&#xD;
				        var capPrcl = capPrclObj.getOutput();&#xD;
				        aa.parcel.updateDailyParcelWithAPOAttribute(capPrcl);	&#xD;
				        logDebug(&quot;Updated Parcel &quot; + capPrclArr[x].getParcelNumber() + &quot; with Reference Data&quot;);&#xD;
			        }&#xD;
			        else&#xD;
				        logDebug(&quot;Failed to Wrap Parcel Model for &quot; + capPrclArr[x].getParcelNumber());&#xD;
&#xD;
		        }&#xD;
		        else&#xD;
			        logDebug(&quot;No matching reference Parcels found for &quot; + capPrclArr[x].getParcelNumber());&#xD;
	        }&#xD;
	        else&#xD;
		        logDebug(&quot;Failed to get reference Parcel for &quot; + capPrclArr[x].getParcelNumber())&#xD;
	    }&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskDepartment(wfstr,wfDepartment) // optional process name&#xD;
	{&#xD;
	// Update the task assignment department&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
        var assignBureau = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[2];&#xD;
	var assignDivision = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[3];&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
        for (var i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
                if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
 			{&#xD;
			if (wfDepartment)&#xD;
				{&#xD;
				var taskUserObj = fTask.getTaskItem().getAssignedUser()&#xD;
				taskUserObj.setBureauCode(assignBureau);&#xD;
				taskUserObj.setDivisionCode(assignDivision);&#xD;
				fTask.setAssignedUser(taskUserObj);&#xD;
        			var taskItem = fTask.getTaskItem();&#xD;
&#xD;
				var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Department Set to &quot; + assignBureau);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update Department.  Invalid department : &quot; + assignBureau);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel()&#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
&#xD;
	}&#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><initializer></initializer><title>InvoiceFeeAfter</title></script><scriptName>InvoiceFeeAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>LicProfUpdateAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2011-01-06T08:54:53.580-07:00</auditDate><auditID>CPARKS</auditID><auditStatus>A</auditStatus></auditModel><event><name>LicProfUpdateAfter</name><auditModel><auditDate>2009-03-05T16:14:40-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after update a license professional.</description></event><script><name>LICPROFUPDATEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2011-01-06T08:52:20.893-07:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| Program : LicProfUpdateAfterV1.6.js&#xD;
| Event   : LicProfUpdateAFter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;			// Set to true to see results in popup window&#xD;
var showDebug = true;				// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;LicProfUpdateAfter&quot;; 		// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;&#xD;
var documentOnly = false;			// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;			// turn off tokenizing of App Specific and Parcel Attributes&#xD;
var useAppSpecificGroupName = false;		// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;		// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;				// Maximum number of std choice entries.  Must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId= aa.env.getValue(&quot;CapIdModel&quot;);&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup = null;&#xD;
if(appTypeArray[0].substr(0,1) !=&quot;_&quot;) //Model Home Check&#xD;
{&#xD;
	var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
	if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
}&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var licProfObject = aa.env.getValue(&quot;LicProfModel&quot;);&#xD;
logDebug(&quot;licProfObject = &quot; + licProfObject.getClass());&#xD;
&#xD;
var CAEAtts = aa.env.getValue(&quot;LicProfAttribute&quot;).toArray();&#xD;
for (ca in CAEAtts)&#xD;
	AInfo[&quot;CAEAttribute.&quot; + CAEAtts[ca].getAttributeName()] = CAEAtts[ca].getAttributeValue();&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + appId + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
  &#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
    	{&#xD;
  	//  tableName is the name of the ASI table&#xD;
  	//  tableValueArray is an array of associative array values.  All elements MUST be either a string or asiTableVal object&#xD;
    	var itemCap = capId&#xD;
  	if (arguments.length &gt; 2)&#xD;
  		itemCap = arguments[2]; // use cap ID specified in args&#xD;
  &#xD;
  	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
  &#xD;
  	if (!tssmResult.getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
  &#xD;
  	var tssm = tssmResult.getOutput();&#xD;
  	var tsm = tssm.getAppSpecificTableModel();&#xD;
  	var fld = tsm.getTableField();&#xD;
        var fld_readonly = tsm.getReadonlyField(); // get Readonly field&#xD;
  &#xD;
         	for (thisrow in tableValueArray)&#xD;
  		{&#xD;
  &#xD;
  		var col = tsm.getColumns()&#xD;
  		var coli = col.iterator();&#xD;
  &#xD;
  		while (coli.hasNext())&#xD;
  			{&#xD;
  			var colname = coli.next();&#xD;
  &#xD;
			if (typeof(tableValueArray[thisrow][colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
				{&#xD;
	  			fld.add(tableValueArray[thisrow][colname.getColumnName()].fieldValue);&#xD;
	  			fld_readonly.add(tableValueArray[thisrow][colname.getColumnName()].readOnly);&#xD;
				}&#xD;
			else // we are passed a string&#xD;
				{&#xD;
  				fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
  				fld_readonly.add(null);&#xD;
				}&#xD;
  			}&#xD;
  &#xD;
  		tsm.setTableField(fld);&#xD;
  &#xD;
  		tsm.setReadonlyField(fld_readonly);&#xD;
  &#xD;
  		}&#xD;
  &#xD;
  	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
  &#xD;
  	 if (!addResult .getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
  	else&#xD;
  		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
  &#xD;
  	}&#xD;
  &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
&#xD;
function addFeeWithExtraData(fcode, fsched, fperiod, fqty, finvoice, feeCap, feeComment, UDF1, UDF2) {&#xD;
    var feeCapMessage = &quot;&quot;;&#xD;
    var feeSeq_L = new Array(); 			// invoicing fee for CAP in args&#xD;
    var paymentPeriod_L = new Array(); 		// invoicing pay periods for CAP in args&#xD;
&#xD;
    assessFeeResult = aa.finance.createFeeItem(feeCap, fsched, fcode, fperiod, fqty);&#xD;
    if (assessFeeResult.getSuccess()) {&#xD;
        feeSeq = assessFeeResult.getOutput();&#xD;
        logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
        logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
        fsm = aa.finance.getFeeItemByPK(feeCap, feeSeq).getOutput().getF4FeeItem();&#xD;
&#xD;
        if (feeComment) fsm.setFeeNotes(feeComment);&#xD;
        if (UDF1) fsm.setUdf1(UDF1);&#xD;
        if (UDF2) fsm.setUdf2(UDF2);&#xD;
&#xD;
        aa.finance.editFeeItem(fsm)&#xD;
&#xD;
&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
        {&#xD;
            feeSeqList.push(feeSeq);&#xD;
            paymentPeriodList.push(fperiod);&#xD;
        }&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
        {&#xD;
            feeSeq_L.push(feeSeq);&#xD;
            paymentPeriod_L.push(fperiod);&#xD;
            var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
            if (invoiceResult_L.getSuccess())&#xD;
                logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
            else&#xD;
                logDebug(&quot;**ERROR: Invoicing the fee items assessed was not successful.  Reason: &quot; + invoiceResult.getErrorMessage());&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
        return null;&#xD;
    }&#xD;
&#xD;
    return feeSeq;&#xD;
&#xD;
}&#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
function addParcelAndOwnerFromRefAddress(refAddress)  // optional capID&#xD;
	{&#xD;
&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	// first add the primary parcel&#xD;
	//&#xD;
	var primaryParcelResult = aa.parcel.getPrimaryParcelByRefAddressID(refAddress,&quot;Y&quot;);&#xD;
	if (primaryParcelResult.getSuccess())&#xD;
		var primaryParcel = primaryParcelResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get primary parcel for ref Address &quot; + refAddress + &quot; , &quot; + primaryParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var capParModel = aa.parcel.warpCapIdParcelModel2CapParcelModel(capId,primaryParcel).getOutput()&#xD;
&#xD;
	var createPMResult = aa.parcel.createCapParcel(capParModel);&#xD;
	if (createPMResult.getSuccess())&#xD;
		logDebug(&quot;created CAP Parcel&quot;);&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Failed to create the cap Parcel &quot; + createPMResult.getErrorMessage()); }&#xD;
&#xD;
&#xD;
	// Now the owners&#xD;
	//&#xD;
&#xD;
	var parcelListResult = aa.parcel.getParcelDailyByCapID(capId,null);&#xD;
	if (parcelListResult.getSuccess())&#xD;
		var parcelList = parcelListResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel List &quot; + parcelListResult.getErrorMessage()); return false; }&#xD;
&#xD;
&#xD;
	for (var thisP in parcelList)&#xD;
  		{&#xD;
  		var ownerListResult = aa.owner.getOwnersByParcel(parcelList[thisP]);&#xD;
		if (ownerListResult.getSuccess())&#xD;
			var ownerList = ownerListResult.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Failed to get Owner List &quot; + ownerListResult.getErrorMessage()); return false; }&#xD;
&#xD;
  		for (var thisO in ownerList)&#xD;
      			{&#xD;
      			ownerList[thisO].setCapID(capId);&#xD;
      			createOResult = aa.owner.createCapOwnerWithAPOAttribute(ownerList[thisO]);&#xD;
&#xD;
			if (createOResult.getSuccess())&#xD;
				logDebug(&quot;Created CAP Owner&quot;);&#xD;
			else&#xD;
				{ logDebug(&quot;**WARNING: Failed to create CAP Owner &quot; + createOResult.getErrorMessage()); }&#xD;
			}&#xD;
	      	}&#xD;
     }&#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
&#xD;
function addReferenceContactByName(vFirst, vMiddle, vLast)&#xD;
{&#xD;
	var userFirst = vFirst;&#xD;
	var userMiddle = vMiddle;&#xD;
	var userLast = vLast;&#xD;
&#xD;
	//Find PeopleModel object for user&#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
	//Add the reference contact record to the current CAP&#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
}&#xD;
function addressExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
	var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
	if (capAddResult.getSuccess())&#xD;
		var fcapAddressObj = capAddResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddResult.getErrorType() + &quot;:&quot; + capAddResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapAddressObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
			if (addCapCondResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements must be either a string or asiTableVal object&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	var col = tsm.getColumns();&#xD;
	var fld_readonly = tsm.getReadonlyField(); //get ReadOnly property&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
&#xD;
		if (typeof(tableValues[colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()].fieldValue);&#xD;
			fld_readonly.add(tableValues[colname.getColumnName()].readOnly);&#xD;
			}&#xD;
		else // we are passed a string&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()]);&#xD;
			fld_readonly.add(null);&#xD;
			}&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	tsm.setReadonlyField(fld_readonly); // set readonly field&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
&#xD;
function asiTableValObj(columnName, fieldValue, readOnly) {&#xD;
	this.columnName = columnName;&#xD;
	this.fieldValue = fieldValue;&#xD;
	this.readOnly = readOnly;&#xD;
&#xD;
	asiTableValObj.prototype.toString=function(){ return this.fieldValue }&#xD;
};&#xD;
&#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	}function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	}function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	}function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	}function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	function checkCapForLicensedProfessionalType( licProfType )&#xD;
{&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
&#xD;
	if( capLicenseResult.getSuccess() )&#xD;
	{ &#xD;
		var capLicenseArr = capLicenseResult.getOutput();&#xD;
		&#xD;
		if (!capLicenseArr)&#xD;
			{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
		&#xD;
		for( licProf in capLicenseArr )&#xD;
		{&#xD;
			if( licProfType.equals(capLicenseArr[licProf].getLicenseType()) )&#xD;
			{&#xD;
				aa.print( &quot;Found License Professional with Type= &quot; + licProfType );&#xD;
				return true; //Found Licensed Prof of specified type&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		return false;&#xD;
	}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
}function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
function closeSubWorkflow(thisProcessID,wfStat) // optional capId&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var isCompleted = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTaskSM = wfObj[i];&#xD;
		if (fTaskSM.getProcessID() == thisProcessID &amp;&amp; fTaskSM.getCompleteFlag() != &quot;Y&quot;)&#xD;
			{&#xD;
			logDebug(&quot;closeSubWorkflow: found an incomplete task processID #&quot; + thisProcessID + &quot; , Step# &quot; + fTaskSM.getStepNumber(),3);&#xD;
			isCompleted = false&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (!isCompleted) return false;&#xD;
&#xD;
&#xD;
	// get the parent task&#xD;
&#xD;
	var relationArray = aa.workflow.getProcessRelationByCapID(itemCap,null).getOutput()&#xD;
&#xD;
	var relRecord = null;&#xD;
&#xD;
	for (thisRel in relationArray)&#xD;
		if (relationArray[thisRel].getProcessID() == thisProcessID)&#xD;
			relRecord = relationArray[thisRel];&#xD;
&#xD;
	if (!relRecord)&#xD;
		{&#xD;
		logDebug(&quot;closeSubWorkflow: did not find a process relation, exiting&quot;,3);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	logDebug(&quot;executing handleDisposition:&quot; + relRecord.getStepNumber() + &quot;,&quot; + relRecord.getParentProcessID() + &quot;,&quot; + wfStat,3);&#xD;
&#xD;
	var handleResult = aa.workflow.handleDisposition(itemCap,relRecord.getStepNumber(),relRecord.getParentProcessID(),wfStat,sysDate,&quot;Closed via script&quot;,&quot;Closed via script&quot;,systemUserObj ,&quot;Y&quot;);&#xD;
&#xD;
	if (!handleResult.getSuccess())&#xD;
		logDebug(&quot;**WARNING: closing parent task: &quot; + handleResult.getErrorMessage());&#xD;
	else&#xD;
		logDebug(&quot;Closed parent task&quot;);&#xD;
	}&#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
function comparePeopleGeneric(peop)&#xD;
	{&#xD;
&#xD;
	// this function will be passed as a parameter to the createRefContactsFromCapContactsAndLink function.&#xD;
	//&#xD;
	// takes a single peopleModel as a parameter, and will return the sequence number of the first G6Contact result&#xD;
	//&#xD;
	// returns null if there are no matches&#xD;
	//&#xD;
	// current search method is by email only.  In order to use attributes enhancement 09ACC-05048 must be implemented&#xD;
	//&#xD;
&#xD;
	peop.setAuditDate(null)&#xD;
	peop.setAuditID(null)&#xD;
	peop.setAuditStatus(null)&#xD;
	peop.setBirthDate(null)&#xD;
	peop.setBusName2(null)&#xD;
	peop.setBusinessName(null)&#xD;
	peop.setComment(null)&#xD;
	peop.setCompactAddress(null)&#xD;
	peop.setContactSeqNumber(null)&#xD;
	peop.setContactType(null)&#xD;
	peop.setContactTypeFlag(null)&#xD;
	peop.setCountry(null)&#xD;
	peop.setCountryCode(null)&#xD;
	// peop.setEmail(null)       just as a test we are using email&#xD;
	peop.setEndBirthDate(null)&#xD;
	peop.setFax(null)&#xD;
	peop.setFaxCountryCode(null)&#xD;
	peop.setFein(null)&#xD;
	peop.setFirstName(null)&#xD;
	peop.setFlag(null)&#xD;
	peop.setFullName(null)&#xD;
	peop.setGender(null)&#xD;
	peop.setHoldCode(null)&#xD;
	peop.setHoldDescription(null)&#xD;
	peop.setId(null)&#xD;
	peop.setIvrPinNumber(null)&#xD;
	peop.setIvrUserNumber(null)&#xD;
	peop.setLastName(null)&#xD;
	peop.setMaskedSsn(null)&#xD;
	peop.setMiddleName(null)&#xD;
	peop.setNamesuffix(null)&#xD;
	peop.setPhone1(null)&#xD;
	peop.setPhone1CountryCode(null)&#xD;
	peop.setPhone2(null)&#xD;
	peop.setPhone2CountryCode(null)&#xD;
	peop.setPhone3(null)&#xD;
	peop.setPhone3CountryCode(null)&#xD;
	peop.setPostOfficeBox(null)&#xD;
	peop.setPreferredChannel(null)&#xD;
	peop.setPreferredChannelString(null)&#xD;
	peop.setRate1(null)&#xD;
	peop.setRelation(null)&#xD;
	peop.setSalutation(null)&#xD;
	peop.setServiceProviderCode(null)&#xD;
	peop.setSocialSecurityNumber(null)&#xD;
	peop.setTitle(null)&#xD;
	peop.setTradeName(null)&#xD;
&#xD;
	var r = aa.people.getPeopleByPeopleModel(peop);&#xD;
&#xD;
    if (!r.getSuccess())&#xD;
			{ logDebug(&quot;WARNING: error searching for people : &quot; + r.getErrorMessage()); return false; }&#xD;
&#xD;
	var peopResult = r.getOutput();&#xD;
&#xD;
	if (peopResult.length == 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for REF contact, no matches found, returing null&quot;);&#xD;
		return null;&#xD;
		}&#xD;
&#xD;
	if (peopResult.length &gt; 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for a REF Contact, &quot; + peopResult.length + &quot; matches found! returning the first match : &quot; + peopResult[0].getContactSeqNumber() );&#xD;
		return peopResult[0].getContactSeqNumber()&#xD;
		}&#xD;
&#xD;
}function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
}function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	}&#xD;
	&#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
function convertStringToPhone(theString)&#xD;
	{&#xD;
	var n = &quot;22233344455566677778889999&quot;;&#xD;
&#xD;
	var compString = String(theString.toUpperCase());&#xD;
	var retString = &quot;&quot;;&#xD;
&#xD;
	for (var x=0 ; x&lt; compString.length ; x++)&#xD;
   		{&#xD;
   		if (compString[x] &gt;= &quot;A&quot; &amp;&amp; compString[x] &lt;= &quot;Z&quot;)&#xD;
   			retString += n[compString.charCodeAt(x)-65]&#xD;
  		 else&#xD;
   			retString += compString[x];&#xD;
  		}&#xD;
   	return retString;&#xD;
 	}&#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
&#xD;
	//check if target CAP has primary address&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//get addresses from originating CAP&#xD;
	var capAddressResult = aa.address.getAddressWithAttributeByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddressWithAPOAttribute(vToCapId, newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	return copied;&#xD;
	}&#xD;
&#xD;
&#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional groups to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
&#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
&#xD;
function copyLicensedProf(sCapId, tCapId)&#xD;
{&#xD;
	//Function will copy all licensed professionals from source CapID to target CapID&#xD;
&#xD;
	var licProf = aa.licenseProfessional.getLicensedProfessionalsByCapID(sCapId).getOutput();&#xD;
	if (licProf != null)&#xD;
		for(x in licProf)&#xD;
		{&#xD;
			licProf[x].setCapID(tCapId);&#xD;
			aa.licenseProfessional.createLicensedProfessional(licProf[x]);&#xD;
			logDebug(&quot;Copied &quot; + licProf[x].getLicenseNbr());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;No licensed professional on source&quot;);&#xD;
}&#xD;
&#xD;
//Function will copy all owners from source CAP (sCapID) to target CAP (tCapId)&#xD;
function copyOwner(sCapID, tCapID)&#xD;
{&#xD;
	var ownrReq = aa.owner.getOwnerByCapId(sCapID);&#xD;
	if(ownrReq.getSuccess())&#xD;
	{&#xD;
		var ownrObj = ownrReq.getOutput();&#xD;
		for (xx in ownrObj)&#xD;
		{&#xD;
			ownrObj[xx].setCapID(tCapID);&#xD;
			aa.owner.createCapOwnerWithAPOAttribute(ownrObj[xx]);&#xD;
			logDebug(&quot;Copied Owner: &quot; + ownrObj[xx].getOwnerFullName())&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
		logDebug(&quot;Error Copying Owner : &quot; + ownrObj.getErrorType() + &quot; : &quot; + ownrObj.getErrorMessage());&#xD;
}&#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
&#xD;
function createCapComment(vComment)  //optional CapId&#xD;
{&#xD;
	var vCapId = capId;&#xD;
	if (arguments.length == 2)&#xD;
		vCapId = arguments[1];&#xD;
	var comDate = aa.date.getCurrentDate(); &#xD;
	var capCommentScriptModel= aa.cap.createCapCommentScriptModel(); &#xD;
	capCommentScriptModel.setCapIDModel(vCapId); &#xD;
	capCommentScriptModel.setCommentType(&quot;APP LEVEL COMMENT&quot;); &#xD;
	capCommentScriptModel.setSynopsis(&quot;&quot;); &#xD;
	capCommentScriptModel.setText(vComment); &#xD;
	capCommentScriptModel.setAuditUser(currentUserID); &#xD;
	capCommentScriptModel.setAuditStatus(&quot;A&quot;); &#xD;
	capCommentScriptModel.setAuditDate(comDate); &#xD;
	var capCommentModel=capCommentScriptModel.getCapCommentModel(); &#xD;
	aa.cap.createCapComment(capCommentModel); &#xD;
	logDebug(&quot;Comment Added&quot;);&#xD;
}function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createPublicUserFromContact()   // optional: Contact Type, default Applicant&#xD;
{&#xD;
    var contactType = &quot;Applicant&quot;;&#xD;
    var contact;&#xD;
    if (arguments.length &gt; 0) contactType = arguments[0]; // use contact type specified&#xD;
&#xD;
    var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
    if (capContactResult.getSuccess()) {&#xD;
        var Contacts = capContactResult.getOutput();&#xD;
        for (yy in Contacts) {&#xD;
            aa.print(Contacts[yy].getCapContactModel().getPeople().getContactType())&#xD;
            if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
                contact = Contacts[yy];&#xD;
        }&#xD;
    }&#xD;
&#xD;
    aa.print(contact.getEmail());&#xD;
    if (!contact)&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no such contact&quot;); return false; }&#xD;
&#xD;
    if (!contact.getEmail())&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no email address&quot;); return false; }&#xD;
&#xD;
    // check if exists already&#xD;
&#xD;
    var getUserResult = aa.publicUser.getPublicUserByEmail(contact.getEmail())&#xD;
    if (getUserResult.getSuccess()) {&#xD;
        var userModel = getUserResult.getOutput()&#xD;
        aa.print(&quot;found the user already&quot;);&#xD;
        if (userModel) return userModel;  // send back the existing user&#xD;
    }&#xD;
&#xD;
    // create a new one&#xD;
&#xD;
    var publicUser = aa.publicUser.getPublicUserModel();&#xD;
    publicUser.setFirstName(contact.getFirstName());&#xD;
    publicUser.setLastName(contact.getLastName());&#xD;
    publicUser.setEmail(contact.getEmail());&#xD;
    publicUser.setUserID(contact.getEmail());&#xD;
    publicUser.setPassword(&quot;7d3fe8b8d7ba80addfc296b07de60cc101e4af60&quot;); //password : Gary0813&#xD;
    publicUser.setAuditID(&quot;PublicUser&quot;);&#xD;
    publicUser.setAuditStatus(&quot;A&quot;);&#xD;
    publicUser.setCellPhone(contact.getCapContactModel().getPeople().getPhone2());&#xD;
&#xD;
    var result = aa.publicUser.createPublicUser(publicUser);&#xD;
&#xD;
    if (result.getSuccess()) {&#xD;
        logDebug(&quot;Created public user &quot; + contact.getEmail() + &quot;  sucessfully.&quot;);&#xD;
        var userSeqNum = result.getOutput();&#xD;
        var userModel = aa.publicUser.getPublicUser(userSeqNum).getOutput()&#xD;
&#xD;
        // create for agency&#xD;
        aa.publicUser.createPublicUserForAgency(userModel);&#xD;
&#xD;
        // activate for agency&#xD;
        var userPinBiz = aa.proxyInvoker.newInstance(&quot;com.accela.pa.pin.UserPINBusiness&quot;).getOutput()&#xD;
		userPinBiz.updateActiveStatusAndLicenseIssueDate4PublicUser(servProvCode,userSeqNum,&quot;ADMIN&quot;);&#xD;
		// reset password&#xD;
&#xD;
		var PUB = aa.proxyInvoker.newInstance(&quot;com.accela.v360.publicuser.PublicUserBusiness&quot;).getOutput()&#xD;
		PUB.resetPassword(contact.getEmail());&#xD;
&#xD;
        // send Activate email&#xD;
        aa.publicUser.sendActivateEmail(userModel, true, true);&#xD;
&#xD;
        // send another email&#xD;
        aa.publicUser.sendPasswordEmail(userModel);&#xD;
        return userModel;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**Warning creating public user &quot; + contact.getEmail() + &quot;  failure: &quot; + result.getErrorMessage()); return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
function createRefContactsFromCapContactsAndLink(pCapId, contactTypeArray, ignoreAttributeArray, replaceCapContact, overwriteRefContact, refContactExists)&#xD;
	{&#xD;
&#xD;
	// contactTypeArray is either null (all), or an array or contact types to process&#xD;
	//&#xD;
	// ignoreAttributeArray is either null (none), or an array of attributes to ignore when creating a REF contact&#xD;
	//&#xD;
	// replaceCapContact not implemented yet&#xD;
	//&#xD;
	// overwriteRefContact -- if true, will refresh linked ref contact with CAP contact data&#xD;
	//&#xD;
	// refContactExists is a function for REF contact comparisons.&#xD;
	//&#xD;
	var ingoreArray = new Array();&#xD;
	if (arguments.length &gt; 1) ignoreArray = arguments[1];&#xD;
&#xD;
	var c = aa.people.getCapContactByCapID(pCapId).getOutput()&#xD;
	var cCopy = aa.people.getCapContactByCapID(pCapId).getOutput()  // must have two working datasets&#xD;
&#xD;
	for (var i in c)&#xD;
	   {&#xD;
	   var con = c[i];&#xD;
&#xD;
	   var p = con.getPeople();&#xD;
	   &#xD;
	   if (contactTypeArray &amp;&amp; !exists(p.getContactType(),contactTypeArray))&#xD;
		continue;  // not in the contact type list.  Move along.&#xD;
&#xD;
	   &#xD;
	   var refContactNum = con.getCapContactModel().getRefContactNumber();&#xD;
	   if (refContactNum)  // This is a reference contact.   Let's refresh or overwrite as requested in parms.&#xD;
	   	{&#xD;
	   	if (overwriteRefContact)&#xD;
	   		{&#xD;
	   		p.setContactSeqNumber(refContactNum);  // set the ref seq# to refresh&#xD;
	   		&#xD;
	   		&#xD;
	   						var a = p.getAttributes();&#xD;
			&#xD;
							if (a)&#xD;
								{&#xD;
								var ai = a.iterator();&#xD;
								while (ai.hasNext())&#xD;
									{&#xD;
									var xx = ai.next();&#xD;
									xx.setContactNo(refContactNum);&#xD;
									}&#xD;
					}&#xD;
					&#xD;
					&#xD;
					&#xD;
	   		var r = aa.people.editPeopleWithAttribute(p,p.getAttributes());&#xD;
	   		&#xD;
			if (!r.getSuccess()) &#xD;
				logDebug(&quot;WARNING: couldn't refresh reference people : &quot; + r.getErrorMessage()); &#xD;
			else&#xD;
				logDebug(&quot;Successfully refreshed ref contact #&quot; + refContactNum + &quot; with CAP contact data&quot;); &#xD;
			}&#xD;
			&#xD;
	   	if (replaceCapContact)&#xD;
	   		{&#xD;
				// To Be Implemented later.   Is there a use case?&#xD;
			}&#xD;
			&#xD;
	   	}&#xD;
	   	else  // user entered the contact freehand.   Let's create or link to ref contact.&#xD;
	   	{&#xD;
			var ccmSeq = p.getContactSeqNumber();&#xD;
&#xD;
			var existingContact = refContactExists(p);  // Call the custom function to see if the REF contact exists&#xD;
&#xD;
			var p = cCopy[i].getPeople();  // get a fresh version, had to mangle the first for the search&#xD;
&#xD;
			if (existingContact)  // we found a match with our custom function.  Use this one.&#xD;
				{&#xD;
					refPeopleId = existingContact;&#xD;
				}&#xD;
			else  // did not find a match, let's create one&#xD;
				{&#xD;
&#xD;
				var a = p.getAttributes();&#xD;
&#xD;
				if (a)&#xD;
					{&#xD;
					//&#xD;
					// Clear unwanted attributes&#xD;
					var ai = a.iterator();&#xD;
					while (ai.hasNext())&#xD;
						{&#xD;
						var xx = ai.next();&#xD;
						if (ignoreAttributeArray &amp;&amp; exists(xx.getAttributeName().toUpperCase(),ignoreAttributeArray))&#xD;
							ai.remove();&#xD;
						}&#xD;
					}&#xD;
&#xD;
				var r = aa.people.createPeopleWithAttribute(p,a);&#xD;
&#xD;
				if (!r.getSuccess())&#xD;
					{logDebug(&quot;WARNING: couldn't create reference people : &quot; + r.getErrorMessage()); continue; }&#xD;
&#xD;
				//&#xD;
				// createPeople is nice and updates the sequence number to the ref seq&#xD;
				//&#xD;
&#xD;
				var p = cCopy[i].getPeople();&#xD;
				var refPeopleId = p.getContactSeqNumber();&#xD;
&#xD;
				logDebug(&quot;Successfully created reference contact #&quot; + refPeopleId);&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// now that we have the reference Id, we can link back to reference&#xD;
			//&#xD;
&#xD;
		    var ccm = aa.people.getCapContactByPK(pCapId,ccmSeq).getOutput().getCapContactModel();&#xD;
&#xD;
		    ccm.setRefContactNumber(refPeopleId);&#xD;
		    r = aa.people.editCapContact(ccm);&#xD;
&#xD;
		    if (!r.getSuccess())&#xD;
				{ logDebug(&quot;WARNING: error updating cap contact model : &quot; + r.getErrorMessage()); }&#xD;
			else&#xD;
				{ logDebug(&quot;Successfully linked ref contact &quot; + refPeopleId + &quot; to cap contact &quot; + ccmSeq);}&#xD;
&#xD;
&#xD;
	    }  // end if user hand entered contact &#xD;
	}  // end for each CAP contact&#xD;
} // end function&#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
function deactivateTask(wfstr) // optional process name&#xD;
{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
	{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
	}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
	{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
		{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
		}			&#xD;
	}&#xD;
}&#xD;
&#xD;
function deleteTask(targetCapId,deleteTaskName)&#xD;
{&#xD;
	//&#xD;
	// Get the target Task&#xD;
	//&#xD;
	var workflowResult = aa.workflow.getTasks(targetCapId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var tTask = null;&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(deleteTaskName.toUpperCase()))&#xD;
  			{&#xD;
			var tTask = wfObj[i];&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	if (!tTask)&#xD;
  	  	{ logDebug(&quot;**WARNING: Task not found: &quot; + deleteTaskName); return false; }&#xD;
&#xD;
&#xD;
	logDebug(&quot;Removing task &quot; + tTask.getTaskDescription());&#xD;
	var result = aa.workflow.removeTask(tTask)&#xD;
&#xD;
	if (!result.getSuccess())&#xD;
		{ logDebug(&quot;error &quot; + result.getErrorMessage()); return false; }&#xD;
&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	&#xD;
	itemCap = capId;&#xD;
	&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
   	&#xD;
   	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
			{&#xD;
				if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
				{&#xD;
					appspecObj[i].setChecklistComment(itemValue);&#xD;
						&#xD;
					var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
					if (actionResult.getSuccess()) &#xD;
					{							&#xD;
						logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
					} &#xD;
					else &#xD;
					{&#xD;
						logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
					}&#xD;
						&#xD;
					updated = true;&#xD;
					AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
				}&#xD;
				&#xD;
				i++;&#xD;
				&#xD;
			} // while loop&#xD;
		} // item name blank&#xD;
	} // got app specific object	&#xD;
	else&#xD;
	{ &#xD;
		logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage());&#xD;
	}&#xD;
}//End Function&#xD;
&#xD;
function editBuildingCount(numBuild) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setBuildingCount(parseFloat(numBuild));&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated building count to &quot; + numBuild); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
}function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editInspectionRequiredFlag(inspType,reqFlag)&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var result = aa.inspection.getInspMilestoneByCapID(itemCap);&#xD;
&#xD;
	if(!result.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection milestones: &quot;  + result.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspMilestones= result.getOutput();&#xD;
&#xD;
	if (!inspMilestones)&#xD;
		{ logDebug(&quot;No Inspection Milestones found&quot;) ; return false ; }&#xD;
&#xD;
	for (thisM in inspMilestones)&#xD;
		{&#xD;
		var obj= inspMilestones[thisM];&#xD;
		if (inspType.equals(obj.getInspType()))&#xD;
			{&#xD;
			if (reqFlag) obj.setInspRequired(&quot;Y&quot;);&#xD;
			else obj.setInspRequired(&quot;N&quot;);&#xD;
&#xD;
			result = aa.inspection.updateInspectionMilestone(inspMilestones);&#xD;
			if(result.getSuccess())&#xD;
				logDebug(&quot;inspection milestone updated sucessfully.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: could not update inpsection milestone &quot; +result.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	}function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editScheduledDate(scheduledDate) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	vScheduledDate = aa.date.parseDate(scheduledDate);&#xD;
	&#xD;
	//cd.setScheduledDate(vScheduledDate); //bug, doesn't work&#xD;
	cdScriptObj.setScheduledDate(vScheduledDate);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated scheduled date to &quot; + scheduledDate) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR updating scheduled date: &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = &quot;&quot; + Contacts[yy].getEmail();&#xD;
		}&#xD;
&#xD;
	if (emailAddress.indexOf(&quot;@&quot;) &gt; 0)&#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no valid email address&quot;);&#xD;
	}function endBranch() {&#xD;
	// stop execution of the current std choice&#xD;
	stopBranch = false;&#xD;
	}function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
&#xD;
function externalLP_CA(licNum,rlpType,doPopulateRef,doPopulateTrx,itemCap)&#xD;
	{&#xD;
&#xD;
	/*&#xD;
	Version: 3.2&#xD;
&#xD;
	Usage:&#xD;
&#xD;
		licNum			:  Valid CA license number.   Non-alpha, max 8 characters.  If null, function will use the LPs on the supplied CAP ID&#xD;
		rlpType			:  License professional type to use when validating and creating new LPs&#xD;
		doPopulateRef 	:  If true, will create/refresh a reference LP of this number/type&#xD;
		doPopulateTrx 	:  If true, will copy create/refreshed reference LPs to the supplied Cap ID.   doPopulateRef must be true for this to work&#xD;
		itemCap			:  If supplied, licenses on the CAP will be validated.  Also will be refreshed if doPopulateRef and doPopulateTrx are true&#xD;
&#xD;
	returns: non-null string of status codes for invalid licenses&#xD;
&#xD;
	examples:&#xD;
&#xD;
	appsubmitbefore   (will validate the LP entered, if any, and cancel the event if the LP is inactive, cancelled, expired, etc.)&#xD;
	===============&#xD;
	true ^ cslbMessage = &quot;&quot;;&#xD;
	CAELienseNumber ^ cslbMessage = externalLP_CA(CAELienseNumber,false,false,CAELienseType,null);&#xD;
	cslbMessage.length &gt; 0 ^ cancel = true ; showMessage = true ; comment(cslbMessage)&#xD;
&#xD;
	appsubmitafter  (update all CONTRACTOR LPs on the CAP and REFERENCE with data from CSLB.  Link the CAP LPs to REFERENCE.   Pop up a message if any are inactive...)&#xD;
	==============&#xD;
	true ^ 	cslbMessage = externalLP_CA(null,true,true,&quot;CONTRACTOR&quot;,capId)&#xD;
	cslbMessage.length &gt; 0 ^ showMessage = true ; comment(cslbMessage);&#xD;
&#xD;
	Note;  Custom LP Template Field Mappings can be edited in the script below&#xD;
	*/&#xD;
&#xD;
	var returnMessage = &quot;&quot;;&#xD;
&#xD;
	var workArray = new Array();&#xD;
	if (licNum)&#xD;
		workArray.push(String(licNum));&#xD;
&#xD;
	if (itemCap)&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(itemCap);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{&#xD;
			var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
		if (capLicenseArr == null || !capLicenseArr.length)&#xD;
			{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); }&#xD;
		else&#xD;
			{&#xD;
			for (var thisLic in capLicenseArr)&#xD;
				if (capLicenseArr[thisLic].getLicenseType() == rlpType)&#xD;
					workArray.push(capLicenseArr[thisLic]);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		doPopulateTrx = false; // can't do this without a CAP;&#xD;
&#xD;
	for (var thisLic = 0; thisLic &lt; workArray.length; thisLic++)&#xD;
		{&#xD;
		var licNum = workArray[thisLic];&#xD;
		var licObj = null;&#xD;
		var isObject = false;&#xD;
&#xD;
		if (typeof(licNum) == &quot;object&quot;)  // is this one an object or string?&#xD;
			{&#xD;
			licObj = licNum;&#xD;
			licNum = licObj.getLicenseNbr();&#xD;
			isObject = true;&#xD;
			}&#xD;
&#xD;
		// Make the call to the California State License Board&#xD;
&#xD;
        var saxBuilder = aa.proxyInvoker.newInstance(&quot;org.jdom.input.SAXBuilder&quot;).getOutput();&#xD;
        var aURLArgList = new Array()&#xD;
        aURLArgList[0] = &quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum;&#xD;
        var oURL = aa.proxyInvoker.newInstance(&quot;java.net.URL&quot;,aURLArgList).getOutput();&#xD;
        var document = saxBuilder.build(oURL); //(&quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum);&#xD;
        var root = document.getRootElement();&#xD;
&#xD;
		var errorNode = root.getChild(&quot;Error&quot;);&#xD;
		if (errorNode)&#xD;
			{&#xD;
			logDebug(&quot;Error for license &quot; + licNum + &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;));&#xD;
			returnMessage+=&quot;License &quot; + licNum +  &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;) + &quot; &quot;;&#xD;
			continue;&#xD;
			}&#xD;
&#xD;
		var lpBiz = root.getChild(&quot;BusinessInfo&quot;);&#xD;
		var lpStatus = root.getChild(&quot;PrimaryStatus&quot;);&#xD;
		var lpClass = root.getChild(&quot;Classifications&quot;);&#xD;
		var lpBonds = root.getChild(&quot;ContractorBond&quot;);&#xD;
		var lpWC = root.getChild(&quot;WorkersComp&quot;);&#xD;
&#xD;
		// Primary Status&#xD;
		// 3 = expired, 10 = good, 11 = inactive, 1 = canceled.   We will ignore all but 10 and return text.&#xD;
		var stas = lpStatus.getChildren();&#xD;
		for (var i=0 ; i&lt;stas.size(); i++) {&#xD;
			var sta = stas.get(i);&#xD;
&#xD;
			if (sta.getAttribute(&quot;Code&quot;).getValue() != &quot;10&quot;)&#xD;
				returnMessage+=&quot;License:&quot; + licNum + &quot;, &quot; + sta.getAttribute(&quot;Desc&quot;).getValue() + &quot; &quot;;&#xD;
		}&#xD;
&#xD;
		if (doPopulateRef)  // refresh or create a reference LP&#xD;
			{&#xD;
			var updating = false;&#xD;
&#xD;
			// check to see if the licnese already exists...if not, create.&#xD;
&#xD;
			var newLic = getRefLicenseProf(licNum)&#xD;
&#xD;
			if (newLic)&#xD;
				{&#xD;
				updating = true;&#xD;
				logDebug(&quot;Updating existing Ref Lic Prof : &quot; + licNum);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
				}&#xD;
&#xD;
			if (isObject)  // update the reference LP with data from the transactional, if we have some.&#xD;
				{&#xD;
				if (licObj.getAddress1()) newLic.setAddress1(licObj.getAddress1());&#xD;
				if (licObj.getAddress2()) newLic.setAddress2(licObj.getAddress2());&#xD;
				if (licObj.getAddress3()) newLic.setAddress3(licObj.getAddress3());&#xD;
				if (licObj.getAgencyCode()) newLic.setAgencyCode(licObj.getAgencyCode());&#xD;
				if (licObj.getBusinessLicense()) newLic.setBusinessLicense(licObj.getBusinessLicense());&#xD;
				if (licObj.getBusinessName()) newLic.setBusinessName(licObj.getBusinessName());&#xD;
				if (licObj.getBusName2()) newLic.setBusinessName2(licObj.getBusName2());&#xD;
				if (licObj.getCity()) newLic.setCity(licObj.getCity());&#xD;
				if (licObj.getCityCode()) newLic.setCityCode(licObj.getCityCode());&#xD;
				if (licObj.getContactFirstName()) newLic.setContactFirstName(licObj.getContactFirstName());&#xD;
				if (licObj.getContactLastName()) newLic.setContactLastName(licObj.getContactLastName());&#xD;
				if (licObj.getContactMiddleName()) newLic.setContactMiddleName(licObj.getContactMiddleName());&#xD;
				if (licObj.getCountryCode()) newLic.setContryCode(licObj.getCountryCode());&#xD;
				if (licObj.getEmail()) newLic.setEMailAddress(licObj.getEmail());&#xD;
				if (licObj.getCountry()) newLic.setCountry(licObj.getCountry());&#xD;
				if (licObj.getEinSs()) newLic.setEinSs(licObj.getEinSs());&#xD;
				if (licObj.getFax()) newLic.setFax(licObj.getFax());&#xD;
				if (licObj.getFaxCountryCode()) newLic.setFaxCountryCode(licObj.getFaxCountryCode());&#xD;
				if (licObj.getHoldCode()) newLic.setHoldCode(licObj.getHoldCode());&#xD;
				if (licObj.getHoldDesc()) newLic.setHoldDesc(licObj.getHoldDesc());&#xD;
				if (licObj.getLicenseExpirDate()) newLic.setLicenseExpirationDate(licObj.getLicenseExpirDate());&#xD;
				if (licObj.getLastRenewalDate()) newLic.setLicenseLastRenewalDate(licObj.getLastRenewalDate());&#xD;
				if (licObj.getLicesnseOrigIssueDate()) newLic.setLicOrigIssDate(licObj.getLicesnseOrigIssueDate());&#xD;
				if (licObj.getPhone1()) newLic.setPhone1(licObj.getPhone1());&#xD;
				if (licObj.getPhone1CountryCode()) newLic.setPhone1CountryCode(licObj.getPhone1CountryCode());&#xD;
				if (licObj.getPhone2()) newLic.setPhone2(licObj.getPhone2());&#xD;
				if (licObj.getPhone2CountryCode()) newLic.setPhone2CountryCode(licObj.getPhone2CountryCode());&#xD;
				if (licObj.getSelfIns()) newLic.setSelfIns(licObj.getSelfIns());&#xD;
				if (licObj.getState()) newLic.setState(licObj.getState());&#xD;
				if (licObj.getSuffixName()) newLic.setSuffixName(licObj.getSuffixName());&#xD;
				if (licObj.getZip()) newLic.setZip(licObj.getZip());&#xD;
				}&#xD;
&#xD;
			// Now set data from the CSLB&#xD;
&#xD;
			if (lpBiz.getChild(&quot;Name&quot;).getText() != &quot;&quot;) newLic.setBusinessName(unescape(lpBiz.getChild(&quot;Name&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr1&quot;).getText() != &quot;&quot;) newLic.setAddress1(unescape(lpBiz.getChild(&quot;Addr1&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr2&quot;).getText() != &quot;&quot;) newLic.setAddress2(unescape(lpBiz.getChild(&quot;Addr2&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;City&quot;).getText() != &quot;&quot;) newLic.setCity(unescape(lpBiz.getChild(&quot;City&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;State&quot;).getText() != &quot;&quot;) newLic.setState(unescape(lpBiz.getChild(&quot;State&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Zip&quot;).getText() != &quot;&quot;) newLic.setZip(unescape(lpBiz.getChild(&quot;Zip&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText() != &quot;&quot;) newLic.setPhone1(unescape(stripNN(lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText()).replace(/\+/g,&quot; &quot;)));&#xD;
			newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
			newLic.setAuditDate(sysDate);&#xD;
			newLic.setAuditID(currentUserID);&#xD;
			newLic.setAuditStatus(&quot;A&quot;);&#xD;
			newLic.setLicenseType(rlpType);&#xD;
			newLic.setLicState(&quot;CA&quot;);  // hardcode CA&#xD;
			newLic.setStateLicense(licNum);&#xD;
&#xD;
			if (lpBiz.getChild(&quot;IssueDt&quot;).getText()) newLic.setLicenseIssueDate(aa.date.parseDate(lpBiz.getChild(&quot;IssueDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ExpireDt&quot;).getText()) newLic.setLicenseExpirationDate(aa.date.parseDate(lpBiz.getChild(&quot;ExpireDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ReissueDt&quot;).getText()) newLic.setLicenseLastRenewalDate(aa.date.parseDate(lpBiz.getChild(&quot;ReissueDt&quot;).getText()));&#xD;
&#xD;
			var wcs = root.getChild(&quot;WorkersComp&quot;).getChildren();&#xD;
&#xD;
			for (var j=0 ; j&lt;wcs.size(); j++) {&#xD;
				wc = wcs.get(j);&#xD;
&#xD;
				if (wc.getAttribute(&quot;PolicyNo&quot;).getValue()) newLic.setWcPolicyNo(wc.getAttribute(&quot;PolicyNo&quot;).getValue());&#xD;
				if (wc.getAttribute(&quot;InsCoCde&quot;).getValue()) newLic.setWcInsCoCode(unescape(wc.getAttribute(&quot;InsCoCde&quot;).getValue()));&#xD;
				if (wc.getAttribute(&quot;WCEffDt&quot;).getValue()) newLic.setWcEffDate(aa.date.parseDate(wc.getAttribute(&quot;WCEffDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCExpDt&quot;).getValue()) newLic.setWcExpDate(aa.date.parseDate(wc.getAttribute(&quot;WCExpDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCCancDt&quot;).getValue()) newLic.setWcCancDate(aa.date.parseDate(wc.getAttribute(&quot;WCCancDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;Exempt&quot;).getValue() == &quot;E&quot;) newLic.setWcExempt(&quot;Y&quot;); else newLic.setWcExempt(&quot;N&quot;);&#xD;
&#xD;
				break; // only use first&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// Do the refresh/create and get the sequence number&#xD;
			//&#xD;
			if (updating)&#xD;
				{&#xD;
				var myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
				var licSeqNbr = newLic.getLicSeqNbr();&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
				if (!myResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;**WARNING: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
					continue;&#xD;
					}&#xD;
&#xD;
				var licSeqNbr = myResult.getOutput()&#xD;
				}&#xD;
&#xD;
			logDebug(&quot;Successfully added/updated License No. &quot; + licNum + &quot;, Type: &quot; + rlpType + &quot; Sequence Number &quot; + licSeqNbr);&#xD;
&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data -- first copy from the transactional LP if it exists&#xD;
			/////&#xD;
&#xD;
&#xD;
			if (isObject)  // update the reference LP with attributes from the transactional, if we have some.&#xD;
				{&#xD;
				var attrArray = licObj.getAttributes();&#xD;
&#xD;
				if (attrArray)&#xD;
					{&#xD;
					for (var k in attrArray)&#xD;
						{&#xD;
						var attr = attrArray[k];&#xD;
						editRefLicProfAttribute(licNum,attr.getAttributeName(),attr.getAttributeValue());&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data&#xD;
			/////&#xD;
			/////  NOTE!  Agencies may have to configure template data below based on their configuration.  Please note all edits&#xD;
			/////&#xD;
&#xD;
			var cbs = root.getChild(&quot;Classifications&quot;).getChildren();&#xD;
			for (var m=0 ; m&lt;cbs.size(); m++) {&#xD;
				cb = cbs.get(m);&#xD;
&#xD;
				if (m == 0)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 1&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 1&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 1)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 2&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 2&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				if (m == 2)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 3&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 3&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 3)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 4&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 4&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				}&#xD;
&#xD;
			var bos = root.getChild(&quot;ContractorBond&quot;).getChildren();&#xD;
&#xD;
			for (var n=0 ; n&lt;bos.size(); n++) {&#xD;
				var bo = bos.get(n);&#xD;
				if (bo.getAttribute(&quot;BondAmt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND AMOUNT&quot;,unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()));&#xD;
				if (bo.getAttribute(&quot;BondCancDt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND EXPIRATION&quot;,unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()));&#xD;
&#xD;
				// Currently unused but could be loaded into custom attributes.&#xD;
/*&#xD;
				aa.print(&quot;Bond Surety Type       : &quot; + unescape(bo.getAttribute(&quot;SuretyTp&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Code              : &quot; + unescape(bo.getAttribute(&quot;InsCoCde&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Insurance Company : &quot; + unescape(bo.getAttribute(&quot;InsCoName&quot;).getValue()).replace(/\+/g,&quot; &quot;))&#xD;
				aa.print(&quot;Bond Number            : &quot; + unescape(bo.getAttribute(&quot;BondNo&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Amount            : &quot; + unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Effective Date    : &quot; + unescape(bo.getAttribute(&quot;BondEffDt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Cancel Date       : &quot; + unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()))&#xD;
*/&#xD;
				break; // only use first bond&#xD;
				}&#xD;
&#xD;
			if (doPopulateTrx)&#xD;
				{&#xD;
				var lpsmResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,licSeqNbr)&#xD;
					if (!lpsmResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING error retrieving the LP just created &quot; + lpsmResult.getErrorMessage()) ; }&#xD;
&#xD;
				var lpsm = lpsmResult.getOutput();&#xD;
&#xD;
				// Remove from CAP&#xD;
&#xD;
				var isPrimary = false;&#xD;
&#xD;
				for (var currLic in capLicenseArr)&#xD;
					{&#xD;
					var thisLP = capLicenseArr[currLic];&#xD;
					if (thisLP.getLicenseType() == rlpType &amp;&amp; thisLP.getLicenseNbr() == licNum)&#xD;
						{&#xD;
						logDebug(&quot;Removing license: &quot; + thisLP.getLicenseNbr() + &quot; from CAP.  We will link the new reference LP&quot;);&#xD;
						if (thisLP.getPrintFlag() == &quot;Y&quot;)&#xD;
							{&#xD;
							logDebug(&quot;...remove primary status...&quot;);&#xD;
							isPrimary = true;&#xD;
							thisLP.setPrintFlag(&quot;N&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisLP);&#xD;
							}&#xD;
						var remCapResult = aa.licenseProfessional.removeLicensedProfessional(thisLP);&#xD;
						if (capLicenseResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;...Success.&quot;); }&#xD;
						else&#xD;
							{ logDebug(&quot;**WARNING removing lic prof: &quot; + remCapResult.getErrorMessage()); }&#xD;
						}&#xD;
					}&#xD;
&#xD;
				// add the LP to the CAP&#xD;
				var asCapResult= aa.licenseScript.associateLpWithCap(itemCap,lpsm)&#xD;
				if (!asCapResult.getSuccess())&#xD;
				{ logDebug(&quot;**WARNING error associating CAP to LP: &quot; + asCapResult.getErrorMessage()) }&#xD;
				else&#xD;
					{ logDebug(&quot;Associated the CAP to the new LP&quot;) }&#xD;
&#xD;
				// Now make the LP primary again&#xD;
				if (isPrimary)&#xD;
					{&#xD;
					var capLps = getLicenseProfessional(itemCap);&#xD;
&#xD;
					for (var thisCapLpNum in capLps)&#xD;
						{&#xD;
						if (capLps[thisCapLpNum].getLicenseNbr().equals(licNum))&#xD;
							{&#xD;
							var thisCapLp = capLps[thisCapLpNum];&#xD;
							thisCapLp.setPrintFlag(&quot;Y&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisCapLp);&#xD;
							logDebug(&quot;Updated primary flag on Cap LP : &quot; + licNum);&#xD;
&#xD;
							// adding this return will cause the test script to work without error, even though this is the last statement executed&#xD;
							//if (returnMessage.length &gt; 0) return returnMessage;&#xD;
							//else return null;&#xD;
&#xD;
							}&#xD;
						}&#xD;
				}&#xD;
			} // do populate on the CAP&#xD;
		} // do populate on the REF&#xD;
	} // for each license&#xD;
&#xD;
	if (returnMessage.length &gt; 0) return returnMessage;&#xD;
	else return null;&#xD;
&#xD;
} // end function&#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	}&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
function feeCopyByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			 addFee(ffeObjArr[ff].getFeeCod(),  ffeObjArr[ff].getFeeSchudle() ,  ffeObjArr[ff].getPaymentPeriod() ,  ffeObjArr[ff].getFeeUnit() ,    'Y') &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
function getChildTasks(taskName) {&#xD;
    var childTasks = new Array();&#xD;
    var childId = null;&#xD;
    var itemCap = capId&#xD;
    if (arguments.length &gt; 1)&#xD;
        itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
    var wfObj = workflowResult.getOutput();&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getTaskDescription().equals(taskName)) {&#xD;
            var relationArray = aa.workflow.getProcessRelationByCapID(itemCap, null).getOutput()&#xD;
            for (thisRel in relationArray) {&#xD;
                y = relationArray[thisRel]&#xD;
                if (y.getParentTaskName() &amp;&amp; y.getParentTaskName().equals(fTaskSM.getTaskDescription()))&#xD;
                    childId = y.getProcessID()&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getProcessID() == childId)&#xD;
            childTasks.push(fTaskSM)&#xD;
    }&#xD;
&#xD;
    return childTasks;&#xD;
&#xD;
}&#xD;
&#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0];&#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // we are in a page flow script so use the capModel to get contacts&#xD;
		{&#xD;
		capContactArray = cap.getContactsGroup().toArray() ;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var capContactArray = capContactResult.getOutput();&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	if (capContactArray)&#xD;
		{&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;middleName&quot;] = capContactArray[yy].getPeople().middleName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;&#xD;
&#xD;
			if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // using capModel to get contacts&#xD;
				var pa = capContactArray[yy].getPeople().getAttributes().toArray();&#xD;
			else&#xD;
				var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);&#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}&#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
  function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
function getLastScheduledInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector that is assigned to the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function getLicenseProfessional(itemcapId)&#xD;
{&#xD;
	capLicenseArr = null;&#xD;
	var s_result = aa.licenseProfessional.getLicenseProf(itemcapId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capLicenseArr = s_result.getOutput();&#xD;
		if (capLicenseArr == null || capLicenseArr.length == 0)&#xD;
		{&#xD;
			aa.print(&quot;WARNING: no licensed professionals on this CAP:&quot; + itemcapId);&#xD;
			capLicenseArr = null;&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to license professional: &quot; + s_result.getErrorMessage());&#xD;
		capLicenseArr = null;&#xD;
	}&#xD;
	return capLicenseArr;&#xD;
}&#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; newLicArray[thisLic] &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    }&#xD;
&#xD;
function isReadyRenew(capid) {&#xD;
    if (capid == null || aa.util.instanceOfString(capid)) {&#xD;
        return false;&#xD;
    }&#xD;
    var result = aa.expiration.isExpiredLicenses(capid);&#xD;
    if (result.getSuccess()) {&#xD;
        return true;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Failed to get expiration with CAP(&quot; + capid + &quot;): &quot; + result.getErrorMessage());&#xD;
    }&#xD;
    return false;&#xD;
}&#xD;
&#xD;
function isRenewProcess(parentCapID, partialCapID) {&#xD;
    //1. Check to see parent CAP ID is null.&#xD;
    if (parentCapID == null || partialCapID == null)&#xD;
    { logDebug(&quot;ERROR: the parentCapID or the partialCap ID is null&quot;); return false; }&#xD;
    //2. Get CAPModel by PK for partialCAP.&#xD;
    var result = aa.cap.getCap(partialCapID);&#xD;
    if (result.getSuccess()) {&#xD;
        capScriptModel = result.getOutput();&#xD;
        //2.1. Check to see if it is partial CAP.&#xD;
        if (capScriptModel.isCompleteCap()) {&#xD;
            logDebug(&quot;ERROR: It is not partial CAP(&quot; + capScriptModel.getCapID() + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Fail to get CAPModel (&quot; + partialCapID + &quot;): &quot; + result.getErrorMessage());&#xD;
        return false;&#xD;
    }&#xD;
    //3.  Check to see if the renewal was initiated before.&#xD;
    result = aa.cap.getProjectByMasterID(parentCapID, &quot;Renewal&quot;, &quot;Incomplete&quot;);&#xD;
    if (result.getSuccess()) {&#xD;
        partialProjects = result.getOutput();&#xD;
        if (partialProjects != null &amp;&amp; partialProjects.length &gt; 0) {&#xD;
            //Avoid to initiate renewal process multiple times.&#xD;
            logDebug(&quot;Warning: Renewal process was initiated before. ( &quot; + parentCapID + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
&#xD;
    }&#xD;
    //4 . Check to see if parent CAP is ready for renew.&#xD;
    return isReadyRenew(parentCapID);&#xD;
}&#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function licenseObject(licnumber)  // optional renewal Cap ID -- uses the expiration on the renewal CAP.&#xD;
	{&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
&#xD;
   	b1ExpResult = aa.expiration.getLicensesByCapID(itemCap)&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
			tmpDate = this.b1Exp.getExpDate();&#xD;
			if (tmpDate)&#xD;
				this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
			this.b1Status = this.b1Exp.getExpStatus();&#xD;
			logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + b1ExpResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function loadAddressAttributes(thisArr)&#xD;
{&#xD;
	//&#xD;
	// Returns an associative array of Address Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
   	var capAddressResult = aa.address.getAddressWithAttributeByCapId(itemCap);&#xD;
   	if (capAddressResult.getSuccess())&#xD;
   		var fcapAddressObj = capAddressResult.getOutput();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddressResult.getErrorType() + &quot;:&quot; + capAddressResult.getErrorMessage())&#xD;
&#xD;
  	for (i in fcapAddressObj)&#xD;
  	{&#xD;
  		addressAttrObj = fcapAddressObj[i].getAttributes().toArray();&#xD;
  		for (z in addressAttrObj)&#xD;
			thisArr[&quot;AddressAttribute.&quot; + addressAttrObj[z].getB1AttributeName()]=addressAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;AddressAttribute.PrimaryFlag&quot;] = fcapAddressObj[i].getPrimaryFlag();&#xD;
		thisArr[&quot;AddressAttribute.HouseNumberStart&quot;] = fcapAddressObj[i].getHouseNumberStart();&#xD;
		thisArr[&quot;AddressAttribute.StreetDirection&quot;] = fcapAddressObj[i].getStreetDirection();&#xD;
		thisArr[&quot;AddressAttribute.StreetName&quot;] = fcapAddressObj[i].getStreetName();&#xD;
		thisArr[&quot;AddressAttribute.StreetSuffix&quot;] = fcapAddressObj[i].getStreetSuffix();&#xD;
		thisArr[&quot;AddressAttribute.City&quot;] = fcapAddressObj[i].getCity();&#xD;
		thisArr[&quot;AddressAttribute.State&quot;] = fcapAddressObj[i].getState();&#xD;
		thisArr[&quot;AddressAttribute.Zip&quot;] = fcapAddressObj[i].getZip();&#xD;
		thisArr[&quot;AddressAttribute.AddressStatus&quot;] = fcapAddressObj[i].getAddressStatus();&#xD;
		thisArr[&quot;AddressAttribute.County&quot;] = fcapAddressObj[i].getCounty();&#xD;
		thisArr[&quot;AddressAttribute.Country&quot;] = fcapAddressObj[i].getCountry();&#xD;
		thisArr[&quot;AddressAttribute.AddressDescription&quot;] = fcapAddressObj[i].getAddressDescription();&#xD;
		thisArr[&quot;AddressAttribute.XCoordinate&quot;] = fcapAddressObj[i].getXCoordinator();&#xD;
		thisArr[&quot;AddressAttribute.YCoordinate&quot;] = fcapAddressObj[i].getYCoordinator();&#xD;
  	}&#xD;
}&#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
      var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		var readOnly = 'N';&#xD;
		if (readOnlyi.hasNext()) {&#xD;
			readOnly = readOnlyi.next();&#xD;
		}&#xD;
		var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
		tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
		}&#xD;
		tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	}&#xD;
&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
	  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
				}&#xD;
&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
			//tempObject[tcol.getColumnName()] = tval;&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadASITablesBefore() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	//&#xD;
&#xD;
	var gm =  aa.env.getValue(&quot;AppSpecificTableGroupModel&quot;);&#xD;
	var ta = gm.getTablesMap().values()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
		  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator();&#xD;
&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
			}&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
          eval(copyStr);  // move to table name&#xD;
&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
&#xD;
function loadGuideSheetItems(inspId) {&#xD;
	//&#xD;
	// Returns an associative array of Guide Sheet Items&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var retArray = new Array()&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var r = aa.inspection.getInspections(itemCap)&#xD;
&#xD;
	if (r.getSuccess())&#xD;
	 	{&#xD;
		var inspArray = r.getOutput();&#xD;
&#xD;
		for (i in inspArray)&#xD;
			{&#xD;
			if (inspArray[i].getIdNumber() == inspId)&#xD;
				{&#xD;
				var inspModel = inspArray[i].getInspection();&#xD;
&#xD;
				var gs = inspModel.getGuideSheets()&#xD;
&#xD;
				if (gs)&#xD;
					{&#xD;
					gsArray = gs.toArray();&#xD;
					for (var loopk in gsArray)&#xD;
						{&#xD;
						var gsItems = gsArray[loopk].getItems().toArray()&#xD;
						for (var loopi in gsItems)&#xD;
							retArray[gsItems[loopi].getGuideItemText()] = gsItems[loopi].getGuideItemStatus();&#xD;
						}&#xD;
					} // if there are guidesheets&#xD;
				else&#xD;
					logDebug(&quot;No guidesheets for this inspection&quot;);&#xD;
				} // if this is the right inspection&#xD;
			} // for each inspection&#xD;
		} // if there are inspections&#xD;
&#xD;
	logDebug(&quot;loaded &quot; + retArray.length + &quot; guidesheet items&quot;);&#xD;
	return retArray;&#xD;
	}&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + (fTask.getStatusDate().getMonth() + 1) + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
function logDebug(dstr) {&#xD;
&#xD;
    if (!aa.calendar.getNextWorkDay) {&#xD;
&#xD;
		vLevel = 1&#xD;
		if (arguments.length &gt; 1)&#xD;
			vLevel = arguments[1]&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
			debug += dstr + br;&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel)&#xD;
			aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr)&#xD;
		}&#xD;
	else {&#xD;
			debug+=dstr + br;&#xD;
		}&#xD;
&#xD;
}&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
function lookupFeesByValuationSlidingScale(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 2;&#xD;
	if (arguments.length == 4) valNumber = (arguments[3] + 1);&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
                        &#xD;
                        &#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 2)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					var divisor = workVals[1];&#xD;
					saveVal = parseInt((capval - workVals[0])/divisor);&#xD;
					if ((capval - workVals[0]) % divisor &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function prepareRenewal() {&#xD;
&#xD;
    if (isRenewProcess(parentCapId, capId)) {&#xD;
        logDebug(&quot;CAPID(&quot; + parentCapId + &quot;) is ready for renew. PartialCap (&quot; + capId + &quot;)&quot;);&#xD;
&#xD;
        //Associate partial cap with parent CAP.&#xD;
        var result = aa.cap.createRenewalCap(parentCapId, capId, true);&#xD;
        if (result.getSuccess()) {&#xD;
            // Set B1PERMIT.B1_ACCESS_BY_ACA to &quot;N&quot; for partial CAP to not allow that it is searched by ACA user.&#xD;
            aa.cap.updateAccessByACA(capId, &quot;N&quot;);&#xD;
        }&#xD;
        else&#xD;
        { logDebug(&quot;ERROR: Associate partial cap with parent CAP. &quot; + result.getErrorMessage()); return false };&#xD;
&#xD;
        return true;&#xD;
    }&#xD;
    else&#xD;
    { logDebug(&quot;Renewal Process did not finish properly&quot;); return false; }&#xD;
}&#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function removeAllFees(itemCap) // Removes all non-invoiced fee items for a CAP ID&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByCapID(itemCap);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
&#xD;
				var editResult = aa.finance.removeFeeItem(itemCap, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + feeList[feeNum].getFeeCod());&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+feeList[feeNum].getFeeCod()+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
	}&#xD;
&#xD;
	function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.removeAppSpecificTableInfos(tableName,itemCap,currentUserID)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ aa.print(&quot;**WARNING: error removing ASI table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
        else&#xD;
	logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function replaceMessageTokens(m)&#xD;
	{&#xD;
	//  tokens in pipes will attempt to interpret as script variables&#xD;
	//  tokens in curly braces will attempt to replace from AInfo (ASI, etc)&#xD;
	//&#xD;
	//  e.g.   |capId|  or |wfTask|  or |wfStatus|&#xD;
	//&#xD;
	//  e.g.   {Expiration Date}  or  {Number of Electrical Outlets}&#xD;
	//&#xD;
	//  e.g.   m = &quot;Your recent license application (|capIdString|) has successfully passed |wfTask| with a status of |wfStatus|&quot;&#xD;
&#xD;
	while (m.indexOf(&quot;|&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;|&quot;)&#xD;
	  var e = m.indexOf(&quot;|&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;typeof(&quot; + r + &quot;) != \&quot;undefined\&quot; ? &quot; + r + &quot; : \&quot;undefined\&quot;&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\|&quot; + r + &quot;\\|&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
	  }&#xD;
&#xD;
	while (m.indexOf(&quot;{&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;{&quot;)&#xD;
	  var e = m.indexOf(&quot;}&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;AInfo[\&quot;&quot; + r + &quot;\&quot;]&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\{&quot; + r + &quot;\\}&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
&#xD;
	  }&#xD;
&#xD;
	 return m&#xD;
	 }&#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID.&#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm&#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3)&#xD;
		if (arguments[2] != null)&#xD;
			{&#xD;
			var inspRes = aa.person.getUser(arguments[2]);&#xD;
			if (inspRes.getSuccess())&#xD;
				inspectorObj = inspRes.getOutput();&#xD;
			}&#xD;
&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
&#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
function stripNN(fullStr) {&#xD;
    var allowed = &quot;0123456789.&quot;;&#xD;
    var stripped = &quot;&quot;;&#xD;
    for (i = 0; i &lt; fullStr.length(); i++)&#xD;
        if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
        stripped += String.fromCharCode(fullStr.charAt(i))&#xD;
    return stripped;&#xD;
}&#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*&#xD;
DQ 09/03/2009 - Added Check to ensure Task status date is not null prior to getting status date&#xD;
Function will return false on fail&#xD;
*/&#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
	            if (fTask.getStatusDate() != null)&#xD;
	                return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
	            else&#xD;
	                { logMessage(&quot;**ERROR: NULL workflow task &quot;+fTask.getTaskDescription()+&quot; status date. &quot;); return false; }&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number&#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap, &quot;APPLICATION&quot;, stat, sysDate, cmt, systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
}&#xD;
&#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq)&#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
    // 12/22/2008 - DQ - Correct Invoice loop to accumulate instead of reset each iteration&#xD;
&#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)&#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
&#xD;
    var invFeeFound=false;&#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = adjustedQty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) )&#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
&#xD;
	return feeSeq;&#xD;
	}&#xD;
&#xD;
&#xD;
function updateRefParcelToCap() //Takes Optional CapId&#xD;
{&#xD;
	var vCapId = null;&#xD;
	if (arguments.length &gt; 0)&#xD;
		vCapId = arguments[0];&#xD;
	else&#xD;
		vCapId = capId;&#xD;
&#xD;
    var capPrclArr = aa.parcel.getParcelDailyByCapID(vCapId,null).getOutput();&#xD;
    if(capPrclArr != null)&#xD;
    {&#xD;
        for (x in capPrclArr)&#xD;
        {&#xD;
	        var prclObj = aa.parcel.getParceListForAdmin(capPrclArr[x].getParcelNumber(), null, null, null, null, null, null, null, null, null);&#xD;
	        if (prclObj.getSuccess() )&#xD;
	        {&#xD;
		        var prclArr = prclObj.getOutput();&#xD;
		        if (prclArr.length)&#xD;
		        {&#xD;
			        var prcl = prclArr[0].getParcelModel();&#xD;
			        var capPrclObj = aa.parcel.warpCapIdParcelModel2CapParcelModel(vCapId, prcl);&#xD;
&#xD;
			        if (capPrclObj.getSuccess())&#xD;
			        {&#xD;
&#xD;
				        var capPrcl = capPrclObj.getOutput();&#xD;
				        aa.parcel.updateDailyParcelWithAPOAttribute(capPrcl);	&#xD;
				        logDebug(&quot;Updated Parcel &quot; + capPrclArr[x].getParcelNumber() + &quot; with Reference Data&quot;);&#xD;
			        }&#xD;
			        else&#xD;
				        logDebug(&quot;Failed to Wrap Parcel Model for &quot; + capPrclArr[x].getParcelNumber());&#xD;
&#xD;
		        }&#xD;
		        else&#xD;
			        logDebug(&quot;No matching reference Parcels found for &quot; + capPrclArr[x].getParcelNumber());&#xD;
	        }&#xD;
	        else&#xD;
		        logDebug(&quot;Failed to get reference Parcel for &quot; + capPrclArr[x].getParcelNumber())&#xD;
	    }&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskDepartment(wfstr,wfDepartment) // optional process name&#xD;
	{&#xD;
	// Update the task assignment department&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
        var assignBureau = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[2];&#xD;
	var assignDivision = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[3];&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
        for (var i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
                if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
 			{&#xD;
			if (wfDepartment)&#xD;
				{&#xD;
				var taskUserObj = fTask.getTaskItem().getAssignedUser()&#xD;
				taskUserObj.setBureauCode(assignBureau);&#xD;
				taskUserObj.setDivisionCode(assignDivision);&#xD;
				fTask.setAssignedUser(taskUserObj);&#xD;
        			var taskItem = fTask.getTaskItem();&#xD;
&#xD;
				var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Department Set to &quot; + assignBureau);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update Department.  Invalid department : &quot; + assignBureau);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel()&#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
&#xD;
	}&#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}&#xD;
&#xD;
// custom function to return the Minimum Date&#xD;
function getMinDate(date1, date2, date3, date4)&#xD;
         {&#xD;
           //Gets 4 String Dates, sorts them and return the minimum date&#xD;
           var stringDates = new Array();&#xD;
           var i = 0;&#xD;
           var j = 0;&#xD;
           var temp = &quot;&quot;;&#xD;
           stringDates[0] = date1;&#xD;
           stringDates[1] = date2;&#xD;
           stringDates[2] = date3;&#xD;
           stringDates[3] = date4;&#xD;
&#xD;
           for( i = 0; i &lt; i &lt; stringDates.length; i++)&#xD;
           {&#xD;
              for( j = 0; j &lt; (stringDates.length-1); j++)&#xD;
              {&#xD;
                 if( !isNaN(jsDateToMMDDYYYY(stringDates[i])) || !isNaN(jsDateToMMDDYYYY(stringDates[j])) )&#xD;
                 {&#xD;
                   if( jsDateToMMDDYYYY(stringDates[i]) &lt; jsDateToMMDDYYYY(stringDates[j]) )&#xD;
                   {&#xD;
                      temp = stringDates[i];&#xD;
                      stringDates[i] = stringDates[j];&#xD;
                      stringDates[j] = temp;&#xD;
                   }&#xD;
                 }&#xD;
                 else&#xD;
                 {&#xD;
                    logMessage(&quot;WARNING&quot;,&quot;Date Field is blank or cannot be found. Cannot process record.&quot;);&#xD;
                    continue;&#xD;
                 }&#xD;
              }&#xD;
           }&#xD;
           return stringDates[0];&#xD;
         }</content><initializer></initializer><title>LICPROFUPDATEAFTER</title></script><scriptName>LICPROFUPDATEAFTER</scriptName></agencyEvent>
<agencyEvent><eventName>ParcelUpdateAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:55:05.687-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>ParcelUpdateAfter</name><auditModel><auditDate>2004-01-14T12:05:26-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>ParcelUpdateAfter</description></event><script><name>PARCELUPDATEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2009-10-31T14:38:00-06:00</auditDate><auditID>PMONTOYA</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| Program : ParcelUpdateAfterV1.5.js&#xD;
| Event   : ParcelUpdateAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;ParcelUpdateAfter&quot;;	 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables -- moved up here since we have to get the capid from the parcel model&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var parcelModel = aa.env.getValue(&quot;parcelModel&quot;);&#xD;
logDebug(&quot;parcelModel = &quot; + parcelModel.getClass());&#xD;
&#xD;
capId= parcelModel.getCapID();&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
//var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup;&#xD;
var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	logDebug(&quot;**ERROR getting cap detail : &quot; + capDetailObjResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Internal Functions and Classes (Used by this script)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent)&#xD;
	{&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	var lastEvalTrue = false;&#xD;
	logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);&#xD;
	for (xx in pairObjArray)&#xD;
		{&#xD;
		doObj = pairObjArray[xx];&#xD;
		if (doExecution)&#xD;
			{&#xD;
			if (doObj.enabled)&#xD;
				if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation))&#xD;
					{&#xD;
					eval(token(doObj.act));&#xD;
					lastEvalTrue = true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					if (doObj.elseact)&#xD;
						eval(token(doObj.elseact));&#xD;
					lastEvalTrue = false;&#xD;
					}&#xD;
			}&#xD;
		else // just document&#xD;
			{&#xD;
			docWrite(&quot;|  &quot;,false,docIndent);&#xD;
			var disableString = &quot;&quot;;&#xD;
			if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
			if (doObj.elseact)&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact ,false,docIndent);&#xD;
			else&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act,false,docIndent);&#xD;
&#xD;
			for (yy in doObj.branch)&#xD;
				{&#xD;
				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);&#xD;
				}&#xD;
			}&#xD;
		} // next sAction&#xD;
	if (!doExecution) docWrite(null,true,docIndent);&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
&#xD;
function logDebug(dstr)&#xD;
	{&#xD;
	debug+=dstr + br;&#xD;
	}&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
 &#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
 &#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValueArray is an array of associative array values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
&#xD;
	for (thisrow in tableValueArray)&#xD;
		{&#xD;
		var col = tsm.getColumns()&#xD;
		var coli = col.iterator();&#xD;
&#xD;
		while (coli.hasNext())&#xD;
			{&#xD;
			var colname = coli.next();&#xD;
			fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			logDebug(&quot;Table: &quot; + tableName + &quot; Row:&quot; + thisrow + &quot; Column: &quot; + colname.getColumnName() + &quot; Value: &quot; + tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			}&#xD;
&#xD;
		tsm.setTableField(fld);&#xD;
&#xD;
		if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
		}&#xD;
&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
&#xD;
	// Even when this works it gives an index out of range error&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
 &#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
	        	if (addCapCondResult.getSuccess())&#xD;
	        		{&#xD;
				logMessage(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
	var col = tsm.getColumns()&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
		fld.add(tableValues[colname.getColumnName()]);&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
&#xD;
	if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
 &#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
 &#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
 &#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
 &#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
 &#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	} &#xD;
function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	} &#xD;
function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	} &#xD;
function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	} &#xD;
function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	 &#xD;
function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
 &#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
} &#xD;
function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
 &#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	//check if target CAP has primary address	&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
		&#xD;
	//get addresses from originating CAP	&#xD;
	var capAddressResult = aa.address.getAddressByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddress(newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional fields to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
 &#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
 &#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
 &#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
 &#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	 &#xD;
function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
 &#xD;
function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
 &#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
 &#xD;
function deactivateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logMessage(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
		{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
		}&#xD;
   	&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
			{&#xD;
				while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
				{&#xD;
					if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
					{&#xD;
						appspecObj[i].setChecklistComment(itemValue);&#xD;
						var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
						if (actionResult.getSuccess()) {&#xD;
							logMessage(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
							logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
						} else {&#xD;
							logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
						}&#xD;
						updated = true;&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
					}&#xD;
					i++;&#xD;
				} // while loop&#xD;
			} // item name blank&#xD;
		} // got app specific object	&#xD;
		else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
} &#xD;
function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	} &#xD;
function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
 &#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
	&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
   	&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = Contacts[yy].getEmail();&#xD;
		}	&#xD;
&#xD;
	if (emailAddress.length) &#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no email address&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	} &#xD;
&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
 &#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0]; &#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var capContactArray = capContactResult.getOutput();&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;			&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;			&#xD;
			aArray[&quot;email&quot;] = capContactArray[yy].getPeople().email;&#xD;
			aArray[&quot;addressLine1&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine1();&#xD;
			aArray[&quot;addressLine2&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine2();&#xD;
			aArray[&quot;city&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCity();&#xD;
			aArray[&quot;state&quot;] = capContactArray[yy].getPeople().getCompactAddress().getState();&#xD;
			aArray[&quot;zip&quot;] = capContactArray[yy].getPeople().getCompactAddress().getZip();&#xD;
			aArray[&quot;fax&quot;] = capContactArray[yy].getPeople().fax;&#xD;
			aArray[&quot;notes&quot;] = capContactArray[yy].getPeople().notes;&#xD;
			aArray[&quot;country&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCountry();&#xD;
			aArray[&quot;fullName&quot;] = capContactArray[yy].getPeople().fullName;&#xD;
&#xD;
&#xD;
			var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);                &#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}	&#xD;
&#xD;
 &#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
 &#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
   &#xD;
function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
 &#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
 &#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	} &#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &amp;lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &amp;gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
 &#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
 &#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))  &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    } &#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
 &#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	} &#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
&#xD;
function licenseObject(licnumber)&#xD;
	{&#xD;
	// available statuses (from various R1_SERVER_CONSTANT values&#xD;
	var licenseStatus = new Array(&quot;&quot;,&quot;Active&quot;,&quot;About To Expire&quot;,&quot;Delinquent&quot;,&quot;Expired&quot;,&quot;Invalid&quot;,&quot;Pending&quot;);&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
   	// The only way to pull up a renewal is to supply a status.  I don't understand since it has a 1 to 1 relationship with b1permit, but oh well.&#xD;
   	// the silly thing returns a blank record, so have to check the B1expirationModel to see if it's valid&#xD;
&#xD;
   	for (myStatus in licenseStatus)&#xD;
   		{&#xD;
   		b1ExpResult = aa.expiration.getLicensesByCapID(capId,licenseStatus[myStatus]);&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
   			exptest = this.b1Exp.getB1Expiration();&#xD;
    			if (exptest)&#xD;
    				{&#xD;
    				tmpDate = this.b1Exp.getExpDate();&#xD;
    				if (tmpDate)&#xD;
    					this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
    				this.b1Status = this.b1Exp.getExpStatus();&#xD;
    				logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
    				break&#xD;
    				}&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
		}&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	} &#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
 &#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
 &#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr); &#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
  	&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + fTask.getStatusDate().getMonth() + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}			&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}	&#xD;
 &#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
 &#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
 &#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
 &#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;SCRIPT LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
 &#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	} &#xD;
  function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
	&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
		&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	&#xD;
	tsm.getColumns().clear();&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	&#xD;
	// Even when this works it gives an error of &quot;0&quot;&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error removing all rows from ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
 &#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID. &#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm &#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
	&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
		        &#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
 &#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    &#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
		}&#xD;
	} &#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
	{&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap,&quot;APPLICATION&quot;,stat, sysDate, cmt ,systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq) &#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
        &#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)        &#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
        &#xD;
    var invFeeFound=false;    &#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = fqty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) ) &#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
			&#xD;
	return feeSeq;&#xD;
	} &#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
	&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
	&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel() &#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
	&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
		&#xD;
	}	&#xD;
 &#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	 &#xD;
function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}</content><title>ParcelUpdateAfter</title></script><scriptName>ParcelUpdateAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>PaymentReceiveAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:55:19.550-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>PaymentReceiveAfter</name><auditModel><auditDate>2002-03-15T14:09:24-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after payment allocation is recorded.</description></event><script><name>PAYMENTRECEIVEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-02-06T22:57:14.400-07:00</auditDate><auditID>PMONTOYA</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: PaymentReceiveAfter.js 4781 2009-10-01 05:55:23Z roland.vonschoech $&#xD;
| Program : PaymentReceiveAfterV1.6.js&#xD;
| Event   : PaymentReceiveAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   : Keith - added function function getParentCapIDForReview(capid)to bottom&#xD;
|         : Caleb - modified function getParentCapIDForReview to use a'completed' renewal  record.  Should be noted the scripting will need to be changed when updating script to Master Scripts V2.0&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;PaymentReceiveAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup = null;&#xD;
if(appTypeArray[0].substr(0,1) !=&quot;_&quot;) //Model Home Check&#xD;
{&#xD;
	var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
	if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
}&#xD;
var publicUser = false;&#xD;
if (currentUserID.indexOf(&quot;PUBLICUSER&quot;) == 0) { currentUserID = &quot;ADMIN&quot;; publicUser = true }&#xD;
var partialCap = !cap.isCompleteCap();&#xD;
&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var FeeSeqList = aa.env.getValue(&quot;FeeItemsList&quot;);			logDebug(&quot;FeeSeqList = &quot; + FeeSeqList);&#xD;
var FeeItemsOffsetList = aa.env.getValue(&quot;FeeItemsOffsetList&quot;);		logDebug(&quot;FeeItemsOffsetList = &quot; + FeeItemsOffsetList);&#xD;
var FeeItemsPaidList = aa.env.getValue(&quot;FeeItemsPaidList&quot;);		logDebug(&quot;FeeItemsPaidList = &quot; + FeeItemsPaidList);&#xD;
var FeePeriod = aa.env.getValue(&quot;FeePeriod&quot;);				logDebug(&quot;FeePeriod = &quot; + FeePeriod);&#xD;
var NumberOfFeeItems = aa.env.getValue(&quot;NumberOfFeeItems&quot;);		logDebug(&quot;NumberOfFeeItems = &quot; + NumberOfFeeItems);&#xD;
var PaymentCashierId = aa.env.getValue(&quot;PaymentCashierId&quot;);		logDebug(&quot;PaymentCashierId = &quot; + PaymentCashierId);&#xD;
var PaymentComment = aa.env.getValue(&quot;PaymentComment&quot;);			logDebug(&quot;PaymentComment = &quot; + PaymentComment);&#xD;
var PaymentDate = aa.env.getValue(&quot;PaymentDate&quot;);			logDebug(&quot;PaymentDate = &quot; + PaymentDate);&#xD;
var PaymentMethod = aa.env.getValue(&quot;PaymentMethod&quot;);			logDebug(&quot;PaymentMethod = &quot; + PaymentMethod);&#xD;
var PaymentRegisterId = aa.env.getValue(&quot;PaymentRegisterId&quot;);		logDebug(&quot;PaymentRegisterId = &quot; + PaymentRegisterId);&#xD;
var PaymentTotalAvailableAmount = aa.env.getValue(&quot;PaymentTotalAvailableAmount&quot;);	logDebug(&quot;PaymentTotalAvailableAmount = &quot; + PaymentTotalAvailableAmount);&#xD;
var PaymentTotalPaidAmount  = aa.env.getValue(&quot;PaymentTotalPaidAmount&quot;);	logDebug(&quot;PaymentTotalPaidAmount  = &quot; + PaymentTotalPaidAmount );&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
  &#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
    	{&#xD;
  	//  tableName is the name of the ASI table&#xD;
  	//  tableValueArray is an array of associative array values.  All elements MUST be either a string or asiTableVal object&#xD;
    	var itemCap = capId&#xD;
  	if (arguments.length &gt; 2)&#xD;
  		itemCap = arguments[2]; // use cap ID specified in args&#xD;
  &#xD;
  	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
  &#xD;
  	if (!tssmResult.getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
  &#xD;
  	var tssm = tssmResult.getOutput();&#xD;
  	var tsm = tssm.getAppSpecificTableModel();&#xD;
  	var fld = tsm.getTableField();&#xD;
        var fld_readonly = tsm.getReadonlyField(); // get Readonly field&#xD;
  &#xD;
         	for (thisrow in tableValueArray)&#xD;
  		{&#xD;
  &#xD;
  		var col = tsm.getColumns()&#xD;
  		var coli = col.iterator();&#xD;
  &#xD;
  		while (coli.hasNext())&#xD;
  			{&#xD;
  			var colname = coli.next();&#xD;
  &#xD;
			if (typeof(tableValueArray[thisrow][colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
				{&#xD;
	  			fld.add(tableValueArray[thisrow][colname.getColumnName()].fieldValue);&#xD;
	  			fld_readonly.add(tableValueArray[thisrow][colname.getColumnName()].readOnly);&#xD;
				}&#xD;
			else // we are passed a string&#xD;
				{&#xD;
  				fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
  				fld_readonly.add(null);&#xD;
				}&#xD;
  			}&#xD;
  &#xD;
  		tsm.setTableField(fld);&#xD;
  &#xD;
  		tsm.setReadonlyField(fld_readonly);&#xD;
  &#xD;
  		}&#xD;
  &#xD;
  	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
  &#xD;
  	 if (!addResult .getSuccess())&#xD;
  		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
  	else&#xD;
  		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
  &#xD;
  	}&#xD;
  &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
&#xD;
function addFeeWithExtraData(fcode, fsched, fperiod, fqty, finvoice, feeCap, feeComment, UDF1, UDF2) {&#xD;
    var feeCapMessage = &quot;&quot;;&#xD;
    var feeSeq_L = new Array(); 			// invoicing fee for CAP in args&#xD;
    var paymentPeriod_L = new Array(); 		// invoicing pay periods for CAP in args&#xD;
&#xD;
    assessFeeResult = aa.finance.createFeeItem(feeCap, fsched, fcode, fperiod, fqty);&#xD;
    if (assessFeeResult.getSuccess()) {&#xD;
        feeSeq = assessFeeResult.getOutput();&#xD;
        logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
        logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
        fsm = aa.finance.getFeeItemByPK(feeCap, feeSeq).getOutput().getF4FeeItem();&#xD;
&#xD;
        if (feeComment) fsm.setFeeNotes(feeComment);&#xD;
        if (UDF1) fsm.setUdf1(UDF1);&#xD;
        if (UDF2) fsm.setUdf2(UDF2);&#xD;
&#xD;
        aa.finance.editFeeItem(fsm)&#xD;
&#xD;
&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
        {&#xD;
            feeSeqList.push(feeSeq);&#xD;
            paymentPeriodList.push(fperiod);&#xD;
        }&#xD;
        if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
        {&#xD;
            feeSeq_L.push(feeSeq);&#xD;
            paymentPeriod_L.push(fperiod);&#xD;
            var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
            if (invoiceResult_L.getSuccess())&#xD;
                logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
            else&#xD;
                logDebug(&quot;**ERROR: Invoicing the fee items assessed was not successful.  Reason: &quot; + invoiceResult.getErrorMessage());&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
        return null;&#xD;
    }&#xD;
&#xD;
    return feeSeq;&#xD;
&#xD;
}&#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
function addParcelAndOwnerFromRefAddress(refAddress)  // optional capID&#xD;
	{&#xD;
&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	// first add the primary parcel&#xD;
	//&#xD;
	var primaryParcelResult = aa.parcel.getPrimaryParcelByRefAddressID(refAddress,&quot;Y&quot;);&#xD;
	if (primaryParcelResult.getSuccess())&#xD;
		var primaryParcel = primaryParcelResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get primary parcel for ref Address &quot; + refAddress + &quot; , &quot; + primaryParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var capParModel = aa.parcel.warpCapIdParcelModel2CapParcelModel(capId,primaryParcel).getOutput()&#xD;
&#xD;
	var createPMResult = aa.parcel.createCapParcel(capParModel);&#xD;
	if (createPMResult.getSuccess())&#xD;
		logDebug(&quot;created CAP Parcel&quot;);&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Failed to create the cap Parcel &quot; + createPMResult.getErrorMessage()); }&#xD;
&#xD;
&#xD;
	// Now the owners&#xD;
	//&#xD;
&#xD;
	var parcelListResult = aa.parcel.getParcelDailyByCapID(capId,null);&#xD;
	if (parcelListResult.getSuccess())&#xD;
		var parcelList = parcelListResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel List &quot; + parcelListResult.getErrorMessage()); return false; }&#xD;
&#xD;
&#xD;
	for (var thisP in parcelList)&#xD;
  		{&#xD;
  		var ownerListResult = aa.owner.getOwnersByParcel(parcelList[thisP]);&#xD;
		if (ownerListResult.getSuccess())&#xD;
			var ownerList = ownerListResult.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Failed to get Owner List &quot; + ownerListResult.getErrorMessage()); return false; }&#xD;
&#xD;
  		for (var thisO in ownerList)&#xD;
      			{&#xD;
      			ownerList[thisO].setCapID(capId);&#xD;
      			createOResult = aa.owner.createCapOwnerWithAPOAttribute(ownerList[thisO]);&#xD;
&#xD;
			if (createOResult.getSuccess())&#xD;
				logDebug(&quot;Created CAP Owner&quot;);&#xD;
			else&#xD;
				{ logDebug(&quot;**WARNING: Failed to create CAP Owner &quot; + createOResult.getErrorMessage()); }&#xD;
			}&#xD;
	      	}&#xD;
     }&#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
&#xD;
function addReferenceContactByName(vFirst, vMiddle, vLast)&#xD;
{&#xD;
	var userFirst = vFirst;&#xD;
	var userMiddle = vMiddle;&#xD;
	var userLast = vLast;&#xD;
&#xD;
	//Find PeopleModel object for user&#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
	//Add the reference contact record to the current CAP&#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage());&#xD;
			return false;&#xD;
		}&#xD;
}&#xD;
function addressExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
	var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
	if (capAddResult.getSuccess())&#xD;
		var fcapAddressObj = capAddResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddResult.getErrorType() + &quot;:&quot; + capAddResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapAddressObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
			if (addCapCondResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements must be either a string or asiTableVal object&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	var col = tsm.getColumns();&#xD;
	var fld_readonly = tsm.getReadonlyField(); //get ReadOnly property&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
&#xD;
		if (typeof(tableValues[colname.getColumnName()]) == &quot;object&quot;)  // we are passed an asiTablVal Obj&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()].fieldValue);&#xD;
			fld_readonly.add(tableValues[colname.getColumnName()].readOnly);&#xD;
			}&#xD;
		else // we are passed a string&#xD;
			{&#xD;
			fld.add(tableValues[colname.getColumnName()]);&#xD;
			fld_readonly.add(null);&#xD;
			}&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	tsm.setReadonlyField(fld_readonly); // set readonly field&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
&#xD;
function asiTableValObj(columnName, fieldValue, readOnly) {&#xD;
	this.columnName = columnName;&#xD;
	this.fieldValue = fieldValue;&#xD;
	this.readOnly = readOnly;&#xD;
&#xD;
	asiTableValObj.prototype.toString=function(){ return this.fieldValue }&#xD;
};&#xD;
&#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	}function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	}function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	}function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	}function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	function checkCapForLicensedProfessionalType( licProfType )&#xD;
{&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	&#xD;
	if( capLicenseResult.getSuccess() )&#xD;
	{ &#xD;
		var capLicenseArr = capLicenseResult.getOutput();&#xD;
		&#xD;
		if (!capLicenseArr)&#xD;
			{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
		&#xD;
		for( licProf in capLicenseArr )&#xD;
		{&#xD;
			if( licProfType.equals(capLicenseArr[licProf].getLicenseType()) )&#xD;
			{&#xD;
				aa.print( &quot;Found License Professional with Type= &quot; + licProfType );&#xD;
				return true; //Found Licensed Prof of specified type&#xD;
			}&#xD;
		}&#xD;
		&#xD;
		return false;&#xD;
	}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
}function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
function closeSubWorkflow(thisProcessID,wfStat) // optional capId&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var isCompleted = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTaskSM = wfObj[i];&#xD;
		if (fTaskSM.getProcessID() == thisProcessID &amp;&amp; fTaskSM.getCompleteFlag() != &quot;Y&quot;)&#xD;
			{&#xD;
			logDebug(&quot;closeSubWorkflow: found an incomplete task processID #&quot; + thisProcessID + &quot; , Step# &quot; + fTaskSM.getStepNumber(),3);&#xD;
			isCompleted = false&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (!isCompleted) return false;&#xD;
&#xD;
&#xD;
	// get the parent task&#xD;
&#xD;
	var relationArray = aa.workflow.getProcessRelationByCapID(itemCap,null).getOutput()&#xD;
&#xD;
	var relRecord = null;&#xD;
&#xD;
	for (thisRel in relationArray)&#xD;
		if (relationArray[thisRel].getProcessID() == thisProcessID)&#xD;
			relRecord = relationArray[thisRel];&#xD;
&#xD;
	if (!relRecord)&#xD;
		{&#xD;
		logDebug(&quot;closeSubWorkflow: did not find a process relation, exiting&quot;,3);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	logDebug(&quot;executing handleDisposition:&quot; + relRecord.getStepNumber() + &quot;,&quot; + relRecord.getParentProcessID() + &quot;,&quot; + wfStat,3);&#xD;
&#xD;
	var handleResult = aa.workflow.handleDisposition(itemCap,relRecord.getStepNumber(),relRecord.getParentProcessID(),wfStat,sysDate,&quot;Closed via script&quot;,&quot;Closed via script&quot;,systemUserObj ,&quot;Y&quot;);&#xD;
&#xD;
	if (!handleResult.getSuccess())&#xD;
		logDebug(&quot;**WARNING: closing parent task: &quot; + handleResult.getErrorMessage());&#xD;
	else&#xD;
		logDebug(&quot;Closed parent task&quot;);&#xD;
	}&#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
function comparePeopleGeneric(peop)&#xD;
	{&#xD;
&#xD;
	// this function will be passed as a parameter to the createRefContactsFromCapContactsAndLink function.&#xD;
	//&#xD;
	// takes a single peopleModel as a parameter, and will return the sequence number of the first G6Contact result&#xD;
	//&#xD;
	// returns null if there are no matches&#xD;
	//&#xD;
	// current search method is by email only.  In order to use attributes enhancement 09ACC-05048 must be implemented&#xD;
	//&#xD;
&#xD;
	peop.setAuditDate(null)&#xD;
	peop.setAuditID(null)&#xD;
	peop.setAuditStatus(null)&#xD;
	peop.setBirthDate(null)&#xD;
	peop.setBusName2(null)&#xD;
	peop.setBusinessName(null)&#xD;
	peop.setComment(null)&#xD;
	peop.setCompactAddress(null)&#xD;
	peop.setContactSeqNumber(null)&#xD;
	peop.setContactType(null)&#xD;
	peop.setContactTypeFlag(null)&#xD;
	peop.setCountry(null)&#xD;
	peop.setCountryCode(null)&#xD;
	// peop.setEmail(null)       just as a test we are using email&#xD;
	peop.setEndBirthDate(null)&#xD;
	peop.setFax(null)&#xD;
	peop.setFaxCountryCode(null)&#xD;
	peop.setFein(null)&#xD;
	peop.setFirstName(null)&#xD;
	peop.setFlag(null)&#xD;
	peop.setFullName(null)&#xD;
	peop.setGender(null)&#xD;
	peop.setHoldCode(null)&#xD;
	peop.setHoldDescription(null)&#xD;
	peop.setId(null)&#xD;
	peop.setIvrPinNumber(null)&#xD;
	peop.setIvrUserNumber(null)&#xD;
	peop.setLastName(null)&#xD;
	peop.setMaskedSsn(null)&#xD;
	peop.setMiddleName(null)&#xD;
	peop.setNamesuffix(null)&#xD;
	peop.setPhone1(null)&#xD;
	peop.setPhone1CountryCode(null)&#xD;
	peop.setPhone2(null)&#xD;
	peop.setPhone2CountryCode(null)&#xD;
	peop.setPhone3(null)&#xD;
	peop.setPhone3CountryCode(null)&#xD;
	peop.setPostOfficeBox(null)&#xD;
	peop.setPreferredChannel(null)&#xD;
	peop.setPreferredChannelString(null)&#xD;
	peop.setRate1(null)&#xD;
	peop.setRelation(null)&#xD;
	peop.setSalutation(null)&#xD;
	peop.setServiceProviderCode(null)&#xD;
	peop.setSocialSecurityNumber(null)&#xD;
	peop.setTitle(null)&#xD;
	peop.setTradeName(null)&#xD;
&#xD;
	var r = aa.people.getPeopleByPeopleModel(peop);&#xD;
&#xD;
    if (!r.getSuccess())&#xD;
			{ logDebug(&quot;WARNING: error searching for people : &quot; + r.getErrorMessage()); return false; }&#xD;
&#xD;
	var peopResult = r.getOutput();&#xD;
&#xD;
	if (peopResult.length == 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for REF contact, no matches found, returing null&quot;);&#xD;
		return null;&#xD;
		}&#xD;
&#xD;
	if (peopResult.length &gt; 0)&#xD;
		{&#xD;
		logDebug(&quot;Searched for a REF Contact, &quot; + peopResult.length + &quot; matches found! returning the first match : &quot; + peopResult[0].getContactSeqNumber() );&#xD;
		return peopResult[0].getContactSeqNumber()&#xD;
		}&#xD;
&#xD;
}function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
}function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
function convertStringToPhone(theString)&#xD;
	{&#xD;
	var n = &quot;22233344455566677778889999&quot;;&#xD;
&#xD;
	var compString = String(theString.toUpperCase());&#xD;
	var retString = &quot;&quot;;&#xD;
&#xD;
	for (var x=0 ; x&lt; compString.length ; x++)&#xD;
   		{&#xD;
   		if (compString[x] &gt;= &quot;A&quot; &amp;&amp; compString[x] &lt;= &quot;Z&quot;)&#xD;
   			retString += n[compString.charCodeAt(x)-65]&#xD;
  		 else&#xD;
   			retString += compString[x];&#xD;
  		}&#xD;
   	return retString;&#xD;
 	}&#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
&#xD;
	//check if target CAP has primary address&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//get addresses from originating CAP&#xD;
	var capAddressResult = aa.address.getAddressWithAttributeByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddressWithAPOAttribute(vToCapId, newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	return copied;&#xD;
	}&#xD;
&#xD;
&#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional groups to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
&#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
&#xD;
function copyLicensedProf(sCapId, tCapId)&#xD;
{&#xD;
	//Function will copy all licensed professionals from source CapID to target CapID&#xD;
&#xD;
	var licProf = aa.licenseProfessional.getLicensedProfessionalsByCapID(sCapId).getOutput();&#xD;
	if (licProf != null)&#xD;
		for(x in licProf)&#xD;
		{&#xD;
			licProf[x].setCapID(tCapId);&#xD;
			aa.licenseProfessional.createLicensedProfessional(licProf[x]);&#xD;
			logDebug(&quot;Copied &quot; + licProf[x].getLicenseNbr());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;No licensed professional on source&quot;);&#xD;
}&#xD;
&#xD;
//Function will copy all owners from source CAP (sCapID) to target CAP (tCapId)&#xD;
function copyOwner(sCapID, tCapID)&#xD;
{&#xD;
	var ownrReq = aa.owner.getOwnerByCapId(sCapID);&#xD;
	if(ownrReq.getSuccess())&#xD;
	{&#xD;
		var ownrObj = ownrReq.getOutput();&#xD;
		for (xx in ownrObj)&#xD;
		{&#xD;
			ownrObj[xx].setCapID(tCapID);&#xD;
			aa.owner.createCapOwnerWithAPOAttribute(ownrObj[xx]);&#xD;
			logDebug(&quot;Copied Owner: &quot; + ownrObj[xx].getOwnerFullName())&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
		logDebug(&quot;Error Copying Owner : &quot; + ownrObj.getErrorType() + &quot; : &quot; + ownrObj.getErrorMessage());&#xD;
}&#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	}function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
&#xD;
function createCapComment(vComment)  //optional CapId&#xD;
{&#xD;
	var vCapId = capId;&#xD;
	if (arguments.length == 2)&#xD;
		vCapId = arguments[1];&#xD;
	var comDate = aa.date.getCurrentDate(); &#xD;
	var capCommentScriptModel= aa.cap.createCapCommentScriptModel(); &#xD;
	capCommentScriptModel.setCapIDModel(vCapId); &#xD;
	capCommentScriptModel.setCommentType(&quot;APP LEVEL COMMENT&quot;); &#xD;
	capCommentScriptModel.setSynopsis(&quot;&quot;); &#xD;
	capCommentScriptModel.setText(vComment); &#xD;
	capCommentScriptModel.setAuditUser(currentUserID); &#xD;
	capCommentScriptModel.setAuditStatus(&quot;A&quot;); &#xD;
	capCommentScriptModel.setAuditDate(comDate); &#xD;
	var capCommentModel=capCommentScriptModel.getCapCommentModel(); &#xD;
	aa.cap.createCapComment(capCommentModel); &#xD;
	logDebug(&quot;Comment Added&quot;);&#xD;
}function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createPublicUserFromContact()   // optional: Contact Type, default Applicant&#xD;
{&#xD;
    var contactType = &quot;Applicant&quot;;&#xD;
    var contact;&#xD;
    if (arguments.length &gt; 0) contactType = arguments[0]; // use contact type specified&#xD;
&#xD;
    var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
    if (capContactResult.getSuccess()) {&#xD;
        var Contacts = capContactResult.getOutput();&#xD;
        for (yy in Contacts) {&#xD;
            aa.print(Contacts[yy].getCapContactModel().getPeople().getContactType())&#xD;
            if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
                contact = Contacts[yy];&#xD;
        }&#xD;
    }&#xD;
&#xD;
    aa.print(contact.getEmail());&#xD;
    if (!contact)&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no such contact&quot;); return false; }&#xD;
&#xD;
    if (!contact.getEmail())&#xD;
    { logDebug(&quot;Couldn't create public user for &quot; + contactType + &quot;, no email address&quot;); return false; }&#xD;
&#xD;
    // check if exists already&#xD;
&#xD;
    var getUserResult = aa.publicUser.getPublicUserByEmail(contact.getEmail())&#xD;
    if (getUserResult.getSuccess()) {&#xD;
        var userModel = getUserResult.getOutput()&#xD;
        aa.print(&quot;found the user already&quot;);&#xD;
        if (userModel) return userModel;  // send back the existing user&#xD;
    }&#xD;
&#xD;
    // create a new one&#xD;
&#xD;
    var publicUser = aa.publicUser.getPublicUserModel();&#xD;
    publicUser.setFirstName(contact.getFirstName());&#xD;
    publicUser.setLastName(contact.getLastName());&#xD;
    publicUser.setEmail(contact.getEmail());&#xD;
    publicUser.setUserID(contact.getEmail());&#xD;
    publicUser.setPassword(&quot;7d3fe8b8d7ba80addfc296b07de60cc101e4af60&quot;); //password : Gary0813&#xD;
    publicUser.setAuditID(&quot;PublicUser&quot;);&#xD;
    publicUser.setAuditStatus(&quot;A&quot;);&#xD;
    publicUser.setCellPhone(contact.getCapContactModel().getPeople().getPhone2());&#xD;
&#xD;
    var result = aa.publicUser.createPublicUser(publicUser);&#xD;
&#xD;
    if (result.getSuccess()) {&#xD;
        logDebug(&quot;Created public user &quot; + contact.getEmail() + &quot;  sucessfully.&quot;);&#xD;
        var userSeqNum = result.getOutput();&#xD;
        var userModel = aa.publicUser.getPublicUser(userSeqNum).getOutput()&#xD;
&#xD;
        // create for agency&#xD;
        aa.publicUser.createPublicUserForAgency(userModel);&#xD;
&#xD;
        // activate for agency&#xD;
        var userPinBiz = aa.proxyInvoker.newInstance(&quot;com.accela.pa.pin.UserPINBusiness&quot;).getOutput()&#xD;
		userPinBiz.updateActiveStatusAndLicenseIssueDate4PublicUser(servProvCode,userSeqNum,&quot;ADMIN&quot;);&#xD;
		// reset password&#xD;
&#xD;
		var PUB = aa.proxyInvoker.newInstance(&quot;com.accela.v360.publicuser.PublicUserBusiness&quot;).getOutput()&#xD;
		PUB.resetPassword(contact.getEmail());&#xD;
&#xD;
        // send Activate email&#xD;
        aa.publicUser.sendActivateEmail(userModel, true, true);&#xD;
&#xD;
        // send another email&#xD;
        aa.publicUser.sendPasswordEmail(userModel);&#xD;
        return userModel;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;**Warning creating public user &quot; + contact.getEmail() + &quot;  failure: &quot; + result.getErrorMessage()); return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
function createRefContactsFromCapContactsAndLink(pCapId, contactTypeArray, ignoreAttributeArray, replaceCapContact, overwriteRefContact, refContactExists)&#xD;
	{&#xD;
&#xD;
	// contactTypeArray is either null (all), or an array or contact types to process&#xD;
	//&#xD;
	// ignoreAttributeArray is either null (none), or an array of attributes to ignore when creating a REF contact&#xD;
	//&#xD;
	// replaceCapContact not implemented yet&#xD;
	//&#xD;
	// overwriteRefContact -- if true, will refresh linked ref contact with CAP contact data&#xD;
	//&#xD;
	// refContactExists is a function for REF contact comparisons.&#xD;
	//&#xD;
	var ingoreArray = new Array();&#xD;
	if (arguments.length &gt; 1) ignoreArray = arguments[1];&#xD;
&#xD;
	var c = aa.people.getCapContactByCapID(pCapId).getOutput()&#xD;
	var cCopy = aa.people.getCapContactByCapID(pCapId).getOutput()  // must have two working datasets&#xD;
&#xD;
	for (var i in c)&#xD;
	   {&#xD;
	   var con = c[i];&#xD;
&#xD;
	   var p = con.getPeople();&#xD;
	   &#xD;
	   if (contactTypeArray &amp;&amp; !exists(p.getContactType(),contactTypeArray))&#xD;
		continue;  // not in the contact type list.  Move along.&#xD;
&#xD;
	   &#xD;
	   var refContactNum = con.getCapContactModel().getRefContactNumber();&#xD;
	   if (refContactNum)  // This is a reference contact.   Let's refresh or overwrite as requested in parms.&#xD;
	   	{&#xD;
	   	if (overwriteRefContact)&#xD;
	   		{&#xD;
	   		p.setContactSeqNumber(refContactNum);  // set the ref seq# to refresh&#xD;
	   		&#xD;
	   		&#xD;
	   						var a = p.getAttributes();&#xD;
			&#xD;
							if (a)&#xD;
								{&#xD;
								var ai = a.iterator();&#xD;
								while (ai.hasNext())&#xD;
									{&#xD;
									var xx = ai.next();&#xD;
									xx.setContactNo(refContactNum);&#xD;
									}&#xD;
					}&#xD;
					&#xD;
					&#xD;
					&#xD;
	   		var r = aa.people.editPeopleWithAttribute(p,p.getAttributes());&#xD;
	   		&#xD;
			if (!r.getSuccess()) &#xD;
				logDebug(&quot;WARNING: couldn't refresh reference people : &quot; + r.getErrorMessage()); &#xD;
			else&#xD;
				logDebug(&quot;Successfully refreshed ref contact #&quot; + refContactNum + &quot; with CAP contact data&quot;); &#xD;
			}&#xD;
			&#xD;
	   	if (replaceCapContact)&#xD;
	   		{&#xD;
				// To Be Implemented later.   Is there a use case?&#xD;
			}&#xD;
			&#xD;
	   	}&#xD;
	   	else  // user entered the contact freehand.   Let's create or link to ref contact.&#xD;
	   	{&#xD;
			var ccmSeq = p.getContactSeqNumber();&#xD;
&#xD;
			var existingContact = refContactExists(p);  // Call the custom function to see if the REF contact exists&#xD;
&#xD;
			var p = cCopy[i].getPeople();  // get a fresh version, had to mangle the first for the search&#xD;
&#xD;
			if (existingContact)  // we found a match with our custom function.  Use this one.&#xD;
				{&#xD;
					refPeopleId = existingContact;&#xD;
				}&#xD;
			else  // did not find a match, let's create one&#xD;
				{&#xD;
&#xD;
				var a = p.getAttributes();&#xD;
&#xD;
				if (a)&#xD;
					{&#xD;
					//&#xD;
					// Clear unwanted attributes&#xD;
					var ai = a.iterator();&#xD;
					while (ai.hasNext())&#xD;
						{&#xD;
						var xx = ai.next();&#xD;
						if (ignoreAttributeArray &amp;&amp; exists(xx.getAttributeName().toUpperCase(),ignoreAttributeArray))&#xD;
							ai.remove();&#xD;
						}&#xD;
					}&#xD;
&#xD;
				var r = aa.people.createPeopleWithAttribute(p,a);&#xD;
&#xD;
				if (!r.getSuccess())&#xD;
					{logDebug(&quot;WARNING: couldn't create reference people : &quot; + r.getErrorMessage()); continue; }&#xD;
&#xD;
				//&#xD;
				// createPeople is nice and updates the sequence number to the ref seq&#xD;
				//&#xD;
&#xD;
				var p = cCopy[i].getPeople();&#xD;
				var refPeopleId = p.getContactSeqNumber();&#xD;
&#xD;
				logDebug(&quot;Successfully created reference contact #&quot; + refPeopleId);&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// now that we have the reference Id, we can link back to reference&#xD;
			//&#xD;
&#xD;
		    var ccm = aa.people.getCapContactByPK(pCapId,ccmSeq).getOutput().getCapContactModel();&#xD;
&#xD;
		    ccm.setRefContactNumber(refPeopleId);&#xD;
		    r = aa.people.editCapContact(ccm);&#xD;
&#xD;
		    if (!r.getSuccess())&#xD;
				{ logDebug(&quot;WARNING: error updating cap contact model : &quot; + r.getErrorMessage()); }&#xD;
			else&#xD;
				{ logDebug(&quot;Successfully linked ref contact &quot; + refPeopleId + &quot; to cap contact &quot; + ccmSeq);}&#xD;
&#xD;
&#xD;
	    }  // end if user hand entered contact &#xD;
	}  // end for each CAP contact&#xD;
} // end function&#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
function deactivateTask(wfstr) // optional process name&#xD;
{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
	{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
	}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
	{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
		{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
		}			&#xD;
	}&#xD;
}&#xD;
&#xD;
function deleteTask(targetCapId,deleteTaskName)&#xD;
{&#xD;
	//&#xD;
	// Get the target Task&#xD;
	//&#xD;
	var workflowResult = aa.workflow.getTasks(targetCapId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	var tTask = null;&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(deleteTaskName.toUpperCase()))&#xD;
  			{&#xD;
			var tTask = wfObj[i];&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	if (!tTask)&#xD;
  	  	{ logDebug(&quot;**WARNING: Task not found: &quot; + deleteTaskName); return false; }&#xD;
&#xD;
&#xD;
	logDebug(&quot;Removing task &quot; + tTask.getTaskDescription());&#xD;
	var result = aa.workflow.removeTask(tTask)&#xD;
&#xD;
	if (!result.getSuccess())&#xD;
		{ logDebug(&quot;error &quot; + result.getErrorMessage()); return false; }&#xD;
&#xD;
}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry, doExecution, docIndent) {&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    var lastEvalTrue = false;&#xD;
    stopBranch = false;  // must be global scope&#xD;
&#xD;
    logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
    var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
    if (!doExecution) docWrite(stdChoiceEntry, true, docIndent);&#xD;
    for (xx in pairObjArray) {&#xD;
        doObj = pairObjArray[xx];&#xD;
        if (doExecution) {&#xD;
            if (doObj.enabled) {&#xD;
&#xD;
				if (stopBranch)&#xD;
					{&#xD;
					stopBranch = false;&#xD;
					break;&#xD;
					}&#xD;
&#xD;
                logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Criteria : &quot; + doObj.cri, 2)&#xD;
&#xD;
                if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation)) {&#xD;
                    logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Action : &quot; + doObj.act, 2)&#xD;
&#xD;
                    eval(token(doObj.act));&#xD;
                    lastEvalTrue = true;&#xD;
                }&#xD;
                else {&#xD;
                    if (doObj.elseact) {&#xD;
                        logDebug(aa.env.getValue(&quot;CurrentUserID&quot;) + &quot; : &quot; + stdChoiceEntry + &quot; : #&quot; + doObj.ID + &quot; : Else : &quot; + doObj.elseact, 2)&#xD;
                        eval(token(doObj.elseact));&#xD;
                    }&#xD;
                    lastEvalTrue = false;&#xD;
                }&#xD;
            }&#xD;
        }&#xD;
        else // just document&#xD;
        {&#xD;
            docWrite(&quot;|  &quot;, false, docIndent);&#xD;
            var disableString = &quot;&quot;;&#xD;
            if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
            if (doObj.elseact)&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact, false, docIndent);&#xD;
            else&#xD;
                docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act, false, docIndent);&#xD;
&#xD;
            for (yy in doObj.branch) {&#xD;
                doStandardChoiceActions(doObj.branch[yy], false, docIndent + 1);&#xD;
            }&#xD;
        }&#xD;
    } // next sAction&#xD;
    if (!doExecution) docWrite(null, true, docIndent);&#xD;
    var thisDate = new Date();&#xD;
    var thisTime = thisDate.getTime();&#xD;
    logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot; + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
}&#xD;
&#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	&#xD;
	itemCap = capId;&#xD;
	&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
   	&#xD;
   	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
			{&#xD;
				if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
				{&#xD;
					appspecObj[i].setChecklistComment(itemValue);&#xD;
						&#xD;
					var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
					if (actionResult.getSuccess()) &#xD;
					{							&#xD;
						logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
					} &#xD;
					else &#xD;
					{&#xD;
						logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
					}&#xD;
						&#xD;
					updated = true;&#xD;
					AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
				}&#xD;
				&#xD;
				i++;&#xD;
				&#xD;
			} // while loop&#xD;
		} // item name blank&#xD;
	} // got app specific object	&#xD;
	else&#xD;
	{ &#xD;
		logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage());&#xD;
	}&#xD;
}//End Function&#xD;
&#xD;
function editBuildingCount(numBuild) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setBuildingCount(parseFloat(numBuild));&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated building count to &quot; + numBuild); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
}function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
function editInspectionRequiredFlag(inspType,reqFlag)&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var result = aa.inspection.getInspMilestoneByCapID(itemCap);&#xD;
&#xD;
	if(!result.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection milestones: &quot;  + result.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspMilestones= result.getOutput();&#xD;
&#xD;
	if (!inspMilestones)&#xD;
		{ logDebug(&quot;No Inspection Milestones found&quot;) ; return false ; }&#xD;
&#xD;
	for (thisM in inspMilestones)&#xD;
		{&#xD;
		var obj= inspMilestones[thisM];&#xD;
		if (inspType.equals(obj.getInspType()))&#xD;
			{&#xD;
			if (reqFlag) obj.setInspRequired(&quot;Y&quot;);&#xD;
			else obj.setInspRequired(&quot;N&quot;);&#xD;
&#xD;
			result = aa.inspection.updateInspectionMilestone(inspMilestones);&#xD;
			if(result.getSuccess())&#xD;
				logDebug(&quot;inspection milestone updated sucessfully.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: could not update inpsection milestone &quot; +result.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	}function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editScheduledDate(scheduledDate) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	vScheduledDate = aa.date.parseDate(scheduledDate);&#xD;
	&#xD;
	//cd.setScheduledDate(vScheduledDate); //bug, doesn't work&#xD;
	cdScriptObj.setScheduledDate(vScheduledDate);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated scheduled date to &quot; + scheduledDate) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR updating scheduled date: &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
}function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = &quot;&quot; + Contacts[yy].getEmail();&#xD;
		}&#xD;
&#xD;
	if (emailAddress.indexOf(&quot;@&quot;) &gt; 0)&#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no valid email address&quot;);&#xD;
	}function endBranch() {&#xD;
	// stop execution of the current std choice&#xD;
	stopBranch = false;&#xD;
	}function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
&#xD;
function externalLP_CA(licNum,rlpType,doPopulateRef,doPopulateTrx,itemCap)&#xD;
	{&#xD;
&#xD;
	/*&#xD;
	Version: 3.2&#xD;
&#xD;
	Usage:&#xD;
&#xD;
		licNum			:  Valid CA license number.   Non-alpha, max 8 characters.  If null, function will use the LPs on the supplied CAP ID&#xD;
		rlpType			:  License professional type to use when validating and creating new LPs&#xD;
		doPopulateRef 	:  If true, will create/refresh a reference LP of this number/type&#xD;
		doPopulateTrx 	:  If true, will copy create/refreshed reference LPs to the supplied Cap ID.   doPopulateRef must be true for this to work&#xD;
		itemCap			:  If supplied, licenses on the CAP will be validated.  Also will be refreshed if doPopulateRef and doPopulateTrx are true&#xD;
&#xD;
	returns: non-null string of status codes for invalid licenses&#xD;
&#xD;
	examples:&#xD;
&#xD;
	appsubmitbefore   (will validate the LP entered, if any, and cancel the event if the LP is inactive, cancelled, expired, etc.)&#xD;
	===============&#xD;
	true ^ cslbMessage = &quot;&quot;;&#xD;
	CAELienseNumber ^ cslbMessage = externalLP_CA(CAELienseNumber,false,false,CAELienseType,null);&#xD;
	cslbMessage.length &gt; 0 ^ cancel = true ; showMessage = true ; comment(cslbMessage)&#xD;
&#xD;
	appsubmitafter  (update all CONTRACTOR LPs on the CAP and REFERENCE with data from CSLB.  Link the CAP LPs to REFERENCE.   Pop up a message if any are inactive...)&#xD;
	==============&#xD;
	true ^ 	cslbMessage = externalLP_CA(null,true,true,&quot;CONTRACTOR&quot;,capId)&#xD;
	cslbMessage.length &gt; 0 ^ showMessage = true ; comment(cslbMessage);&#xD;
&#xD;
	Note;  Custom LP Template Field Mappings can be edited in the script below&#xD;
	*/&#xD;
&#xD;
	var returnMessage = &quot;&quot;;&#xD;
&#xD;
	var workArray = new Array();&#xD;
	if (licNum)&#xD;
		workArray.push(String(licNum));&#xD;
&#xD;
	if (itemCap)&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(itemCap);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{&#xD;
			var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
		if (capLicenseArr == null || !capLicenseArr.length)&#xD;
			{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); }&#xD;
		else&#xD;
			{&#xD;
			for (var thisLic in capLicenseArr)&#xD;
				if (capLicenseArr[thisLic].getLicenseType() == rlpType)&#xD;
					workArray.push(capLicenseArr[thisLic]);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		doPopulateTrx = false; // can't do this without a CAP;&#xD;
&#xD;
	for (var thisLic = 0; thisLic &lt; workArray.length; thisLic++)&#xD;
		{&#xD;
		var licNum = workArray[thisLic];&#xD;
		var licObj = null;&#xD;
		var isObject = false;&#xD;
&#xD;
		if (typeof(licNum) == &quot;object&quot;)  // is this one an object or string?&#xD;
			{&#xD;
			licObj = licNum;&#xD;
			licNum = licObj.getLicenseNbr();&#xD;
			isObject = true;&#xD;
			}&#xD;
&#xD;
		// Make the call to the California State License Board&#xD;
&#xD;
        var saxBuilder = aa.proxyInvoker.newInstance(&quot;org.jdom.input.SAXBuilder&quot;).getOutput();&#xD;
        var aURLArgList = new Array()&#xD;
        aURLArgList[0] = &quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum;&#xD;
        var oURL = aa.proxyInvoker.newInstance(&quot;java.net.URL&quot;,aURLArgList).getOutput();&#xD;
        var document = saxBuilder.build(oURL); //(&quot;https://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + licNum);&#xD;
        var root = document.getRootElement();&#xD;
&#xD;
		var errorNode = root.getChild(&quot;Error&quot;);&#xD;
		if (errorNode)&#xD;
			{&#xD;
			logDebug(&quot;Error for license &quot; + licNum + &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;));&#xD;
			returnMessage+=&quot;License &quot; + licNum +  &quot; : &quot; + errorNode.getText().replace(/\+/g,&quot; &quot;) + &quot; &quot;;&#xD;
			continue;&#xD;
			}&#xD;
&#xD;
		var lpBiz = root.getChild(&quot;BusinessInfo&quot;);&#xD;
		var lpStatus = root.getChild(&quot;PrimaryStatus&quot;);&#xD;
		var lpClass = root.getChild(&quot;Classifications&quot;);&#xD;
		var lpBonds = root.getChild(&quot;ContractorBond&quot;);&#xD;
		var lpWC = root.getChild(&quot;WorkersComp&quot;);&#xD;
&#xD;
		// Primary Status&#xD;
		// 3 = expired, 10 = good, 11 = inactive, 1 = canceled.   We will ignore all but 10 and return text.&#xD;
		var stas = lpStatus.getChildren();&#xD;
		for (var i=0 ; i&lt;stas.size(); i++) {&#xD;
			var sta = stas.get(i);&#xD;
&#xD;
			if (sta.getAttribute(&quot;Code&quot;).getValue() != &quot;10&quot;)&#xD;
				returnMessage+=&quot;License:&quot; + licNum + &quot;, &quot; + sta.getAttribute(&quot;Desc&quot;).getValue() + &quot; &quot;;&#xD;
		}&#xD;
&#xD;
		if (doPopulateRef)  // refresh or create a reference LP&#xD;
			{&#xD;
			var updating = false;&#xD;
&#xD;
			// check to see if the licnese already exists...if not, create.&#xD;
&#xD;
			var newLic = getRefLicenseProf(licNum)&#xD;
&#xD;
			if (newLic)&#xD;
				{&#xD;
				updating = true;&#xD;
				logDebug(&quot;Updating existing Ref Lic Prof : &quot; + licNum);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
				}&#xD;
&#xD;
			if (isObject)  // update the reference LP with data from the transactional, if we have some.&#xD;
				{&#xD;
				if (licObj.getAddress1()) newLic.setAddress1(licObj.getAddress1());&#xD;
				if (licObj.getAddress2()) newLic.setAddress2(licObj.getAddress2());&#xD;
				if (licObj.getAddress3()) newLic.setAddress3(licObj.getAddress3());&#xD;
				if (licObj.getAgencyCode()) newLic.setAgencyCode(licObj.getAgencyCode());&#xD;
				if (licObj.getBusinessLicense()) newLic.setBusinessLicense(licObj.getBusinessLicense());&#xD;
				if (licObj.getBusinessName()) newLic.setBusinessName(licObj.getBusinessName());&#xD;
				if (licObj.getBusName2()) newLic.setBusinessName2(licObj.getBusName2());&#xD;
				if (licObj.getCity()) newLic.setCity(licObj.getCity());&#xD;
				if (licObj.getCityCode()) newLic.setCityCode(licObj.getCityCode());&#xD;
				if (licObj.getContactFirstName()) newLic.setContactFirstName(licObj.getContactFirstName());&#xD;
				if (licObj.getContactLastName()) newLic.setContactLastName(licObj.getContactLastName());&#xD;
				if (licObj.getContactMiddleName()) newLic.setContactMiddleName(licObj.getContactMiddleName());&#xD;
				if (licObj.getCountryCode()) newLic.setContryCode(licObj.getCountryCode());&#xD;
				if (licObj.getEmail()) newLic.setEMailAddress(licObj.getEmail());&#xD;
				if (licObj.getCountry()) newLic.setCountry(licObj.getCountry());&#xD;
				if (licObj.getEinSs()) newLic.setEinSs(licObj.getEinSs());&#xD;
				if (licObj.getFax()) newLic.setFax(licObj.getFax());&#xD;
				if (licObj.getFaxCountryCode()) newLic.setFaxCountryCode(licObj.getFaxCountryCode());&#xD;
				if (licObj.getHoldCode()) newLic.setHoldCode(licObj.getHoldCode());&#xD;
				if (licObj.getHoldDesc()) newLic.setHoldDesc(licObj.getHoldDesc());&#xD;
				if (licObj.getLicenseExpirDate()) newLic.setLicenseExpirationDate(licObj.getLicenseExpirDate());&#xD;
				if (licObj.getLastRenewalDate()) newLic.setLicenseLastRenewalDate(licObj.getLastRenewalDate());&#xD;
				if (licObj.getLicesnseOrigIssueDate()) newLic.setLicOrigIssDate(licObj.getLicesnseOrigIssueDate());&#xD;
				if (licObj.getPhone1()) newLic.setPhone1(licObj.getPhone1());&#xD;
				if (licObj.getPhone1CountryCode()) newLic.setPhone1CountryCode(licObj.getPhone1CountryCode());&#xD;
				if (licObj.getPhone2()) newLic.setPhone2(licObj.getPhone2());&#xD;
				if (licObj.getPhone2CountryCode()) newLic.setPhone2CountryCode(licObj.getPhone2CountryCode());&#xD;
				if (licObj.getSelfIns()) newLic.setSelfIns(licObj.getSelfIns());&#xD;
				if (licObj.getState()) newLic.setState(licObj.getState());&#xD;
				if (licObj.getSuffixName()) newLic.setSuffixName(licObj.getSuffixName());&#xD;
				if (licObj.getZip()) newLic.setZip(licObj.getZip());&#xD;
				}&#xD;
&#xD;
			// Now set data from the CSLB&#xD;
&#xD;
			if (lpBiz.getChild(&quot;Name&quot;).getText() != &quot;&quot;) newLic.setBusinessName(unescape(lpBiz.getChild(&quot;Name&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr1&quot;).getText() != &quot;&quot;) newLic.setAddress1(unescape(lpBiz.getChild(&quot;Addr1&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Addr2&quot;).getText() != &quot;&quot;) newLic.setAddress2(unescape(lpBiz.getChild(&quot;Addr2&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;City&quot;).getText() != &quot;&quot;) newLic.setCity(unescape(lpBiz.getChild(&quot;City&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;State&quot;).getText() != &quot;&quot;) newLic.setState(unescape(lpBiz.getChild(&quot;State&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;Zip&quot;).getText() != &quot;&quot;) newLic.setZip(unescape(lpBiz.getChild(&quot;Zip&quot;).getText()).replace(/\+/g,&quot; &quot;));&#xD;
			if (lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText() != &quot;&quot;) newLic.setPhone1(unescape(stripNN(lpBiz.getChild(&quot;BusinessPhoneNum&quot;).getText()).replace(/\+/g,&quot; &quot;)));&#xD;
			newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
			newLic.setAuditDate(sysDate);&#xD;
			newLic.setAuditID(currentUserID);&#xD;
			newLic.setAuditStatus(&quot;A&quot;);&#xD;
			newLic.setLicenseType(rlpType);&#xD;
			newLic.setLicState(&quot;CA&quot;);  // hardcode CA&#xD;
			newLic.setStateLicense(licNum);&#xD;
&#xD;
			if (lpBiz.getChild(&quot;IssueDt&quot;).getText()) newLic.setLicenseIssueDate(aa.date.parseDate(lpBiz.getChild(&quot;IssueDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ExpireDt&quot;).getText()) newLic.setLicenseExpirationDate(aa.date.parseDate(lpBiz.getChild(&quot;ExpireDt&quot;).getText()));&#xD;
			if (lpBiz.getChild(&quot;ReissueDt&quot;).getText()) newLic.setLicenseLastRenewalDate(aa.date.parseDate(lpBiz.getChild(&quot;ReissueDt&quot;).getText()));&#xD;
&#xD;
			var wcs = root.getChild(&quot;WorkersComp&quot;).getChildren();&#xD;
&#xD;
			for (var j=0 ; j&lt;wcs.size(); j++) {&#xD;
				wc = wcs.get(j);&#xD;
&#xD;
				if (wc.getAttribute(&quot;PolicyNo&quot;).getValue()) newLic.setWcPolicyNo(wc.getAttribute(&quot;PolicyNo&quot;).getValue());&#xD;
				if (wc.getAttribute(&quot;InsCoCde&quot;).getValue()) newLic.setWcInsCoCode(unescape(wc.getAttribute(&quot;InsCoCde&quot;).getValue()));&#xD;
				if (wc.getAttribute(&quot;WCEffDt&quot;).getValue()) newLic.setWcEffDate(aa.date.parseDate(wc.getAttribute(&quot;WCEffDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCExpDt&quot;).getValue()) newLic.setWcExpDate(aa.date.parseDate(wc.getAttribute(&quot;WCExpDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;WCCancDt&quot;).getValue()) newLic.setWcCancDate(aa.date.parseDate(wc.getAttribute(&quot;WCCancDt&quot;).getValue()))&#xD;
				if (wc.getAttribute(&quot;Exempt&quot;).getValue() == &quot;E&quot;) newLic.setWcExempt(&quot;Y&quot;); else newLic.setWcExempt(&quot;N&quot;);&#xD;
&#xD;
				break; // only use first&#xD;
				}&#xD;
&#xD;
			//&#xD;
			// Do the refresh/create and get the sequence number&#xD;
			//&#xD;
			if (updating)&#xD;
				{&#xD;
				var myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
				var licSeqNbr = newLic.getLicSeqNbr();&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				var myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
				if (!myResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;**WARNING: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
					continue;&#xD;
					}&#xD;
&#xD;
				var licSeqNbr = myResult.getOutput()&#xD;
				}&#xD;
&#xD;
			logDebug(&quot;Successfully added/updated License No. &quot; + licNum + &quot;, Type: &quot; + rlpType + &quot; Sequence Number &quot; + licSeqNbr);&#xD;
&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data -- first copy from the transactional LP if it exists&#xD;
			/////&#xD;
&#xD;
&#xD;
			if (isObject)  // update the reference LP with attributes from the transactional, if we have some.&#xD;
				{&#xD;
				var attrArray = licObj.getAttributes();&#xD;
&#xD;
				if (attrArray)&#xD;
					{&#xD;
					for (var k in attrArray)&#xD;
						{&#xD;
						var attr = attrArray[k];&#xD;
						editRefLicProfAttribute(licNum,attr.getAttributeName(),attr.getAttributeValue());&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
&#xD;
			/////&#xD;
			/////  Attribute Data&#xD;
			/////&#xD;
			/////  NOTE!  Agencies may have to configure template data below based on their configuration.  Please note all edits&#xD;
			/////&#xD;
&#xD;
			var cbs = root.getChild(&quot;Classifications&quot;).getChildren();&#xD;
			for (var m=0 ; m&lt;cbs.size(); m++) {&#xD;
				cb = cbs.get(m);&#xD;
&#xD;
				if (m == 0)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 1&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 1&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 1)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 2&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 2&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				if (m == 2)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 3&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 3&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
&#xD;
				if (m == 3)&#xD;
					{&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS CODE 4&quot;,cb.getAttribute(&quot;Code&quot;).getValue());&#xD;
					editRefLicProfAttribute(licNum,&quot;CLASS DESC 4&quot;,unescape(cb.getAttribute(&quot;Desc&quot;).getValue()).replace(/\+/g,&quot; &quot;));&#xD;
					}&#xD;
				}&#xD;
&#xD;
			var bos = root.getChild(&quot;ContractorBond&quot;).getChildren();&#xD;
&#xD;
			for (var n=0 ; n&lt;bos.size(); n++) {&#xD;
				var bo = bos.get(n);&#xD;
				if (bo.getAttribute(&quot;BondAmt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND AMOUNT&quot;,unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()));&#xD;
				if (bo.getAttribute(&quot;BondCancDt&quot;).getValue()) editRefLicProfAttribute(licNum,&quot;BOND EXPIRATION&quot;,unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()));&#xD;
&#xD;
				// Currently unused but could be loaded into custom attributes.&#xD;
/*&#xD;
				aa.print(&quot;Bond Surety Type       : &quot; + unescape(bo.getAttribute(&quot;SuretyTp&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Code              : &quot; + unescape(bo.getAttribute(&quot;InsCoCde&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Insurance Company : &quot; + unescape(bo.getAttribute(&quot;InsCoName&quot;).getValue()).replace(/\+/g,&quot; &quot;))&#xD;
				aa.print(&quot;Bond Number            : &quot; + unescape(bo.getAttribute(&quot;BondNo&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Amount            : &quot; + unescape(bo.getAttribute(&quot;BondAmt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Effective Date    : &quot; + unescape(bo.getAttribute(&quot;BondEffDt&quot;).getValue()))&#xD;
				aa.print(&quot;Bond Cancel Date       : &quot; + unescape(bo.getAttribute(&quot;BondCancDt&quot;).getValue()))&#xD;
*/&#xD;
				break; // only use first bond&#xD;
				}&#xD;
&#xD;
			if (doPopulateTrx)&#xD;
				{&#xD;
				var lpsmResult = aa.licenseScript.getRefLicenseProfBySeqNbr(servProvCode,licSeqNbr)&#xD;
					if (!lpsmResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING error retrieving the LP just created &quot; + lpsmResult.getErrorMessage()) ; }&#xD;
&#xD;
				var lpsm = lpsmResult.getOutput();&#xD;
&#xD;
				// Remove from CAP&#xD;
&#xD;
				var isPrimary = false;&#xD;
&#xD;
				for (var currLic in capLicenseArr)&#xD;
					{&#xD;
					var thisLP = capLicenseArr[currLic];&#xD;
					if (thisLP.getLicenseType() == rlpType &amp;&amp; thisLP.getLicenseNbr() == licNum)&#xD;
						{&#xD;
						logDebug(&quot;Removing license: &quot; + thisLP.getLicenseNbr() + &quot; from CAP.  We will link the new reference LP&quot;);&#xD;
						if (thisLP.getPrintFlag() == &quot;Y&quot;)&#xD;
							{&#xD;
							logDebug(&quot;...remove primary status...&quot;);&#xD;
							isPrimary = true;&#xD;
							thisLP.setPrintFlag(&quot;N&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisLP);&#xD;
							}&#xD;
						var remCapResult = aa.licenseProfessional.removeLicensedProfessional(thisLP);&#xD;
						if (capLicenseResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;...Success.&quot;); }&#xD;
						else&#xD;
							{ logDebug(&quot;**WARNING removing lic prof: &quot; + remCapResult.getErrorMessage()); }&#xD;
						}&#xD;
					}&#xD;
&#xD;
				// add the LP to the CAP&#xD;
				var asCapResult= aa.licenseScript.associateLpWithCap(itemCap,lpsm)&#xD;
				if (!asCapResult.getSuccess())&#xD;
				{ logDebug(&quot;**WARNING error associating CAP to LP: &quot; + asCapResult.getErrorMessage()) }&#xD;
				else&#xD;
					{ logDebug(&quot;Associated the CAP to the new LP&quot;) }&#xD;
&#xD;
				// Now make the LP primary again&#xD;
				if (isPrimary)&#xD;
					{&#xD;
					var capLps = getLicenseProfessional(itemCap);&#xD;
&#xD;
					for (var thisCapLpNum in capLps)&#xD;
						{&#xD;
						if (capLps[thisCapLpNum].getLicenseNbr().equals(licNum))&#xD;
							{&#xD;
							var thisCapLp = capLps[thisCapLpNum];&#xD;
							thisCapLp.setPrintFlag(&quot;Y&quot;);&#xD;
							aa.licenseProfessional.editLicensedProfessional(thisCapLp);&#xD;
							logDebug(&quot;Updated primary flag on Cap LP : &quot; + licNum);&#xD;
&#xD;
							// adding this return will cause the test script to work without error, even though this is the last statement executed&#xD;
							//if (returnMessage.length &gt; 0) return returnMessage;&#xD;
							//else return null;&#xD;
&#xD;
							}&#xD;
						}&#xD;
				}&#xD;
			} // do populate on the CAP&#xD;
		} // do populate on the REF&#xD;
	} // for each license&#xD;
&#xD;
	if (returnMessage.length &gt; 0) return returnMessage;&#xD;
	else return null;&#xD;
&#xD;
} // end function&#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	}&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
function feeCopyByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			 addFee(ffeObjArr[ff].getFeeCod(),  ffeObjArr[ff].getFeeSchudle() ,  ffeObjArr[ff].getPaymentPeriod() ,  ffeObjArr[ff].getFeeUnit() ,    'Y') &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
function getChildTasks(taskName) {&#xD;
    var childTasks = new Array();&#xD;
    var childId = null;&#xD;
    var itemCap = capId&#xD;
    if (arguments.length &gt; 1)&#xD;
        itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
    var wfObj = workflowResult.getOutput();&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getTaskDescription().equals(taskName)) {&#xD;
            var relationArray = aa.workflow.getProcessRelationByCapID(itemCap, null).getOutput()&#xD;
            for (thisRel in relationArray) {&#xD;
                y = relationArray[thisRel]&#xD;
                if (y.getParentTaskName() &amp;&amp; y.getParentTaskName().equals(fTaskSM.getTaskDescription()))&#xD;
                    childId = y.getProcessID()&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
&#xD;
    for (i in wfObj) {&#xD;
        var fTaskSM = wfObj[i];&#xD;
        if (fTaskSM.getProcessID() == childId)&#xD;
            childTasks.push(fTaskSM)&#xD;
    }&#xD;
&#xD;
    return childTasks;&#xD;
&#xD;
}&#xD;
&#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0];&#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // we are in a page flow script so use the capModel to get contacts&#xD;
		{&#xD;
		capContactArray = cap.getContactsGroup().toArray() ;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var capContactArray = capContactResult.getOutput();&#xD;
			}&#xD;
		}&#xD;
	&#xD;
	if (capContactArray)&#xD;
		{&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;middleName&quot;] = capContactArray[yy].getPeople().middleName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;&#xD;
&#xD;
			if (arguments.length == 0 &amp;&amp; !cap.isCompleteCap()) // using capModel to get contacts&#xD;
				var pa = capContactArray[yy].getPeople().getAttributes().toArray();&#xD;
			else&#xD;
				var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);&#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}&#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
  function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
function getLastScheduledInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector that is assigned to the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function getLicenseProfessional(itemcapId)&#xD;
{&#xD;
	capLicenseArr = null;&#xD;
	var s_result = aa.licenseProfessional.getLicenseProf(itemcapId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capLicenseArr = s_result.getOutput();&#xD;
		if (capLicenseArr == null || capLicenseArr.length == 0)&#xD;
		{&#xD;
			aa.print(&quot;WARNING: no licensed professionals on this CAP:&quot; + itemcapId);&#xD;
			capLicenseArr = null;&#xD;
		}&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to license professional: &quot; + s_result.getErrorMessage());&#xD;
		capLicenseArr = null;&#xD;
	}&#xD;
	return capLicenseArr;&#xD;
}&#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; newLicArray[thisLic] &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
}&#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    }&#xD;
&#xD;
function isReadyRenew(capid) {&#xD;
    if (capid == null || aa.util.instanceOfString(capid)) {&#xD;
        return false;&#xD;
    }&#xD;
    var result = aa.expiration.isExpiredLicenses(capid);&#xD;
    if (result.getSuccess()) {&#xD;
        return true;&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Failed to get expiration with CAP(&quot; + capid + &quot;): &quot; + result.getErrorMessage());&#xD;
    }&#xD;
    return false;&#xD;
}&#xD;
&#xD;
function isRenewProcess(parentCapID, partialCapID) {&#xD;
    //1. Check to see parent CAP ID is null.&#xD;
    if (parentCapID == null || partialCapID == null)&#xD;
    { logDebug(&quot;ERROR: the parentCapID or the partialCap ID is null&quot;); return false; }&#xD;
    //2. Get CAPModel by PK for partialCAP.&#xD;
    var result = aa.cap.getCap(partialCapID);&#xD;
    if (result.getSuccess()) {&#xD;
        capScriptModel = result.getOutput();&#xD;
        //2.1. Check to see if it is partial CAP.&#xD;
        if (capScriptModel.isCompleteCap()) {&#xD;
            logDebug(&quot;ERROR: It is not partial CAP(&quot; + capScriptModel.getCapID() + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
    }&#xD;
    else {&#xD;
        logDebug(&quot;ERROR: Fail to get CAPModel (&quot; + partialCapID + &quot;): &quot; + result.getErrorMessage());&#xD;
        return false;&#xD;
    }&#xD;
    //3.  Check to see if the renewal was initiated before.&#xD;
    result = aa.cap.getProjectByMasterID(parentCapID, &quot;Renewal&quot;, &quot;Incomplete&quot;);&#xD;
    if (result.getSuccess()) {&#xD;
        partialProjects = result.getOutput();&#xD;
        if (partialProjects != null &amp;&amp; partialProjects.length &gt; 0) {&#xD;
            //Avoid to initiate renewal process multiple times.&#xD;
            logDebug(&quot;Warning: Renewal process was initiated before. ( &quot; + parentCapID + &quot;)&quot;);&#xD;
            return false;&#xD;
        }&#xD;
&#xD;
    }&#xD;
    //4 . Check to see if parent CAP is ready for renew.&#xD;
    return isReadyRenew(parentCapID);&#xD;
}&#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
function licenseObject(licnumber)  // optional renewal Cap ID -- uses the expiration on the renewal CAP.&#xD;
	{&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
&#xD;
   	b1ExpResult = aa.expiration.getLicensesByCapID(itemCap)&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
			tmpDate = this.b1Exp.getExpDate();&#xD;
			if (tmpDate)&#xD;
				this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
			this.b1Status = this.b1Exp.getExpStatus();&#xD;
			logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + b1ExpResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function loadAddressAttributes(thisArr)&#xD;
{&#xD;
	//&#xD;
	// Returns an associative array of Address Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapAddressObj = null;&#xD;
   	var capAddressResult = aa.address.getAddressWithAttributeByCapId(itemCap);&#xD;
   	if (capAddressResult.getSuccess())&#xD;
   		var fcapAddressObj = capAddressResult.getOutput();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Address object: &quot; + capAddressResult.getErrorType() + &quot;:&quot; + capAddressResult.getErrorMessage())&#xD;
&#xD;
  	for (i in fcapAddressObj)&#xD;
  	{&#xD;
  		addressAttrObj = fcapAddressObj[i].getAttributes().toArray();&#xD;
  		for (z in addressAttrObj)&#xD;
			thisArr[&quot;AddressAttribute.&quot; + addressAttrObj[z].getB1AttributeName()]=addressAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;AddressAttribute.PrimaryFlag&quot;] = fcapAddressObj[i].getPrimaryFlag();&#xD;
		thisArr[&quot;AddressAttribute.HouseNumberStart&quot;] = fcapAddressObj[i].getHouseNumberStart();&#xD;
		thisArr[&quot;AddressAttribute.StreetDirection&quot;] = fcapAddressObj[i].getStreetDirection();&#xD;
		thisArr[&quot;AddressAttribute.StreetName&quot;] = fcapAddressObj[i].getStreetName();&#xD;
		thisArr[&quot;AddressAttribute.StreetSuffix&quot;] = fcapAddressObj[i].getStreetSuffix();&#xD;
		thisArr[&quot;AddressAttribute.City&quot;] = fcapAddressObj[i].getCity();&#xD;
		thisArr[&quot;AddressAttribute.State&quot;] = fcapAddressObj[i].getState();&#xD;
		thisArr[&quot;AddressAttribute.Zip&quot;] = fcapAddressObj[i].getZip();&#xD;
		thisArr[&quot;AddressAttribute.AddressStatus&quot;] = fcapAddressObj[i].getAddressStatus();&#xD;
		thisArr[&quot;AddressAttribute.County&quot;] = fcapAddressObj[i].getCounty();&#xD;
		thisArr[&quot;AddressAttribute.Country&quot;] = fcapAddressObj[i].getCountry();&#xD;
		thisArr[&quot;AddressAttribute.AddressDescription&quot;] = fcapAddressObj[i].getAddressDescription();&#xD;
		thisArr[&quot;AddressAttribute.XCoordinate&quot;] = fcapAddressObj[i].getXCoordinator();&#xD;
		thisArr[&quot;AddressAttribute.YCoordinate&quot;] = fcapAddressObj[i].getYCoordinator();&#xD;
  	}&#xD;
}&#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
      var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		var readOnly = 'N';&#xD;
		if (readOnlyi.hasNext()) {&#xD;
			readOnly = readOnlyi.next();&#xD;
		}&#xD;
		var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
		tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
		}&#xD;
		tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	}&#xD;
&#xD;
&#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
	  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator(); // get Readonly filed&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
				}&#xD;
&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
			//tempObject[tcol.getColumnName()] = tval;&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  logDebug(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
function loadASITablesBefore() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	//&#xD;
&#xD;
	var gm =  aa.env.getValue(&quot;AppSpecificTableGroupModel&quot;);&#xD;
	var ta = gm.getTablesMap().values()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
 	  var numrows = 0;&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
	  if (!tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
		  var tsmfldi = tsm.getTableField().iterator();&#xD;
		  var tsmcoli = tsm.getColumns().iterator();&#xD;
		  var readOnlyi = tsm.getAppSpecificTableModel().getReadonlyField().iterator();&#xD;
&#xD;
		  var numrows = 1;&#xD;
&#xD;
		  while (tsmfldi.hasNext())  // cycle through fields&#xD;
			{&#xD;
			if (!tsmcoli.hasNext())  // cycle through columns&#xD;
				{&#xD;
&#xD;
				var tsmcoli = tsm.getColumns().iterator();&#xD;
				tempArray.push(tempObject);  // end of record&#xD;
				var tempObject = new Array();  // clear the temp obj&#xD;
				numrows++;&#xD;
				}&#xD;
			var tcol = tsmcoli.next();&#xD;
			var tval = tsmfldi.next();&#xD;
			var readOnly = 'N';&#xD;
			if (readOnlyi.hasNext()) {&#xD;
				readOnly = readOnlyi.next();&#xD;
			}&#xD;
			var fieldInfo = new asiTableValObj(tcol.getColumnName(), tval, readOnly);&#xD;
			tempObject[tcol.getColumnName()] = fieldInfo;&#xD;
&#xD;
			}&#xD;
&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
		}&#xD;
&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
          eval(copyStr);  // move to table name&#xD;
&#xD;
	  }&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + feeResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
&#xD;
function loadGuideSheetItems(inspId) {&#xD;
	//&#xD;
	// Returns an associative array of Guide Sheet Items&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var retArray = new Array()&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var r = aa.inspection.getInspections(itemCap)&#xD;
&#xD;
	if (r.getSuccess())&#xD;
	 	{&#xD;
		var inspArray = r.getOutput();&#xD;
&#xD;
		for (i in inspArray)&#xD;
			{&#xD;
			if (inspArray[i].getIdNumber() == inspId)&#xD;
				{&#xD;
				var inspModel = inspArray[i].getInspection();&#xD;
&#xD;
				var gs = inspModel.getGuideSheets()&#xD;
&#xD;
				if (gs)&#xD;
					{&#xD;
					gsArray = gs.toArray();&#xD;
					for (var loopk in gsArray)&#xD;
						{&#xD;
						var gsItems = gsArray[loopk].getItems().toArray()&#xD;
						for (var loopi in gsItems)&#xD;
							retArray[gsItems[loopi].getGuideItemText()] = gsItems[loopi].getGuideItemStatus();&#xD;
						}&#xD;
					} // if there are guidesheets&#xD;
				else&#xD;
					logDebug(&quot;No guidesheets for this inspection&quot;);&#xD;
				} // if this is the right inspection&#xD;
			} // for each inspection&#xD;
		} // if there are inspections&#xD;
&#xD;
	logDebug(&quot;loaded &quot; + retArray.length + &quot; guidesheet items&quot;);&#xD;
	return retArray;&#xD;
	}&#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + (fTask.getStatusDate().getMonth() + 1) + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}&#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
function logDebug(dstr) {&#xD;
&#xD;
    if (!aa.calendar.getNextWorkDay) {&#xD;
&#xD;
		vLevel = 1&#xD;
		if (arguments.length &gt; 1)&#xD;
			vLevel = arguments[1]&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel || vLevel == 1)&#xD;
			debug += dstr + br;&#xD;
&#xD;
		if ((showDebug &amp; vLevel) == vLevel)&#xD;
			aa.debug(aa.getServiceProviderCode() + &quot; : &quot; + aa.env.getValue(&quot;CurrentUserID&quot;), dstr)&#xD;
		}&#xD;
	else {&#xD;
			debug+=dstr + br;&#xD;
		}&#xD;
&#xD;
}&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
function lookupFeesByValuationSlidingScale(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 2;&#xD;
	if (arguments.length == 4) valNumber = (arguments[3] + 1);&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
                        &#xD;
                        &#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 2)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					var divisor = workVals[1];&#xD;
					saveVal = parseInt((capval - workVals[0])/divisor);&#xD;
					if ((capval - workVals[0]) % divisor &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
function parcelExistsOnCap()&#xD;
{&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in fcapParcelObj)&#xD;
	{&#xD;
		return true;&#xD;
	}&#xD;
&#xD;
	return false;&#xD;
}&#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
function prepareRenewal() {&#xD;
&#xD;
    if (isRenewProcess(parentCapId, capId)) {&#xD;
        logDebug(&quot;CAPID(&quot; + parentCapId + &quot;) is ready for renew. PartialCap (&quot; + capId + &quot;)&quot;);&#xD;
&#xD;
        //Associate partial cap with parent CAP.&#xD;
        var result = aa.cap.createRenewalCap(parentCapId, capId, true);&#xD;
        if (result.getSuccess()) {&#xD;
            // Set B1PERMIT.B1_ACCESS_BY_ACA to &quot;N&quot; for partial CAP to not allow that it is searched by ACA user.&#xD;
            aa.cap.updateAccessByACA(capId, &quot;N&quot;);&#xD;
        }&#xD;
        else&#xD;
        { logDebug(&quot;ERROR: Associate partial cap with parent CAP. &quot; + result.getErrorMessage()); return false };&#xD;
&#xD;
        return true;&#xD;
    }&#xD;
    else&#xD;
    { logDebug(&quot;Renewal Process did not finish properly&quot;); return false; }&#xD;
}&#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	}&#xD;
&#xD;
function removeAllFees(itemCap) // Removes all non-invoiced fee items for a CAP ID&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByCapID(itemCap);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
&#xD;
				var editResult = aa.finance.removeFeeItem(itemCap, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + feeList[feeNum].getFeeCod());&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+feeList[feeNum].getFeeCod()+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + feeList[feeNum].getFeeCod() + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
	}&#xD;
&#xD;
	function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 1)&#xD;
		itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.removeAppSpecificTableInfos(tableName,itemCap,currentUserID)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ aa.print(&quot;**WARNING: error removing ASI table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
        else&#xD;
	logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function replaceMessageTokens(m)&#xD;
	{&#xD;
	//  tokens in pipes will attempt to interpret as script variables&#xD;
	//  tokens in curly braces will attempt to replace from AInfo (ASI, etc)&#xD;
	//&#xD;
	//  e.g.   |capId|  or |wfTask|  or |wfStatus|&#xD;
	//&#xD;
	//  e.g.   {Expiration Date}  or  {Number of Electrical Outlets}&#xD;
	//&#xD;
	//  e.g.   m = &quot;Your recent license application (|capIdString|) has successfully passed |wfTask| with a status of |wfStatus|&quot;&#xD;
&#xD;
	while (m.indexOf(&quot;|&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;|&quot;)&#xD;
	  var e = m.indexOf(&quot;|&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;typeof(&quot; + r + &quot;) != \&quot;undefined\&quot; ? &quot; + r + &quot; : \&quot;undefined\&quot;&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\|&quot; + r + &quot;\\|&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
	  }&#xD;
&#xD;
	while (m.indexOf(&quot;{&quot;))&#xD;
	  {&#xD;
	  var s = m.indexOf(&quot;{&quot;)&#xD;
	  var e = m.indexOf(&quot;}&quot;,s+1)&#xD;
	  if (e &lt;= 0) break; // unmatched&#xD;
	  var r = m.substring(s+1,e)&#xD;
&#xD;
	  var evalstring = &quot;AInfo[\&quot;&quot; + r + &quot;\&quot;]&quot;&#xD;
	  var v = eval(evalstring)&#xD;
	  var pattern = new RegExp(&quot;\\{&quot; + r + &quot;\\}&quot;,&quot;g&quot;)&#xD;
	  m = String(m).replace(pattern,v)&#xD;
&#xD;
	  }&#xD;
&#xD;
	 return m&#xD;
	 }&#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID.&#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm&#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3)&#xD;
		if (arguments[2] != null)&#xD;
			{&#xD;
			var inspRes = aa.person.getUser(arguments[2]);&#xD;
			if (inspRes.getSuccess())&#xD;
				inspectorObj = inspRes.getOutput();&#xD;
			}&#xD;
&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
&#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
function stripNN(fullStr) {&#xD;
    var allowed = &quot;0123456789.&quot;;&#xD;
    var stripped = &quot;&quot;;&#xD;
    for (i = 0; i &lt; fullStr.length(); i++)&#xD;
        if (allowed.indexOf(String.fromCharCode(fullStr.charAt(i))) &gt;= 0)&#xD;
        stripped += String.fromCharCode(fullStr.charAt(i))&#xD;
    return stripped;&#xD;
}&#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*&#xD;
DQ 09/03/2009 - Added Check to ensure Task status date is not null prior to getting status date&#xD;
Function will return false on fail&#xD;
*/&#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
	            if (fTask.getStatusDate() != null)&#xD;
	                return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
	            else&#xD;
	                { logMessage(&quot;**ERROR: NULL workflow task &quot;+fTask.getTaskDescription()+&quot; status date. &quot;); return false; }&#xD;
		}&#xD;
	}&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap, &quot;APPLICATION&quot;, stat, sysDate, cmt, systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
}&#xD;
&#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq)&#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
    // 12/22/2008 - DQ - Correct Invoice loop to accumulate instead of reset each iteration&#xD;
&#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)&#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
&#xD;
    var invFeeFound=false;&#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = adjustedQty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) )&#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
&#xD;
	return feeSeq;&#xD;
	}&#xD;
&#xD;
&#xD;
function updateRefParcelToCap() //Takes Optional CapId&#xD;
{&#xD;
	var vCapId = null;&#xD;
	if (arguments.length &gt; 0)&#xD;
		vCapId = arguments[0];&#xD;
	else&#xD;
		vCapId = capId;&#xD;
&#xD;
    var capPrclArr = aa.parcel.getParcelDailyByCapID(vCapId,null).getOutput();&#xD;
    if(capPrclArr != null)&#xD;
    {&#xD;
        for (x in capPrclArr)&#xD;
        {&#xD;
	        var prclObj = aa.parcel.getParceListForAdmin(capPrclArr[x].getParcelNumber(), null, null, null, null, null, null, null, null, null);&#xD;
	        if (prclObj.getSuccess() )&#xD;
	        {&#xD;
		        var prclArr = prclObj.getOutput();&#xD;
		        if (prclArr.length)&#xD;
		        {&#xD;
			        var prcl = prclArr[0].getParcelModel();&#xD;
			        var capPrclObj = aa.parcel.warpCapIdParcelModel2CapParcelModel(vCapId, prcl);&#xD;
&#xD;
			        if (capPrclObj.getSuccess())&#xD;
			        {&#xD;
&#xD;
				        var capPrcl = capPrclObj.getOutput();&#xD;
				        aa.parcel.updateDailyParcelWithAPOAttribute(capPrcl);	&#xD;
				        logDebug(&quot;Updated Parcel &quot; + capPrclArr[x].getParcelNumber() + &quot; with Reference Data&quot;);&#xD;
			        }&#xD;
			        else&#xD;
				        logDebug(&quot;Failed to Wrap Parcel Model for &quot; + capPrclArr[x].getParcelNumber());&#xD;
&#xD;
		        }&#xD;
		        else&#xD;
			        logDebug(&quot;No matching reference Parcels found for &quot; + capPrclArr[x].getParcelNumber());&#xD;
	        }&#xD;
	        else&#xD;
		        logDebug(&quot;Failed to get reference Parcel for &quot; + capPrclArr[x].getParcelNumber())&#xD;
	    }&#xD;
	}&#xD;
}&#xD;
&#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	}&#xD;
&#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function updateTaskDepartment(wfstr,wfDepartment) // optional process name&#xD;
	{&#xD;
	// Update the task assignment department&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
        var assignBureau = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[2];&#xD;
	var assignDivision = &quot;&quot; + wfDepartment.split(&quot;/&quot;)[3];&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
        for (var i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
                if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
 			{&#xD;
			if (wfDepartment)&#xD;
				{&#xD;
				var taskUserObj = fTask.getTaskItem().getAssignedUser()&#xD;
				taskUserObj.setBureauCode(assignBureau);&#xD;
				taskUserObj.setDivisionCode(assignDivision);&#xD;
				fTask.setAssignedUser(taskUserObj);&#xD;
        			var taskItem = fTask.getTaskItem();&#xD;
&#xD;
				var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Department Set to &quot; + assignBureau);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update Department.  Invalid department : &quot; + assignBureau);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel()&#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
&#xD;
	}&#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}&#xD;
&#xD;
&#xD;
function getParentCapIDForReview(capid)&#xD;
{&#xD;
	if (capid == null || aa.util.instanceOfString(capid))&#xD;
	{&#xD;
		return null;&#xD;
	}&#xD;
	//1. Get parent license for review&#xD;
	var result = aa.cap.getProjectByChildCapID(capid, &quot;Renewal&quot;, &quot;Complete&quot;);//&quot;Complete&quot; was&quot;Review&quot;&#xD;
    if(result.getSuccess())&#xD;
	{&#xD;
		projectScriptModels = result.getOutput();&#xD;
		if (projectScriptModels == null || projectScriptModels.length == 0)&#xD;
		{&#xD;
			logDebug(&quot;ERROR: Failed to get parent CAP with CAPID(&quot; + capid + &quot;) for review&quot;);&#xD;
			return null;&#xD;
		}&#xD;
		//2. return parent CAPID.&#xD;
		projectScriptModel = projectScriptModels[0];&#xD;
		return projectScriptModel.getProjectID();&#xD;
	}  &#xD;
    else &#xD;
    {&#xD;
      logDebug(&quot;ERROR: Failed to get parent CAP by child CAP(&quot; + capid + &quot;) for review: &quot; + result.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
}</content><initializer></initializer><title>PAYMENTRECEIVEAFTER</title></script><scriptName>PaymentReceiveAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>V360InspectionResultSubmitAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:55:33.783-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>V360InspectionResultSubmitAfter</name><auditModel><auditDate>2008-02-16T19:36:39-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after result inspection.</description></event><scriptName>V360InspectionResultSubmitAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>VoidFeeAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-17T07:56:12.683-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>VoidFeeAfter</name><auditModel><auditDate>2006-12-06T11:33:17-07:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after voiding fee(manually or automatically)</description></event><script><name>VOIDFEEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2010-04-06T07:15:32.090-06:00</auditDate><auditID>ADMIN</auditID><auditStatus>A</auditStatus></auditModel><content> var showMessage = true;				// Set to true to see results in popup window&#xD;var showDebug = true;				// Set to true to see debug messages in popup window&#xD;var message = &quot;&quot;;				// Message String&#xD;var debug = &quot;&quot;;					// Debug String&#xD;var br = &quot;&lt;BR&gt;&quot;;				// Break Tag&#xD;&#xD;var capId = getCapId();				// CapId object&#xD;var cap = aa.cap.getCap(capId).getOutput();	// Cap object&#xD;var capStatus = cap.getCapStatus();		// Cap status&#xD;var capType = cap.getCapType();     // Cap type&#xD;&#xD;var feeSeqListString = aa.env.getValue(&quot;FeeItemsSeqNbrArray&quot;);	// invoicing fee item list in string type&#xD;var feeSeqList = new Array();					// fee item list in number type&#xD;for(xx in feeSeqListString)&#xD;{&#xD;	feeSeqList.push(Number(feeSeqListString[xx])); 	// convert the string type array to number type array&#xD;}&#xD;&#xD;var paymentPeriodList = new Array();	// payment periods, system need not this parameter for daily side&#xD;&#xD;// The fee item should not belong to a POS before set the fee item status to &quot;CREDITED&quot;.&#xD;if (feeSeqList.length &amp;&amp; !(capStatus == '#POS' &amp;&amp; capType == '_PER_GROUP/_PER_TYPE/_PER_SUB_TYPE/_PER_CATEGORY'))&#xD;{&#xD;	// the following method will set the fee item status from 'VOIDED' to 'CREDITED' after void the fee item;&#xD;	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;	if (invoiceResult.getSuccess())&#xD;	{&#xD;		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;	}&#xD;	else&#xD;	{&#xD;		logDebug(&quot;ERROR: Invoicing the fee items assessed to app # &quot; + capId + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;	}&#xD;}&#xD;&#xD;if (debug.indexOf(&quot;ERROR&quot;) &gt; 0)&#xD;{&#xD;	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;}&#xD;else&#xD;{&#xD;	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;	if (showMessage) &#xD;	{&#xD;		aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;	}&#xD;	if (showDebug)&#xD;	{&#xD;		aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;	}&#xD;}&#xD;	&#xD;function getCapId()  {&#xD;&#xD;    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;&#xD;    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;    if(s_capResult.getSuccess())&#xD;    {&#xD;      return s_capResult.getOutput();&#xD;    }&#xD;    else&#xD;    {&#xD;      logDebug(&quot;ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;      return null;&#xD;    }&#xD;}&#xD;&#xD;function logDebug(dstr)&#xD;{&#xD;	debug += dstr + br;&#xD;}&#xD;	&#xD;function logMessage(dstr)&#xD;{&#xD;	message += dstr + br;&#xD;}	&#xD;&#xD;</content><title>VOIDFEEAFTER</title></script><scriptName>VOIDFEEAFTER</scriptName></agencyEvent>
<agencyEvent><eventName>WorkflowTaskUpdateAfter</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:56:56.763-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>WorkflowTaskUpdateAfter</name><auditModel><auditDate>2002-03-15T14:09:29-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs after a workflow task is updated.</description></event><script><name>WORKFLOWTASKUPDATEAFTER</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-02-06T21:18:39.120-07:00</auditDate><auditID>PMONTOYA</auditID><auditStatus>A</auditStatus></auditModel><content>/*------------------------------------------------------------------------------------------------------/&#xD;
| SVN $Id: WorkflowTaskUpdateAfter.js 3600 2008-10-27 21:36:24Z dane.quatacker $&#xD;
| Program : WorkflowTaskUpdateAfterV1.5.js&#xD;
| Event   : WorkflowTaskUpdateAfter&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   :&#xD;
|&#xD;
| Script Modified by: McKenzie Johnson/TruePoint Solutions - 02/02/2010 added function CheckSiblingTasksComplete to check sibling CAPs active workflow tasks.&#xD;
|	Revised function closeTask to have an optional parameter for capId&#xD;
|	Revised function addParcelCondition to work with XAPO&#xD;
        Miguel Gutierrez/City of El Paso - added function &quot;compareDate&quot;to compare sysdate against an specific date for real event #127&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var showMessage = false;						// Set to true to see results in popup window&#xD;
var showDebug = true;							// Set to true to see debug messages in popup window&#xD;
var controlString = &quot;WorkflowTaskUpdateAfter&quot;; 				// Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;				// Standard choice to execute first (for globals, etc)&#xD;
var documentOnly = false;						// Document Only -- displays hierarchy of std choice steps&#xD;
var disableTokens = false;						// turn off tokenizing of std choices (enables use of &quot;{} and []&quot;)&#xD;
var useAppSpecificGroupName = false;					// Use Group name when populating App Specific Info Values&#xD;
var useTaskSpecificGroupName = false;					// Use Group name when populating Task Specific Info Values&#xD;
var enableVariableBranching = false;					// Allows use of variable names in branching.  Branches are not followed in Doc Only&#xD;
var maxEntries = 99;							// Maximum number of std choice entries.  Entries must be Left Zero Padded&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var startDate = new Date();&#xD;
var startTime = startDate.getTime();&#xD;
var message =	&quot;&quot;;							// Message String&#xD;
var debug = &quot;&quot;;								// Debug String&#xD;
var br = &quot;&lt;BR&gt;&quot;;							// Break Tag&#xD;
var feeSeqList = new Array();						// invoicing fee list&#xD;
var paymentPeriodList = new Array();					// invoicing pay periods&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
&#xD;
var capId = getCapId();							// CapId object&#xD;
var cap = aa.cap.getCap(capId).getOutput();				// Cap object&#xD;
var servProvCode = capId.getServiceProviderCode()       		// Service Provider Code&#xD;
var currentUserID = aa.env.getValue(&quot;CurrentUserID&quot;);   		// Current User&#xD;
var capIDString = capId.getCustomID();					// alternate cap id string&#xD;
var systemUserObj = aa.person.getUser(currentUserID).getOutput();  	// Current User Object&#xD;
var appTypeResult = cap.getCapType();&#xD;
var appTypeString = appTypeResult.toString();				// Convert application type to string (&quot;Building/A/B/C&quot;)&#xD;
var appTypeArray = appTypeString.split(&quot;/&quot;);				// Array of application type string&#xD;
var currentUserGroup;&#xD;
var currentUserGroupObj = aa.userright.getUserRight(appTypeArray[0],currentUserID).getOutput()&#xD;
if (currentUserGroupObj) currentUserGroup = currentUserGroupObj.getGroupName();&#xD;
var capName = cap.getSpecialText();&#xD;
var capStatus = cap.getCapStatus();&#xD;
var fileDateObj = cap.getFileDate();					// File Date scriptdatetime&#xD;
var fileDate = &quot;&quot; + fileDateObj.getMonth() + &quot;/&quot; + fileDateObj.getDayOfMonth() + &quot;/&quot; + fileDateObj.getYear();&#xD;
var fileDateYYYYMMDD = dateFormatted(fileDateObj.getMonth(),fileDateObj.getDayOfMonth(),fileDateObj.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;YYYY-MM-DD&quot;);&#xD;
var parcelArea = 0;&#xD;
&#xD;
var estValue = 0; var calcValue = 0; var feeFactor			// Init Valuations&#xD;
var valobj = aa.finance.getContractorSuppliedValuation(capId,null).getOutput();	// Calculated valuation&#xD;
if (valobj.length) {&#xD;
	estValue = valobj[0].getEstimatedValue();&#xD;
	calcValue = valobj[0].getCalculatedValue();&#xD;
	feeFactor = valobj[0].getbValuatn().getFeeFactorFlag();&#xD;
	}&#xD;
&#xD;
var balanceDue = 0 ; var houseCount = 0; feesInvoicedTotal = 0;		// Init detail Data&#xD;
var capDetail = &quot;&quot;;&#xD;
var capDetailObjResult = aa.cap.getCapDetail(capId);			// Detail&#xD;
if (capDetailObjResult.getSuccess())&#xD;
	{&#xD;
	capDetail = capDetailObjResult.getOutput();&#xD;
	var houseCount = capDetail.getHouseCount();&#xD;
	var feesInvoicedTotal = capDetail.getTotalFee();&#xD;
	var balanceDue = capDetail.getBalance();&#xD;
	}&#xD;
&#xD;
var AInfo = new Array();						// Create array for tokenized variables&#xD;
loadAppSpecific(AInfo); 						// Add AppSpecific Info&#xD;
loadTaskSpecific(AInfo);						// Add task specific info&#xD;
loadParcelAttributes(AInfo);						// Add parcel attributes&#xD;
loadASITables();&#xD;
&#xD;
logDebug(&quot;&lt;B&gt;EMSE Script Results for &quot; + capIDString + &quot;&lt;/B&gt;&quot;);&#xD;
logDebug(&quot;capId = &quot; + capId.getClass());&#xD;
logDebug(&quot;cap = &quot; + cap.getClass());&#xD;
logDebug(&quot;currentUserID = &quot; + currentUserID);&#xD;
logDebug(&quot;currentUserGroup = &quot; + currentUserGroup);&#xD;
logDebug(&quot;systemUserObj = &quot; + systemUserObj.getClass());&#xD;
logDebug(&quot;appTypeString = &quot; + appTypeString);&#xD;
logDebug(&quot;capName = &quot; + capName);&#xD;
logDebug(&quot;capStatus = &quot; + capStatus);&#xD;
logDebug(&quot;fileDate = &quot; + fileDate);&#xD;
logDebug(&quot;fileDateYYYYMMDD = &quot; + fileDateYYYYMMDD);&#xD;
logDebug(&quot;sysDate = &quot; + sysDate.getClass());&#xD;
logDebug(&quot;sysDateMMDDYYYY = &quot; + sysDateMMDDYYYY);&#xD;
logDebug(&quot;parcelArea = &quot; + parcelArea);&#xD;
logDebug(&quot;estValue = &quot; + estValue);&#xD;
logDebug(&quot;calcValue = &quot; + calcValue);&#xD;
logDebug(&quot;feeFactor = &quot; + feeFactor);&#xD;
&#xD;
logDebug(&quot;houseCount = &quot; + houseCount);&#xD;
logDebug(&quot;feesInvoicedTotal = &quot; + feesInvoicedTotal);&#xD;
logDebug(&quot;balanceDue = &quot; + balanceDue);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var wfTask = aa.env.getValue(&quot;WorkflowTask&quot;);				// Workflow Task Triggered event&#xD;
var wfStatus = aa.env.getValue(&quot;WorkflowStatus&quot;);			// Status of workflow that triggered event&#xD;
var wfDate = aa.env.getValue(&quot;WorkflowStatusDate&quot;);			// date of status of workflow that triggered event&#xD;
var wfDateMMDDYYYY = wfDate.substr(5,2) + &quot;/&quot; + wfDate.substr(8,2) + &quot;/&quot; + wfDate.substr(0,4);	// date of status of workflow that triggered event in format MM/DD/YYYY&#xD;
var wfProcessID = aa.env.getValue(&quot;ProcessID&quot;);				// Process ID of workflow&#xD;
var wfStep ; var wfComment ; var wfNote ; var wfDue ;			// Initialize&#xD;
var wfProcess ; 							// Initialize&#xD;
// Go get other task details&#xD;
var wfObj = aa.workflow.getTasks(capId).getOutput();&#xD;
for (i in wfObj)&#xD;
	{&#xD;
	fTask = wfObj[i];&#xD;
	if (fTask.getTaskDescription().equals(wfTask) &amp;&amp; (fTask.getProcessID() == wfProcessID))&#xD;
		{&#xD;
		wfStep = fTask.getStepNumber();&#xD;
		wfProcess = fTask.getProcessCode();&#xD;
		wfComment = fTask.getDispositionComment();&#xD;
		wfNote = fTask.getDispositionNote();&#xD;
		wfDue = fTask.getDueDate();&#xD;
		wfTaskObj = fTask&#xD;
		}&#xD;
	}&#xD;
logDebug(&quot;wfTask = &quot; + wfTask);&#xD;
logDebug(&quot;wfTaskObj = &quot; + wfTask.getClass());&#xD;
logDebug(&quot;wfStatus = &quot; + wfStatus);&#xD;
logDebug(&quot;wfDate = &quot; + wfDate);&#xD;
logDebug(&quot;wfDateMMDDYYYY = &quot; + wfDateMMDDYYYY);&#xD;
logDebug(&quot;wfStep = &quot; + wfStep);&#xD;
logDebug(&quot;wfComment = &quot; + wfComment);&#xD;
logDebug(&quot;wfProcess = &quot; + wfProcess);&#xD;
logDebug(&quot;wfNote = &quot; + wfNote);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + capIDString + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
	if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Internal Functions and Classes (Used by this script)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
function logGlobals(globArray) {&#xD;
&#xD;
	for (loopGlob in globArray)&#xD;
		logDebug(&quot;{&quot; + loopGlob + &quot;} = &quot; + globArray[loopGlob])&#xD;
	}&#xD;
&#xD;
function getCapId()  {&#xD;
&#xD;
    var s_id1 = aa.env.getValue(&quot;PermitId1&quot;);&#xD;
    var s_id2 = aa.env.getValue(&quot;PermitId2&quot;);&#xD;
    var s_id3 = aa.env.getValue(&quot;PermitId3&quot;);&#xD;
&#xD;
    var s_capResult = aa.cap.getCapID(s_id1, s_id2, s_id3);&#xD;
    if(s_capResult.getSuccess())&#xD;
      return s_capResult.getOutput();&#xD;
    else&#xD;
    {&#xD;
      logMessage(&quot;**ERROR: Failed to get capId: &quot; + s_capResult.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
  }&#xD;
&#xD;
&#xD;
//&#xD;
// matches:  returns true if value matches any of the following arguments&#xD;
//&#xD;
function matches(eVal,argList) {&#xD;
   for (var i=1; i&lt;arguments.length;i++)&#xD;
   	if (arguments[i] == eVal)&#xD;
   		return true;&#xD;
&#xD;
}&#xD;
&#xD;
//&#xD;
// exists:  return true if Value is in Array&#xD;
//&#xD;
function exists(eVal, eArray) {&#xD;
	  for (ii in eArray)&#xD;
	  	if (eArray[ii] == eVal) return true;&#xD;
	  return false;&#xD;
}&#xD;
&#xD;
//&#xD;
// Get the standard choices domain for this application type&#xD;
//&#xD;
function getScriptAction(strControl)&#xD;
	{&#xD;
	var actArray = new Array();&#xD;
	var maxLength = String(&quot;&quot; + maxEntries).length;&#xD;
&#xD;
	for (var count=1; count &lt;= maxEntries; count++)  // Must be sequential from 01 up to maxEntries&#xD;
		{&#xD;
		var countstr = &quot;000000&quot; + count;&#xD;
		countstr = String(countstr).substring(countstr.length,countstr.length - maxLength);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(strControl,countstr);&#xD;
&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var myObj= new pairObj(bizDomScriptObj.getBizdomainValue());&#xD;
			myObj.load(bizDomScriptObj.getDescription());&#xD;
			if (bizDomScriptObj.getAuditStatus() == 'I') myObj.enabled = false;&#xD;
			actArray.push(myObj);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
	return actArray;&#xD;
	}&#xD;
&#xD;
function getTaskCnt(wfHistCapID,wfHistTask) // Optional variable to count Task by a Task Status. List each Task Status as a string.&#xD;
{&#xD;
   // Will return count of Task that have been resulted by a certain Task Status&#xD;
   // wfHistTaskStatus - Names of Task Status to be counted with Task.  Enter one or more Task Statuses separated by commas and each in double-quotes.&#xD;
&#xD;
   var count=0;&#xD;
   var workflowResult=aa.workflow.getHistory(wfHistCapID);&#xD;
   var wfTask;&#xD;
   var useTaskStatus = false;&#xD;
   var taskStatusArray = new Array();&#xD;
   if (arguments.length &gt; 2) //Array used to hold Task Status to count&#xD;
      {&#xD;
      useTaskStatus = true;&#xD;
      for (var i=2; i&lt;arguments.length; i++)&#xD;
          taskStatusArray.push(arguments[i].toUpperCase());&#xD;
      }&#xD;
&#xD;
   if (!workflowResult.getSuccess())&#xD;
   {&#xD;
      logMessage(&quot;**ERROR: Failed to get workflow history object: &quot; + workflowResult.getErrorMessage());&#xD;
   }&#xD;
   else&#xD;
   {&#xD;
      var wfObj = workflowResult.getOutput();&#xD;
      for (i in wfObj)&#xD;
      {&#xD;
         wfTask = wfObj[i];&#xD;
         if (wfTask.getTaskDescription().toUpperCase().equals(wfHistTask.toUpperCase()) &amp;&amp; (!useTaskStatus || exists(wfTask.getDisposition().toUpperCase(),taskStatusArray)))&#xD;
         {&#xD;
            count=count+1;&#xD;
         }&#xD;
      }&#xD;
   }&#xD;
  return count;&#xD;
}&#xD;
&#xD;
function doStandardChoiceActions(stdChoiceEntry,doExecution,docIndent)&#xD;
	{&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	var lastEvalTrue = false;&#xD;
	logDebug(&quot;Executing: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	var pairObjArray = getScriptAction(stdChoiceEntry);&#xD;
	if (!doExecution) docWrite(stdChoiceEntry,true,docIndent);&#xD;
	for (xx in pairObjArray)&#xD;
		{&#xD;
		doObj = pairObjArray[xx];&#xD;
		if (doExecution)&#xD;
			{&#xD;
			if (doObj.enabled)&#xD;
				if (eval(token(doObj.cri)) || (lastEvalTrue &amp;&amp; doObj.continuation))&#xD;
					{&#xD;
					eval(token(doObj.act));&#xD;
					lastEvalTrue = true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					if (doObj.elseact)&#xD;
						eval(token(doObj.elseact));&#xD;
					lastEvalTrue = false;&#xD;
					}&#xD;
			}&#xD;
		else // just document&#xD;
			{&#xD;
			docWrite(&quot;|  &quot;,false,docIndent);&#xD;
			var disableString = &quot;&quot;;&#xD;
			if (!doObj.enabled) disableString = &quot;&lt;DISABLED&gt;&quot;;&#xD;
&#xD;
			if (doObj.elseact)&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act + &quot; ^ &quot; + doObj.elseact ,false,docIndent);&#xD;
			else&#xD;
				docWrite(&quot;|  &quot; + doObj.ID + &quot; &quot; + disableString + &quot; &quot; + doObj.cri + &quot; ^ &quot; + doObj.act,false,docIndent);&#xD;
&#xD;
			for (yy in doObj.branch)&#xD;
				{&#xD;
				doStandardChoiceActions(doObj.branch[yy],false,docIndent+1);&#xD;
				}&#xD;
			}&#xD;
		} // next sAction&#xD;
	if (!doExecution) docWrite(null,true,docIndent);&#xD;
	var thisDate = new Date();&#xD;
	var thisTime = thisDate.getTime();&#xD;
	logDebug(&quot;Finished: &quot; + stdChoiceEntry + &quot;, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
function docWrite(dstr,header,indent)&#xD;
	{&#xD;
	var istr = &quot;&quot;;&#xD;
	for (i = 0 ; i &lt; indent ; i++)&#xD;
		istr+=&quot;|  &quot;;&#xD;
	if (header &amp;&amp; dstr)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	if (dstr) aa.print(istr + dstr);&#xD;
	if (header)&#xD;
		aa.print(istr + &quot;------------------------------------------------&quot;);&#xD;
	}&#xD;
&#xD;
&#xD;
function token(tstr)&#xD;
	{&#xD;
	if (!disableTokens)&#xD;
		{&#xD;
		re = new RegExp(&quot;\\{&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;AInfo[\&quot;&quot;);&#xD;
		re = new RegExp(&quot;\\}&quot;,&quot;g&quot;) ; tstr = String(tstr).replace(re,&quot;\&quot;]&quot;);&#xD;
		}&#xD;
	return String(tstr);&#xD;
  	}&#xD;
&#xD;
function pairObj(actID)&#xD;
	{&#xD;
	this.ID = actID;&#xD;
	this.cri = null;&#xD;
	this.act = null;&#xD;
	this.elseact = null;&#xD;
	this.enabled = true;&#xD;
	this.continuation = false;&#xD;
	this.branch = new Array();&#xD;
&#xD;
	this.load = function(loadStr) {&#xD;
		//&#xD;
		// load() : tokenizes and loades the criteria and action&#xD;
		//&#xD;
		loadArr = loadStr.split(&quot;\\^&quot;);&#xD;
		if (loadArr.length &lt; 2 || loadArr.length &gt; 3)&#xD;
			{&#xD;
			logMessage(&quot;**ERROR: The following Criteria/Action pair is incorrectly formatted.  Two or three elements separated by a caret (\&quot;^\&quot;) are required. &quot; + br + br + loadStr)&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			this.cri     = loadArr[0];&#xD;
			this.act     = loadArr[1];&#xD;
			this.elseact = loadArr[2];&#xD;
&#xD;
			if (this.cri.length() == 0) this.continuation = true; // if format is like (&quot;^action...&quot;) then it's a continuation of previous line&#xD;
&#xD;
			var a = loadArr[1];&#xD;
			var bb = a.indexOf(&quot;branch&quot;);&#xD;
			while (!enableVariableBranching &amp;&amp; bb &gt;= 0)&#xD;
			  {&#xD;
			  var cc = a.substring(bb);&#xD;
			  var dd = cc.indexOf(&quot;\&quot;)&quot;);&#xD;
			  this.branch.push(cc.substring(8,dd));&#xD;
			  a = cc.substring(dd);&#xD;
			  bb = a.indexOf(&quot;branch&quot;);&#xD;
			  }&#xD;
&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
function convertDate(thisDate)&#xD;
// convert ScriptDateTime to Javascript Date Object&#xD;
	{&#xD;
	return new Date(thisDate.getMonth() + &quot;/&quot; + thisDate.getDayOfMonth() + &quot;/&quot; + thisDate.getYear());&#xD;
	}&#xD;
&#xD;
&#xD;
function logDebug(dstr)&#xD;
	{&#xD;
	debug+=dstr + br;&#xD;
	}&#xD;
&#xD;
function logMessage(dstr)&#xD;
	{&#xD;
	message+=dstr + br;&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
 &#xD;
function activateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;Y&quot;, &quot;N&quot;, null, null)&#xD;
&#xD;
			logMessage(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;Activating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addAddressCondition(addNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if addNum is null, condition is added to all addresses on CAP&#xD;
	{&#xD;
	if (!addNum)&#xD;
		{&#xD;
		var capAddResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{&#xD;
			var Adds = capAddResult.getOutput();&#xD;
			for (zz in Adds)&#xD;
				{&#xD;
				&#xD;
				if (Adds[zz].getRefAddressId())&#xD;
					{&#xD;
					var addAddCondResult = aa.addressCondition.addAddressCondition(Adds[zz].getRefAddressId(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
&#xD;
						if (addAddCondResult.getSuccess())&#xD;
							{&#xD;
							logDebug(&quot;Successfully added condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
							}&#xD;
						else&#xD;
							{&#xD;
							logDebug( &quot;**ERROR: adding condition to reference Address &quot; + Adds[zz].getRefAddressId() + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
							}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addAddCondResult = aa.addressCondition.addAddressCondition(addNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj);&#xD;
			&#xD;
	&#xD;
		        if (addAddCondResult.getSuccess())&#xD;
		        	{&#xD;
				logDebug(&quot;Successfully added condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition to Address &quot; + addNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addAddCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function addAllFees(fsched,fperiod,fqty,finvoice) // Adds all fees for a given fee schedule&#xD;
	{&#xD;
	var arrFees = aa.finance.getFeeItemList(null,fsched,null).getOutput();&#xD;
	for (xx in arrFees)&#xD;
		{&#xD;
		var feeCod = arrFees[xx].getFeeCod();&#xD;
		var assessFeeResult = aa.finance.createFeeItem(capId,fsched,feeCod,fperiod,fqty);&#xD;
		if (assessFeeResult.getSuccess())&#xD;
			{&#xD;
			var feeSeq = assessFeeResult.getOutput();&#xD;
			logMessage(&quot;Added Fee &quot; + feeCod + &quot;, Qty &quot; + fqty);&#xD;
			logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq);&#xD;
			if (finvoice == &quot;Y&quot;)&#xD;
			{&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: assessing fee (&quot; + feeCod + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
			}&#xD;
		} // for xx&#xD;
	} // function&#xD;
&#xD;
 &#xD;
function addAppCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	var addCapCondResult = aa.capCondition.addCapCondition(capId, cType, cDesc, cComment, sysDate, null, sysDate, null,null, cImpact, systemUserObj, systemUserObj, cStatus, currentUserID, &quot;A&quot;)&#xD;
        if (addCapCondResult.getSuccess())&#xD;
        	{&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		aa.print(&quot;Successfully added condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.print( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
  function addASITable(tableName,tableValueArray) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValueArray is an array of associative array values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
&#xD;
	for (thisrow in tableValueArray)&#xD;
		{&#xD;
		var col = tsm.getColumns()&#xD;
		var coli = col.iterator();&#xD;
&#xD;
		while (coli.hasNext())&#xD;
			{&#xD;
			var colname = coli.next();&#xD;
			fld.add(tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			logDebug(&quot;Table: &quot; + tableName + &quot; Row:&quot; + thisrow + &quot; Column: &quot; + colname.getColumnName() + &quot; Value: &quot; + tableValueArray[thisrow][colname.getColumnName()]);&#xD;
			}&#xD;
&#xD;
		tsm.setTableField(fld);&#xD;
&#xD;
		if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
		}&#xD;
&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
&#xD;
	// Even when this works it gives an index out of range error&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function addFee(fcode,fsched,fperiod,fqty,finvoice) // Adds a single fee, optional argument: fCap&#xD;
	{&#xD;
	// Updated Script will return feeSeq number or null if error encountered (SR5112) &#xD;
	var feeCap = capId;&#xD;
	var feeCapMessage = &quot;&quot;;&#xD;
	var feeSeq_L = new Array();				// invoicing fee for CAP in args&#xD;
	var paymentPeriod_L = new Array();			// invoicing pay periods for CAP in args&#xD;
	var feeSeq = null;&#xD;
	if (arguments.length &gt; 5) &#xD;
		{&#xD;
		feeCap = arguments[5]; // use cap ID specified in args&#xD;
		feeCapMessage = &quot; to specified CAP&quot;;&#xD;
		}&#xD;
&#xD;
	assessFeeResult = aa.finance.createFeeItem(feeCap,fsched,fcode,fperiod,fqty);&#xD;
	if (assessFeeResult.getSuccess())&#xD;
		{&#xD;
		feeSeq = assessFeeResult.getOutput();&#xD;
		logMessage(&quot;Successfully added Fee &quot; + fcode + &quot;, Qty &quot; + fqty + feeCapMessage);&#xD;
		logDebug(&quot;The assessed fee Sequence Number &quot; + feeSeq + feeCapMessage);&#xD;
&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length == 5) // use current CAP&#xD;
			{&#xD;
			feeSeqList.push(feeSeq);&#xD;
			paymentPeriodList.push(fperiod);&#xD;
			}&#xD;
		if (finvoice == &quot;Y&quot; &amp;&amp; arguments.length &gt; 5) // use CAP in args&#xD;
			{&#xD;
			feeSeq_L.push(feeSeq);&#xD;
			paymentPeriod_L.push(fperiod);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(feeCap, feeSeq_L, paymentPeriod_L);&#xD;
			if (invoiceResult_L.getSuccess())&#xD;
				logMessage(&quot;Invoicing assessed fee items&quot; + feeCapMessage + &quot; is successful.&quot;);&#xD;
			else&#xD;
				logDebug(&quot;**ERROR: Invoicing the fee items assessed&quot; + feeCapMessage + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: assessing fee (&quot; + fcode + &quot;): &quot; + assessFeeResult.getErrorMessage());&#xD;
		feeSeq = null;&#xD;
		}&#xD;
	&#xD;
	return feeSeq;&#xD;
	   &#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addLicenseCondition(cType,cStatus,cDesc,cComment,cImpact)&#xD;
	{&#xD;
	// Optional 6th argument is license number, otherwise add to all CAEs on CAP&#xD;
	refLicArr = new Array();&#xD;
	if (arguments.length == 6) // License Number provided&#xD;
		{&#xD;
		refLicArr.push(getRefLicenseProf(arguments[5]));&#xD;
		}&#xD;
	else // adding to cap lic profs&#xD;
		{&#xD;
		var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
		if (capLicenseResult.getSuccess())&#xD;
			{ var refLicArr = capLicenseResult.getOutput();  }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting lic profs from Cap: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
&#xD;
	for (var refLic in refLicArr)&#xD;
		{&#xD;
		if (arguments.length == 6) // use sequence number&#xD;
			licSeq = refLicArr[refLic].getLicSeqNbr();&#xD;
		else&#xD;
			licSeq = refLicArr[refLic].getLicenseNbr();&#xD;
&#xD;
		var addCAEResult = aa.caeCondition.addCAECondition(licSeq, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj)&#xD;
&#xD;
		if (addCAEResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;Successfully added licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding licensed professional (&quot; + licSeq + &quot;) condition (&quot; + cImpact + &quot;): &quot; + addCAEResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, don't add&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Standard Choices Item &quot;+stdChoice+&quot; and Value &quot;+stdValue+&quot; already exist.  Lookup is not added or updated.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//Proceed to add&#xD;
	var strControl;&#xD;
	&#xD;
	if (stdChoice != null &amp;&amp; stdChoice.length &amp;&amp; stdValue != null &amp;&amp; stdValue.length &amp;&amp; stdDesc != null &amp;&amp; stdDesc.length)&#xD;
		{&#xD;
		var bizDomScriptResult = aa.bizDomain.createBizDomain(stdChoice, stdValue, &quot;A&quot;, stdDesc)&#xD;
&#xD;
		if (bizDomScriptResult.getSuccess())&#xD;
&#xD;
			//check if new Std Choice actually created&#xD;
&#xD;
&#xD;
&#xD;
			logDebug(&quot;Successfully created Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
		else&#xD;
			logDebug(&quot;**ERROR creating Std Choice &quot; + bizDomScript.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Could not create std choice, one or more null values&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelCondition(parcelNum, cType,cStatus,cDesc,cComment,cImpact)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var addParcelCondResult = aa.parcelCondition.addParcelCondition(Parcels[zz].getParcelNumber(), cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
					if (addParcelCondResult.getSuccess())&#xD;
					        	{&#xD;
						logMessage(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						logDebug(&quot;Successfully added condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						{&#xD;
						logDebug( &quot;**ERROR: adding condition to Parcel &quot; + Parcels[zz].getParcelNumber() + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
						}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
			var addParcelCondResult = aa.parcelCondition.addParcelCondition(parcelNum, cType, cDesc, cComment, null, null, cImpact, cStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	&#xD;
		        if (addParcelCondResult.getSuccess())&#xD;
		        	{&#xD;
				logMessage(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				logDebug(&quot;Successfully added condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
			logDebug( &quot;**ERROR: adding condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cImpact + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParcelDistrict(parcelNum, districtValue)&#xD;
//if parcelNum is null, district is is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),Parcels[zz].getParcelNumber(),districtValue);&#xD;
				&#xD;
				if (!apdResult.getSuccess())&#xD;
					{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber() + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
				else&#xD;
					logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + Parcels[zz].getParcelNumber());&#xD;
&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		apdResult = aa.parcel.addParceDistrictForDaily(capId.getID1(),capId.getID2(),capId.getID3(),parcelNum,districtValue);&#xD;
&#xD;
		if (!apdResult.getSuccess())&#xD;
			{ logDebug(&quot;**ERROR Adding District &quot; + districtValue + &quot; to parcel #&quot; + parcelNum + &quot; : &quot; + apdResult.getErrorMessage()) ; return false ; }&#xD;
		else&#xD;
			logDebug(&quot;Successfully added district &quot; + districtValue + &quot; to parcel #&quot; + parcelNum);&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function addParent(parentAppNum) &#xD;
//&#xD;
// adds the current application to the parent&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		var linkResult = aa.cap.createAppHierarchy(parentId, capId);&#xD;
		if (linkResult.getSuccess())&#xD;
			logDebug(&quot;Successfully linked to Parent Application : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: linking to parent application parent cap id (&quot; + parentAppNum + &quot;): &quot; + linkResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
			&#xD;
 &#xD;
function addrAddCondition(pAddrNum, pType, pStatus, pDesc, pComment, pImpact, pAllowDup)&#xD;
	{&#xD;
	//if pAddrNum is null, condition is added to all addresses on CAP&#xD;
	//06SSP-00223&#xD;
	//&#xD;
	if (pAllowDup==&quot;Y&quot;)&#xD;
		var noDup = false;&#xD;
	else&#xD;
		var noDup = true;&#xD;
		&#xD;
	var condAdded = false;&#xD;
		&#xD;
	if (!pAddrNum) //no address num, add condition to all addresses on CAP&#xD;
		{&#xD;
		var capAddrResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddrResult.getSuccess())&#xD;
			{&#xD;
			var addCondResult;&#xD;
			var addCondResult2;&#xD;
			var getCondResult;&#xD;
			var condArray;&#xD;
			var addresses = capAddrResult.getOutput();&#xD;
			&#xD;
			addCondLoop:  //loop identifier&#xD;
			for (zz in addresses)&#xD;
				{&#xD;
				var addrRefId = addresses[zz].getRefAddressId();&#xD;
				if (addrRefId==null)&#xD;
					{&#xD;
					logDebug(&quot;No reference address ID found for Address &quot;+zz);&#xD;
					continue;&#xD;
					}&#xD;
					&#xD;
				if (noDup) //Check if this address has duplicate condition&#xD;
					{&#xD;
					var cType;&#xD;
					var cStatus;&#xD;
					var cDesc;&#xD;
					var cImpact;&#xD;
					&#xD;
					getCondResult = aa.addressCondition.getAddressConditions(addrRefId);&#xD;
					condArray = getCondResult.getOutput();&#xD;
					if (condArray.length&gt;0)&#xD;
						{&#xD;
						for (bb in condArray)&#xD;
							{&#xD;
							cType = condArray[bb].getConditionType();&#xD;
							cStatus = condArray[bb].getConditionStatus();&#xD;
							cDesc = condArray[bb].getConditionDescription();&#xD;
							cImpact = condArray[bb].getImpactCode();&#xD;
							if (cType==null)&#xD;
								cType = &quot; &quot;;&#xD;
							if (cStatus==null)&#xD;
								cStatus = &quot; &quot;;&#xD;
							if (cDesc==null)&#xD;
								cDesc = &quot; &quot;;&#xD;
							if (cImpact==null)&#xD;
								cImpact = &quot; &quot;;&#xD;
							if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
								{&#xD;
								logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+addrRefId);&#xD;
								continue addCondLoop; //continue to next address without adding condition&#xD;
								}&#xD;
							}&#xD;
						}&#xD;
					}&#xD;
					&#xD;
				logDebug(&quot;Adding Condition to address &quot; + zz + &quot; = &quot; + addrRefId);&#xD;
				addCondResult = aa.addressCondition.addAddressCondition(addrRefId, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
				if (addCondResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					logDebug(&quot;Successfully added condition to Address ID &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
					condAdded=true;&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					logDebug( &quot;**ERROR: adding condition to Address &quot; + addrRefId + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else //add condition to specified address only&#xD;
		{&#xD;
		if (noDup) //Check if this address has duplicate condition&#xD;
			{&#xD;
			var cType;&#xD;
			var cStatus;&#xD;
			var cDesc;&#xD;
			var cImpact;&#xD;
			&#xD;
			getCondResult = aa.addressCondition.getAddressConditions(pAddrNum);&#xD;
			condArray = getCondResult.getOutput();&#xD;
			if (condArray.length&gt;0)&#xD;
				{&#xD;
				for (bb in condArray)&#xD;
					{&#xD;
					cType = condArray[bb].getConditionType();&#xD;
					cStatus = condArray[bb].getConditionStatus();&#xD;
					cDesc = condArray[bb].getConditionDescription();&#xD;
					cImpact = condArray[bb].getImpactCode();&#xD;
					if (cType==null)&#xD;
						cType = &quot; &quot;;&#xD;
					if (cStatus==null)&#xD;
						cStatus = &quot; &quot;;&#xD;
					if (cDesc==null)&#xD;
						cDesc = &quot; &quot;;&#xD;
					if (cImpact==null)&#xD;
						cImpact = &quot; &quot;;&#xD;
					if ( (pType==null || pType.toUpperCase()==cType.toUpperCase()) &amp;&amp; (pStatus==null || pStatus.toUpperCase()==cStatus.toUpperCase()) &amp;&amp; (pDesc==null || pDesc.toUpperCase()==cDesc.toUpperCase()) &amp;&amp; (pImpact==null || pImpact.toUpperCase()==cImpact.toUpperCase()) )&#xD;
						{&#xD;
						logMessage(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						logDebug(&quot;Condition already exists: New condition not added to Address ID &quot;+pAddrNum);&#xD;
						return false;&#xD;
						}&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		var addCondResult = aa.addressCondition.addAddressCondition(pAddrNum, pType, pDesc, pComment, null, null, pImpact, pStatus, sysDate, null, sysDate, sysDate, systemUserObj, systemUserObj); &#xD;
	  if (addCondResult.getSuccess())&#xD;
		  {&#xD;
			logMessage(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			logDebug(&quot;Successfully added condition to Address ID &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;) &quot; + pDesc);&#xD;
			condAdded=true;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**ERROR: adding condition to Address &quot; + pAddrNum + &quot;  (&quot; + pImpact + &quot;): &quot; + addCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return condAdded;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function addStdCondition(cType,cDesc)&#xD;
	{&#xD;
&#xD;
	if (!aa.capCondition.getStandardConditions)&#xD;
		{&#xD;
		logDebug(&quot;addStdCondition function is not available in this version of Accela Automation.&quot;);&#xD;
		}&#xD;
        else&#xD;
		{&#xD;
		standardConditions = aa.capCondition.getStandardConditions(cType,cDesc).getOutput();&#xD;
		for(i = 0; i&lt;standardConditions.length;i++)&#xD;
			{&#xD;
			standardCondition = standardConditions[i]&#xD;
			var addCapCondResult = aa.capCondition.addCapCondition(capId, standardCondition.getConditionType(), standardCondition.getConditionDesc(), standardCondition.getConditionComment(), sysDate, null, sysDate, null, null, standardCondition.getImpactCode(), systemUserObj, systemUserObj, &quot;Applied&quot;, currentUserID, &quot;A&quot;)&#xD;
	        	if (addCapCondResult.getSuccess())&#xD;
	        		{&#xD;
				logMessage(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				logDebug(&quot;Successfully added condition (&quot; + standardCondition.getConditionDesc() + &quot;)&quot;);&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug( &quot;**ERROR: adding condition (&quot; + standardCondition.getConditionDesc() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
  function addToASITable(tableName,tableValues) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	itemCap = capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField()&#xD;
	var col = tsm.getColumns()&#xD;
	var coli = col.iterator();&#xD;
&#xD;
	while (coli.hasNext())&#xD;
		{&#xD;
		colname = coli.next();&#xD;
		fld.add(tableValues[colname.getColumnName()]);&#xD;
		}&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
&#xD;
	if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
function allTasksComplete(stask) // optional tasks to ignore... for Sacramento&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++) &#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	// returns true if any of the subtasks are active&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
			return false;&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function appHasCondition(pType,pStatus,pDesc,pImpact)&#xD;
	{&#xD;
	// Checks to see if conditions have been added to CAP&#xD;
	// 06SSP-00223&#xD;
	//&#xD;
	if (pType==null)&#xD;
		var condResult = aa.capCondition.getCapConditions(capId);&#xD;
	else&#xD;
		var condResult = aa.capCondition.getCapConditions(capId,pType);&#xD;
		&#xD;
	if (condResult.getSuccess())&#xD;
		var capConds = condResult.getOutput();&#xD;
	else&#xD;
		{ &#xD;
		logMessage(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		logDebug(&quot;**ERROR: getting cap conditions: &quot; + condResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var cStatus;&#xD;
	var cDesc;&#xD;
	var cImpact;&#xD;
	&#xD;
	for (cc in capConds)&#xD;
		{&#xD;
		var thisCond = capConds[cc];&#xD;
		var cStatus = thisCond.getConditionStatus();&#xD;
		var cDesc = thisCond.getConditionDescription();&#xD;
		var cImpact = thisCond.getImpactCode();&#xD;
		var cType = thisCond.getConditionType();&#xD;
		if (cStatus==null)&#xD;
			cStatus = &quot; &quot;;&#xD;
		if (cDesc==null)&#xD;
			cDesc = &quot; &quot;;&#xD;
		if (cImpact==null)&#xD;
			cImpact = &quot; &quot;;&#xD;
		//Look for matching condition&#xD;
		&#xD;
		if ( (pStatus==null || pStatus.toUpperCase().equals(cStatus.toUpperCase())) &amp;&amp; (pDesc==null || pDesc.toUpperCase().equals(cDesc.toUpperCase())) &amp;&amp; (pImpact==null || pImpact.toUpperCase().equals(cImpact.toUpperCase())))&#xD;
			return true; //matching condition found&#xD;
		}&#xD;
	return false; //no matching condition found&#xD;
	} //function&#xD;
	&#xD;
 &#xD;
function appMatch(ats) // optional capId or CapID string&#xD;
	{&#xD;
	var matchArray = appTypeArray //default to current app&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		matchCapParm = arguments[1]&#xD;
		if (typeof(matchCapParm) == &quot;string&quot;)&#xD;
			matchCapId = aa.cap.getCapID(matchCapParm).getOutput();   // Cap ID to check&#xD;
		else&#xD;
			matchCapId = matchCapParm;&#xD;
		if (!matchCapId)&#xD;
			{&#xD;
			logDebug(&quot;**WARNING: CapId passed to appMatch was not valid: &quot; + arguments[1]);&#xD;
			return false&#xD;
			}&#xD;
		matchCap = aa.cap.getCap(matchCapId).getOutput();&#xD;
		matchArray = matchCap.getCapType().toString().split(&quot;/&quot;);&#xD;
		}&#xD;
		&#xD;
	var isMatch = true;&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
	else&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(matchArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
	return isMatch;&#xD;
	}	&#xD;
&#xD;
&#xD;
 &#xD;
function appNameIsUnique(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns true if gaName application name has not been used in CAPs of gaGroup and gaType&#xD;
// Bypasses current CAP&#xD;
	{&#xD;
	var getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText())&#xD;
			if (myCap.getSpecialText().toUpperCase().equals(gaName.toUpperCase()) &amp;&amp; !capIDString.equals(apsArray[aps].getCapID().getCustomID()))&#xD;
				return false;&#xD;
		}&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function assignCap(assignId) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(assignId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving  user model &quot; + assignId + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setAsgnDept(iName.getDeptOfUser());&#xD;
	cd.setAsgnStaff(assignId);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Assigned CAP to &quot; + assignId) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function assignInspection(iNumber,iName)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id and the user name&#xD;
	//&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(iName);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspector user model &quot; + iName + &quot; : &quot; + iNameResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iInspector = iNameResult.getOutput();&#xD;
	&#xD;
	iObj.setInspector(iInspector);&#xD;
&#xD;
	aa.inspection.editInspection(iObj)&#xD;
	}&#xD;
&#xD;
 &#xD;
function assignTask(wfstr,username) // optional process name&#xD;
	{&#xD;
	// Assigns the task to a user.  No audit.&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
		&#xD;
	var taskUserResult = aa.person.getUser(username);&#xD;
	if (taskUserResult.getSuccess())&#xD;
		taskUserObj = taskUserResult.getOutput();  //  User Object&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get user object: &quot; + taskUserResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			fTask.setAssignedUser(taskUserObj);&#xD;
			var taskItem = fTask.getTaskItem();&#xD;
			var adjustResult = aa.workflow.assignTask(taskItem);&#xD;
			&#xD;
			logMessage(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			logDebug(&quot;Assigned Workflow Task: &quot; + wfstr + &quot; to &quot; + username);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function autoAssignInspection(iNumber)&#xD;
	{&#xD;
	// updates the inspection and assigns to a new user&#xD;
	// requires the inspection id&#xD;
	//&#xD;
&#xD;
	iObjResult = aa.inspection.getInspection(capId,iNumber);&#xD;
	if (!iObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection &quot; + iNumber + &quot; : &quot; + iObjResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	iObj = iObjResult.getOutput();&#xD;
&#xD;
&#xD;
	inspTypeResult = aa.inspection.getInspectionType(iObj.getInspection().getInspectionGroup(), iObj.getInspectionType())&#xD;
&#xD;
	if (!inspTypeResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving inspection Type &quot; + inspTypeResult.getErrorMessage()) ; return false ; }&#xD;
	&#xD;
	inspTypeArr = inspTypeResult.getOutput();&#xD;
&#xD;
        if (inspTypeArr == null || inspTypeArr.length == 0)&#xD;
		{ logDebug(&quot;**ERROR no inspection type found&quot;) ; return false ; }&#xD;
&#xD;
	inspType = inspTypeArr[0]; // assume first&#xD;
&#xD;
	inspSeq = inspType.getSequenceNumber();&#xD;
&#xD;
	inspSchedDate = iObj.getScheduledDate().getYear() + &quot;-&quot; + iObj.getScheduledDate().getMonth() + &quot;-&quot; + iObj.getScheduledDate().getDayOfMonth()&#xD;
&#xD;
 	logDebug(inspSchedDate)&#xD;
&#xD;
	iout =  aa.inspection.autoAssignInspector(capId.getID1(),capId.getID2(),capId.getID3(), inspSeq, inspSchedDate)&#xD;
&#xD;
	if (!iout.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving auto assign inspector &quot; + iout.getErrorMessage()) ; return false ; }&#xD;
&#xD;
	inspectorArr = iout.getOutput();&#xD;
&#xD;
	if (inspectorArr == null || inspectorArr.length == 0)&#xD;
		{ logDebug(&quot;**WARNING no auto-assign inspector found&quot;) ; return false ; }&#xD;
	&#xD;
	inspectorObj = inspectorArr[0];  // assume first&#xD;
	&#xD;
	iObj.setInspector(inspectorObj);&#xD;
&#xD;
	assignResult = aa.inspection.editInspection(iObj)&#xD;
&#xD;
	if (!assignResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR re-assigning inspection &quot; + assignResult.getErrorMessage()) ; return false ; }&#xD;
	else&#xD;
		logDebug(&quot;Successfully reassigned inspection &quot; + iObj.getInspectionType() + &quot; to user &quot; + inspectorObj.getUserID());&#xD;
&#xD;
	}&#xD;
 &#xD;
function branch(stdChoice)&#xD;
	{&#xD;
	doStandardChoiceActions(stdChoice,true,0);&#xD;
	}&#xD;
&#xD;
 &#xD;
function branchTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;B&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Branching...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function callWebService(wsSubScript, wsScriptParameters)&#xD;
	{&#xD;
&#xD;
		aa.env.setValue(&quot;wsScriptParameters&quot;,wsScriptParameters);&#xD;
		aa.env.setValue(&quot;wsScriptDebug&quot;,&quot;&quot;);&#xD;
		aa.env.setValue(&quot;wsScriptMessage&quot;,&quot;&quot;);&#xD;
		&#xD;
		var sSubDebug = &quot;&quot;;&#xD;
		var sSubMessage = &quot;&quot;;&#xD;
		&#xD;
		logDebug(&quot;Executing Web Service wsSubScript: &quot; + wsSubScript);&#xD;
		aa.runScriptInNewTransaction(wsSubScript);&#xD;
		sSubDebug = aa.env.getValue(&quot;wsScriptDebug&quot;);&#xD;
		sSubMessage = aa.env.getValue(&quot;wsScriptMessage&quot;);&#xD;
		if (sSubDebug != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Debug from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubDebug);&#xD;
		}&#xD;
		if (sSubMessage != &quot;&quot;)&#xD;
		{&#xD;
			//Logging&#xD;
			logDebug(&quot;Message from wsSubScript: &quot; + wsSubScript);&#xD;
			logDebug(sSubMessage);&#xD;
		}&#xD;
		&#xD;
	} &#xD;
function capHasExpiredLicProf(pDateType, pLicType, pCapId)&#xD;
	{&#xD;
	//Checks if any licensed professional of specified type (optional) on CAP has expired,  Expiration date type specified by pDateType.&#xD;
	//If any have expired, displays message and returns true.  If expiration date is on or before current date, it is expired.&#xD;
	//If any date is blank, script assumes that date has not expired.&#xD;
	//Uses functions: refLicProfGetDate, jsDateToMMDDYYYY(), matches()&#xD;
	//SR5054B&#xD;
	&#xD;
	//Validate parameters&#xD;
	var vDateType;&#xD;
	if ( pDateType==null || pDateType==&quot;&quot; )&#xD;
		{&#xD;
		logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		vDateType = pDateType.toUpperCase();&#xD;
		if ( !matches(vDateType, &quot;EXPIRE&quot;,&quot;INSURANCE&quot;,&quot;BUSINESS&quot;) )&#xD;
			{&#xD;
			logDebug (&quot;Invalid expiration type parameter&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	var vCapId = pCapId;&#xD;
	if ( pCapId==null || pCapId==&quot;&quot; ) //If no capid parameter, use current cap&#xD;
		vCapId = capId;&#xD;
	&#xD;
	//get Licensed Profs on CAP&#xD;
	var licProfResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (!licProfResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Error getting CAP's license professional: &quot; +licProfResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	var vToday = new Date();&#xD;
	var vExpired = false;&#xD;
	var licProfList = licProfResult.getOutput();&#xD;
	if (licProfList)&#xD;
		{&#xD;
		for (i in licProfList)&#xD;
			{&#xD;
			if ( pLicType==null || pLicType==&quot;&quot; || pLicType.equals(licProfList[i].getLicenseType()) )&#xD;
				{&#xD;
				var licNum = licProfList[i].getLicenseNbr();&#xD;
				&#xD;
				//Check if has expired&#xD;
				var vResult = refLicProfGetDate(licNum, vDateType);&#xD;
&#xD;
				if (vResult &lt; vToday)&#xD;
					{&#xD;
					vExpired = true;&#xD;
					logMessage(&quot;WARNING: Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					logDebug(&quot;Licence # &quot;+licNum+&quot; expired on &quot;+jsDateToMMDDYYYY(vResult));&#xD;
					}			&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;No licensed professionals found on CAP&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	return vExpired;&#xD;
	} &#xD;
function capIdsFilterByFileDate(pCapIdArray, pStartDate, pEndDate)&#xD;
	{&#xD;
	//Filters CAP's in pCapIdArray by file date, and returns only CAP's whose file date falls within pStartDate and pEndDate, as a capId Array&#xD;
	//Parameter pCapIdArray must be array of capId's (CapIDModel objects)&#xD;
	//07SSP-00034/SP5015&#xD;
	&#xD;
	if (pCapIdArray.length==0 || pCapIdArray[0]==undefined)&#xD;
		{&#xD;
		logDebug(&quot;Invalid 1st parameter&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var filteredArray = new Array();&#xD;
	var startDate = new Date(pStartDate);&#xD;
	var endDate = new Date(pEndDate);&#xD;
	var relcap;&#xD;
	var fileDate;&#xD;
	&#xD;
	logDebug(&quot;Filtering CAP array by file date between &quot;+pStartDate+&quot; and &quot;+pEndDate);&#xD;
	for (y in pCapIdArray)&#xD;
		{&#xD;
		relcap = aa.cap.getCap(pCapIdArray[y]).getOutput(); //returns CapScriptModel object&#xD;
		fileDate = convertDate(relcap.getFileDate()); //returns javascript date&#xD;
		//logDebug(&quot;CAP: &quot;+pCapIdArray[y]+&quot;, File Date: &quot;+fileDate);&#xD;
		if (fileDate &gt;= startDate &amp;&amp; fileDate &lt;= endDate)&#xD;
			filteredArray.push(pCapIdArray[y]); //add cap to array&#xD;
		}&#xD;
	&#xD;
	return filteredArray;&#xD;
	} &#xD;
function capIdsGetByAddr ()&#xD;
	{&#xD;
	//Gets CAPs with the same address as the current CAP, as capId (CapIDModel) object array (array includes current capId)&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
		&#xD;
	//Get address(es) on current CAP&#xD;
	var addrResult = aa.address.getAddressByCapId(capId);&#xD;
	if (!addrResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: getting CAP addresses: &quot;+addrResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	var addrArray = new Array();&#xD;
	var addrArray = addrResult.getOutput();&#xD;
	if (addrArray.length==0 || addrArray==undefined)&#xD;
		{&#xD;
		logDebug(&quot;The current CAP has no address.  Unable to get CAPs with the same address.&quot;)&#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	//use 1st address for comparison&#xD;
	var streetName = addrArray[0].getStreetName();&#xD;
	var hseNum = addrArray[0].getHouseNumberStart();&#xD;
	var streetSuffix = addrArray[0].getStreetSuffix();&#xD;
	var zip = addrArray[0].getZip();&#xD;
	var streetDir = addrArray[0].getStreetDirection();&#xD;
	&#xD;
	if (streetDir == &quot;&quot;) streetDir = null;&#xD;
	if (streetSuffix == &quot;&quot;) streetSuffix = null;&#xD;
	if (zip == &quot;&quot;) zip = null;&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(streetName,parseInt(hseNum),streetSuffix,zip,streetDir,null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	var capArray=capAddResult.getOutput(); &#xD;
	else&#xD;
	 	{ &#xD;
		logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capIdArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capArray)&#xD;
		capIdArray.push(capArray[i].getCapID());&#xD;
		&#xD;
	if (capIdArray)&#xD;
		return (capIdArray);&#xD;
	else&#xD;
		return false;&#xD;
	} &#xD;
function capIdsGetByParcel(pParcelNum)&#xD;
	{&#xD;
	//Gets CAPs that have parcel pParcelNum, as capId (CapIDModel object)  array (array includes current capId)&#xD;
	//if parameter pParcelNum is null, uses 1st parcel on current CAP&#xD;
	//07SSP-00034/SP5015&#xD;
	//&#xD;
	if (pParcelNum != null)&#xD;
		var parcelNum = pParcelNum;&#xD;
	else&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (!capParcelResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
			&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		if (Parcels[0]==undefined)&#xD;
			{&#xD;
			logDebug(&quot;Current CAP has no parcel&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		var parcelNum = Parcels[0].getParcelNumber();&#xD;
		}&#xD;
		&#xD;
	capParcelResult = aa.cap.getCapListByParcelID(parcelNum, aa.util.newQueryFormat());&#xD;
	&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var capParArray = capParcelResult.getOutput();&#xD;
	var capIdParArray = new Array();&#xD;
	//convert CapIDScriptModel objects to CapIDModel objects&#xD;
	for (i in capParArray)&#xD;
		capIdParArray.push(capParArray[i].getCapID());&#xD;
		&#xD;
	if (capIdParArray)&#xD;
		return capIdParArray;&#xD;
	else&#xD;
		return false;&#xD;
	}&#xD;
		&#xD;
	 &#xD;
function checkInspectionResult(insp2Check,insp2Result)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; String(insp2Result).equals(inspList[xx].getInspectionStatus()))&#xD;
				return true;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function childGetByCapType(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns capId object of first child of pParentCapId whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
	// 06SSP-00219.C61201&#xD;
  //&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var childArray = getCapResult.getOutput();&#xD;
		if (childArray.length)&#xD;
			{&#xD;
			var childCapId;&#xD;
			var capTypeStr = &quot;&quot;;&#xD;
			var childTypeArray;&#xD;
			var isMatch;&#xD;
			for (xx in childArray)&#xD;
				{&#xD;
				childCapId = childArray[xx].getCapID();&#xD;
				if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
					continue;&#xD;
				&#xD;
				capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
				childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
					{&#xD;
					if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
						{&#xD;
						isMatch = false;&#xD;
						break;&#xD;
						}&#xD;
					}&#xD;
				if (isMatch)&#xD;
					return childCapId;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			logDebug( &quot;**WARNING: childGetByCapType function found no children&quot;);	&#xD;
			&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		logDebug( &quot;**WARNING: childGetByCapType function found no children: &quot; + getCapResult.getErrorMessage());&#xD;
	}&#xD;
	&#xD;
 &#xD;
function closeTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, capId&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;Y&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function comment(cstr)&#xD;
	{&#xD;
	if (showDebug) logDebug(cstr);&#xD;
	if (showMessage) logMessage(cstr);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function completeCAP(userId) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage());&#xD;
			return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ 	logDebug(&quot;**ERROR: No cap detail script object&quot;) ;&#xD;
			return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	iNameResult  = aa.person.getUser(userId);&#xD;
&#xD;
	if (!iNameResult.getSuccess())&#xD;
		{ 	logDebug(&quot;**ERROR retrieving  user model &quot; + userId + &quot; : &quot; + iNameResult.getErrorMessage()) ;&#xD;
			return false ; }&#xD;
	&#xD;
	iName = iNameResult.getOutput();&#xD;
&#xD;
	cd.setCompleteDept(iName.getDeptOfUser());&#xD;
	cd.setCompleteStaff(userId);&#xD;
	cdScriptObj.setCompleteDate(sysDate);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
	{ 	&#xD;
		logDebug(&quot;Set CAP *Completed by Staff* to &quot; + userId) + &quot;\nSet CAP *Completed by Dept* &quot; + iName.getDeptOfUser() + &quot;\nSet CAP *Completed Date* &quot; + sysDate.toString(); &#xD;
	}&#xD;
	else&#xD;
	{ 	&#xD;
		logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ;&#xD;
		return false ; &#xD;
	}&#xD;
} &#xD;
function contactAddFromUser(pUserId)&#xD;
	{&#xD;
	// Retrieves user's reference Contact record and adds to CAP&#xD;
	// Returns contact seq nbr or false if contact not added&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (arguments.length==1) //use parameter user&#xD;
		{&#xD;
		var personResult = aa.person.getUser(pUserId);&#xD;
		if (personResult.getSuccess())&#xD;
			{&#xD;
			var personObj = personResult.getOutput();&#xD;
			//logDebug(&quot;personObj class: &quot;+personObj.getClass());&#xD;
			if (personObj==null) // no user found&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Failed to get User&quot;);&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
  	  { &#xD;
			logDebug(&quot;**ERROR: Failed to get User: &quot; + personResult.getErrorMessage()); &#xD;
			return false; &#xD;
			}&#xD;
		}&#xD;
	else //use current user&#xD;
		var personObj = systemUserObj;&#xD;
		&#xD;
	var userFirst = personObj.getFirstName();&#xD;
	var userMiddle = personObj.getMiddleName();&#xD;
	var userLast = personObj.getLastName();&#xD;
	&#xD;
	//Find PeopleModel object for user &#xD;
	var peopleResult = aa.people.getPeopleByFMLName(userFirst, userMiddle, userLast);&#xD;
	if (peopleResult.getSuccess())&#xD;
		{&#xD;
		var peopleObj = peopleResult.getOutput();&#xD;
		//logDebug(&quot;peopleObj is &quot;+peopleObj.getClass());&#xD;
		if (peopleObj==null)&#xD;
			{&#xD;
			logDebug(&quot;No reference user found.&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		logDebug(&quot;No. of reference contacts found: &quot;+peopleObj.length);&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Failed to get reference contact record: &quot; + peopleResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}&#xD;
	&#xD;
	//Add the reference contact record to the current CAP &#xD;
	var contactAddResult = aa.people.createCapContactWithRefPeopleModel(capId, peopleObj[0]);&#xD;
	if (contactAddResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Contact successfully added to CAP.&quot;);&#xD;
		var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var Contacts = capContactResult.getOutput();&#xD;
			var idx = Contacts.length;&#xD;
			var contactNbr = Contacts[idx-1].getCapContactModel().getPeople().getContactSeqNumber();&#xD;
			logDebug (&quot;Contact Nbr = &quot;+contactNbr);&#xD;
			return contactNbr;&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Failed to get Contact Nbr: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
			logDebug(&quot;**ERROR: Cannot add contact: &quot; + contactAddResult.getErrorMessage()); &#xD;
			return false; &#xD;
		}	&#xD;
	} &#xD;
	&#xD;
 &#xD;
function contactSetPrimary(pContactNbr)&#xD;
	{&#xD;
	// Makes contact the Primary Contact&#xD;
	// 06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setFlag(&quot;Y&quot;);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact successfully set to Primary&quot;);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not set contact to Primary: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function contactSetRelation(pContactNbr, pRelation)&#xD;
	{&#xD;
	// Edits Contact Relationship for specified Contact&#xD;
	//06SSP-00186&#xD;
	//&#xD;
	if (pContactNbr==null)&#xD;
		{&#xD;
		logDebug(&quot;ContactNbr parameter is null&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var capContactResult = aa.people.getCapContactByPK(capId, pContactNbr);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			var contact = capContactResult.getOutput();&#xD;
			//logDebug(&quot;contact class is &quot;+contact.getClass());&#xD;
			var peopleObj=contact.getCapContactModel().getPeople();&#xD;
			peopleObj.setRelation(pRelation);&#xD;
			contact.getCapContactModel().setPeople(peopleObj);&#xD;
			var editResult = aa.people.editCapContact(contact.getCapContactModel());&#xD;
			if (editResult.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Contact relationship successfully changed to &quot;+pRelation);&#xD;
				return true;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;**ERROR: Could not change contact relationship: &quot;+editResult.getErrorMessage());&#xD;
				return false;&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;**ERROR: Can't get contact: &quot;+capContactResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyAddresses(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all property addresses from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	//check if target CAP has primary address	&#xD;
	var priAddrExists = false;&#xD;
	var capAddressResult = aa.address.getAddressByCapId(vToCapId);&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			if (&quot;Y&quot;==Address[yy].getPrimaryFlag())&#xD;
				{&#xD;
				priAddrExists = true;&#xD;
				logDebug(&quot;Target CAP has primary address&quot;);&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
		&#xD;
	//get addresses from originating CAP	&#xD;
	var capAddressResult = aa.address.getAddressByCapId(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capAddressResult.getSuccess())&#xD;
		{&#xD;
		Address = capAddressResult.getOutput();&#xD;
		for (yy in Address)&#xD;
			{&#xD;
			newAddress = Address[yy];&#xD;
			newAddress.setCapID(vToCapId);&#xD;
			if (priAddrExists)&#xD;
				newAddress.setPrimaryFlag(&quot;N&quot;); //prevent target CAP from having more than 1 primary address&#xD;
			aa.address.createAddress(newAddress);&#xD;
			logDebug(&quot;Copied address from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get addresses: &quot; + capAddressResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyAppSpecific(newCap) // copy all App Specific info into new Cap&#xD;
	{&#xD;
	for (asi in AInfo)&#xD;
	  	editAppSpecific(asi,AInfo[asi],newCap)&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyASIFields(sourceCapId,targetCapId)  // optional fields to ignore&#xD;
	{&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=1; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var targetCap = aa.cap.getCap(targetCapId).getOutput();&#xD;
	var targetCapType = targetCap.getCapType();&#xD;
	var targetCapTypeString = targetCapType.toString();&#xD;
	var targetCapTypeArray = targetCapTypeString.split(&quot;/&quot;);&#xD;
&#xD;
	var sourceASIResult = aa.appSpecificInfo.getByCapID(sourceCapId)&#xD;
&#xD;
	if (sourceASIResult.getSuccess())&#xD;
		{ var sourceASI = sourceASIResult.getOutput(); }&#xD;
	else&#xD;
		{ aa.print( &quot;**ERROR: getting source ASI: &quot; + sourceASIResult.getErrorMessage()); return false }&#xD;
&#xD;
	for (ASICount in sourceASI)&#xD;
		  {&#xD;
		  thisASI = sourceASI[ASICount];&#xD;
&#xD;
		  if (!exists(thisASI.getCheckboxType(),ignoreArray))&#xD;
		       {&#xD;
		       thisASI.setPermitID1(targetCapId.getID1())&#xD;
		       thisASI.setPermitID2(targetCapId.getID2())&#xD;
		       thisASI.setPermitID3(targetCapId.getID3())&#xD;
		       thisASI.setPerType(targetCapTypeArray[1])&#xD;
		       thisASI.setPerSubType(targetCapTypeArray[2])&#xD;
		       aa.cap.createCheckbox(thisASI)&#xD;
		       }&#xD;
  		  }&#xD;
	}&#xD;
 &#xD;
function copyCalcVal(fromcap,newcap)&#xD;
	{&#xD;
	// 8/8/2008 JHS  creatBCalcValuatn method began using the script model after 6.4  updated this function&#xD;
	if (!newcap)&#xD;
		{ logMessage(&quot;**WARNING: copyCalcVal was passed a null new cap ID&quot;); return false; }&#xD;
&#xD;
	var valResult = aa.finance.getCalculatedValuation(fromcap,null);&#xD;
	if (valResult.getSuccess())&#xD;
		var valArray = valResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get calc val array: &quot; + valResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (thisCV in valArray)&#xD;
		{&#xD;
		var bcv = valArray[thisCV];&#xD;
		bcv.setCapID(newcap);&#xD;
		createResult = aa.finance.createBCalcValuatn(bcv);&#xD;
		if (!createResult.getSuccess())&#xD;
			{ logMessage(&quot;**ERROR: Creating new calc valuatn on target cap ID: &quot; + createResult.getErrorMessage()); return false; }&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function copyConditions(fromCapId)&#xD;
	{&#xD;
	var getFromCondResult = aa.capCondition.getCapConditions(fromCapId);&#xD;
	if (getFromCondResult.getSuccess())&#xD;
		var condA = getFromCondResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
		&#xD;
	for (cc in condA)&#xD;
		{&#xD;
		var thisC = condA[cc];&#xD;
		&#xD;
		var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
		if (addCapCondResult.getSuccess())&#xD;
			logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: adding condition (&quot; + cImpact + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyConditionsFromParcel(parcelIdString)&#xD;
		{&#xD;
		var getFromCondResult = aa.parcelCondition.getParcelConditions(parcelIdString)&#xD;
		if (getFromCondResult.getSuccess())&#xD;
			var condA = getFromCondResult.getOutput();&#xD;
		else&#xD;
			{ logDebug( &quot;**WARNING: getting parcel conditions: &quot; + getFromCondResult.getErrorMessage()) ; return false}&#xD;
			&#xD;
		for (cc in condA)&#xD;
			{&#xD;
			var thisC = condA[cc];&#xD;
			&#xD;
			if (!appHasCondition(thisC.getConditionType(),null,thisC.getConditionDescription(),thisC.getImpactCode()))&#xD;
				{&#xD;
				var addCapCondResult = aa.capCondition.addCapCondition(capId, thisC.getConditionType(), thisC.getConditionDescription(), thisC.getConditionComment(), thisC.getEffectDate(), thisC.getExpireDate(), sysDate, thisC.getRefNumber1(),thisC.getRefNumber2(), thisC.getImpactCode(), thisC.getIssuedByUser(), thisC.getStatusByUser(), thisC.getConditionStatus(), currentUserID, &quot;A&quot;)&#xD;
				if (addCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully added condition (&quot; +  thisC.getImpactCode() + &quot;) &quot; +  thisC.getConditionDescription());&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: adding condition (&quot; + thisC.getImpactCode() + &quot;): &quot; + addCapCondResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**WARNING: adding condition (&quot; + thisC.getImpactCode() + &quot;): condition already exists&quot;);&#xD;
				&#xD;
			}&#xD;
		}&#xD;
 &#xD;
function copyContacts(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all contacts from pFromCapId to pToCapId&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var capContactResult = aa.people.getCapContactByCapID(pFromCapId);&#xD;
	var copied = 0;&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var newContact = Contacts[yy].getCapContactModel();&#xD;
			newContact.setCapID(vToCapId);&#xD;
			aa.people.createCapContact(newContact);&#xD;
			copied++;&#xD;
			logDebug(&quot;Copied contact from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get contacts: &quot; + capContactResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copyFees(sourceCapId,targetCapId)&#xD;
	{&#xD;
&#xD;
	var feeSeqArray = new Array();&#xD;
	var invoiceNbrArray = new Array();&#xD;
	var feeAllocationArray = new Array();&#xD;
&#xD;
	var feeA = loadFees(sourceCapId)&#xD;
&#xD;
	for (x in feeA)&#xD;
		{&#xD;
		thisFee = feeA[x];&#xD;
		&#xD;
		logMessage(&quot;We have a fee &quot; + thisFee.code + &quot; status : &quot; + thisFee.status);&#xD;
		&#xD;
		if (thisFee.status == &quot;INVOICED&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;Y&quot;,targetCapId)&#xD;
&#xD;
			var feeSeqArray = new Array();&#xD;
			var paymentPeriodArray = new Array();&#xD;
&#xD;
			feeSeqArray.push(thisFee.sequence);&#xD;
			paymentPeriodArray.push(thisFee.period);&#xD;
			var invoiceResult_L = aa.finance.createInvoice(sourceCapId, feeSeqArray, paymentPeriodArray);&#xD;
&#xD;
			if (!invoiceResult_L.getSuccess())&#xD;
				aa.print(&quot;**ERROR: Invoicing the fee items voided &quot; + thisFee.code + &quot; was not successful.  Reason: &quot; +  invoiceResult_L.getErrorMessage());&#xD;
			}&#xD;
&#xD;
&#xD;
		if (thisFee.status == &quot;NEW&quot;)&#xD;
			{&#xD;
			addFee(thisFee.code,thisFee.sched,thisFee.period,thisFee.unit,&quot;N&quot;,targetCapId)&#xD;
			}&#xD;
&#xD;
		}&#xD;
&#xD;
	}&#xD;
 &#xD;
function copyParcelGisObjects() &#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
			logDebug(&quot;Looking at parcel &quot; + ParcelValidatedNumber);&#xD;
			var gisObjResult = aa.gis.getParcelGISObjects(ParcelValidatedNumber); // get gis objects on the parcel number&#xD;
			if (gisObjResult.getSuccess()) 	&#xD;
				var fGisObj = gisObjResult.getOutput();&#xD;
			else&#xD;
				{ logDebug(&quot;**ERROR: Getting GIS objects for Parcel.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
			for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
				{&#xD;
				var gisTypeScriptModel = fGisObj[a1];&#xD;
                                var gisObjArray = gisTypeScriptModel.getGISObjects()&#xD;
                                for (b1 in gisObjArray)&#xD;
                                	{&#xD;
  					var gisObjScriptModel = gisObjArray[b1];&#xD;
  					var gisObjModel = gisObjScriptModel.getGisObjectModel() ;&#xD;
&#xD;
					var retval = aa.gis.addCapGISObject(capId,gisObjModel.getServiceID(),gisObjModel.getLayerId(),gisObjModel.getGisId());&#xD;
&#xD;
					if (retval.getSuccess())&#xD;
						{ logDebug(&quot;Successfully added Cap GIS object: &quot; + gisObjModel.getGisId())}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Could not add Cap GIS Object.  Reason is: &quot; + retval.getErrorType() + &quot;:&quot; + retval.getErrorMessage()) ; return false }	&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting Parcels from Cap.  Reason is: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
	}&#xD;
&#xD;
 &#xD;
function copyParcels(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all parcels from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
				&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(pFromCapId,null);&#xD;
	var copied = 0;&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{&#xD;
		var Parcels = capParcelResult.getOutput().toArray();&#xD;
		for (zz in Parcels)&#xD;
			{&#xD;
			var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
			newCapParcel.setParcelModel(Parcels[zz]);&#xD;
			newCapParcel.setCapIDModel(vToCapId);&#xD;
			newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
			newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
			aa.parcel.createCapParcel(newCapParcel);&#xD;
			logDebug(&quot;Copied parcel &quot;+Parcels[zz].getParcelNumber()+&quot; from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
			copied++;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get parcels: &quot; + capParcelResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	return copied;&#xD;
	} &#xD;
function copySchedInspections(pFromCapId, pToCapId)&#xD;
	{&#xD;
	//Copies all scheduled inspections from pFromCapId to pToCapId&#xD;
	//If pToCapId is null, copies to current CAP&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	if (pToCapId==null)&#xD;
		var vToCapId = capId;&#xD;
	else&#xD;
		var vToCapId = pToCapId;&#xD;
		&#xD;
	var inspResultObj = aa.inspection.getInspections(pFromCapId);&#xD;
	&#xD;
	if (!inspResultObj.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get inspections: &quot; + inspResultObj.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var inspCount = 0;&#xD;
	var schedRes;&#xD;
	var inspector;&#xD;
	var inspDate;&#xD;
	var inspTime;&#xD;
	var inspType;&#xD;
	var inspComment;	&#xD;
	&#xD;
	var inspList = inspResultObj.getOutput();&#xD;
	for (xx in inspList)&#xD;
		{&#xD;
		if (&quot;Insp Scheduled&quot;==inspList[xx].getDocumentDescription())&#xD;
			{&#xD;
			inspector = inspList[xx].getInspector();&#xD;
			inspDate = inspList[xx].getScheduledDate();&#xD;
			inspTime = inspList[xx].getScheduledTime();&#xD;
			inspType = inspList[xx].getInspectionType();&#xD;
			inspComment = inspList[xx].getInspectionComments();&#xD;
			schedRes = aa.inspection.scheduleInspection(vToCapId, inspector, inspDate, inspTime, inspType, inspComment);&#xD;
			if (schedRes.getSuccess())&#xD;
				{&#xD;
				logDebug(&quot;Copied scheduled inspection from &quot;+pFromCapId.getCustomID()+&quot; to &quot;+vToCapId.getCustomID());&#xD;
				inspCount++;&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: copying scheduling inspection (&quot; + inspType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	return inspCount;	&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function countActiveTasks(processName)&#xD;
	{&#xD;
	// counts the number of active tasks on a given process&#xD;
        var numOpen = 0;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
		if (fTask.getProcessCode().equals(processName))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				numOpen++;&#xD;
		}&#xD;
	return numOpen;&#xD;
	}&#xD;
	&#xD;
 &#xD;
function countIdenticalInspections()&#xD;
	{&#xD;
	var cntResult = 0;&#xD;
	var oldDateStr = &quot;01/01/1900&quot;;  // inspections older than this date count as 1&#xD;
	if (arguments.length &gt; 0) oldDateStr = arguments[0]; // Option to override olddate in the parameter&#xD;
	oldDate = new Date(&quot;oldDateStr&quot;);&#xD;
	&#xD;
	var oldInspectionFound = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			{&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; String(inspResult).equals(inspList[xx].getInspectionStatus()))&#xD;
				{&#xD;
				if (convertDate(inspList[xx].getInspectionStatusDate()) &lt; oldDate)&#xD;
					{&#xD;
					if (!oldInspectionFound) { cntResult++ ; oldInspectionFound = true }&#xD;
					}&#xD;
				else&#xD;
					{&#xD;
					cntResult++&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
	logDebug(&quot;countIdenticalInspections(&quot; + inspType + &quot;,&quot; + inspResult + &quot;, &quot; + oldDateStr +  &quot;) Returns &quot; + cntResult);&#xD;
	return cntResult;&#xD;
	}	&#xD;
	 &#xD;
function createCap(pCapType, pAppName) &#xD;
	{&#xD;
	// creates a new application and returns the capID object&#xD;
	// 07SSP-00037/SP5017&#xD;
	//&#xD;
	var aCapType = pCapType.split(&quot;/&quot;);&#xD;
	if (aCapType.length != 4)&#xD;
		{&#xD;
		logDebug(&quot;**ERROR in createCap.  The following Application Type String is incorrectly formatted: &quot; + pCapType);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
	&#xD;
	var appCreateResult = aa.cap.createApp(aCapType[0],aCapType[1],aCapType[2],aCapType[3],pAppName);&#xD;
	logDebug(&quot;Creating cap &quot; + pCapType);&#xD;
	&#xD;
	if (!appCreateResult.getSuccess())&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: creating CAP &quot; + appCreateResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	var newId = appCreateResult.getOutput();&#xD;
	logDebug(&quot;CAP of type &quot; + pCapType + &quot; created successfully &quot;);&#xD;
	var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
	&#xD;
	return newId;&#xD;
	}&#xD;
&#xD;
 &#xD;
function createChild(grp,typ,stype,cat,desc) &#xD;
//&#xD;
// creates the new application and returns the capID object&#xD;
//&#xD;
	{&#xD;
	var appCreateResult = aa.cap.createApp(grp,typ,stype,cat,desc);&#xD;
	logDebug(&quot;creating cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat);&#xD;
	if (appCreateResult.getSuccess())&#xD;
		{&#xD;
		var newId = appCreateResult.getOutput();&#xD;
		logDebug(&quot;cap &quot; + grp + &quot;/&quot; + typ + &quot;/&quot; + stype + &quot;/&quot; + cat + &quot; created successfully &quot;);&#xD;
		&#xD;
		// create Detail Record&#xD;
		capModel = aa.cap.newCapScriptModel().getOutput();&#xD;
		capDetailModel = capModel.getCapModel().getCapDetailModel();&#xD;
		capDetailModel.setCapID(newId);&#xD;
		aa.cap.createCapDetail(capDetailModel);&#xD;
&#xD;
		var newObj = aa.cap.getCap(newId).getOutput();	//Cap object&#xD;
		var result = aa.cap.createAppHierarchy(capId, newId); &#xD;
		if (result.getSuccess())&#xD;
			logDebug(&quot;Child application successfully linked&quot;);&#xD;
		else&#xD;
			logDebug(&quot;Could not link applications&quot;);&#xD;
&#xD;
		// Copy Parcels&#xD;
&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				logDebug(&quot;adding parcel #&quot; + zz + &quot; = &quot; + Parcels[zz].getParcelNumber());&#xD;
				var newCapParcel = aa.parcel.getCapParcelModel().getOutput();&#xD;
				newCapParcel.setParcelModel(Parcels[zz]);&#xD;
				newCapParcel.setCapIDModel(newId);&#xD;
				newCapParcel.setL1ParcelNo(Parcels[zz].getParcelNumber());&#xD;
				newCapParcel.setParcelNo(Parcels[zz].getParcelNumber());&#xD;
				aa.parcel.createCapParcel(newCapParcel);&#xD;
				}&#xD;
			}&#xD;
&#xD;
		// Copy Contacts&#xD;
		capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
		if (capContactResult.getSuccess())&#xD;
			{&#xD;
			Contacts = capContactResult.getOutput();&#xD;
			for (yy in Contacts)&#xD;
				{&#xD;
				var newContact = Contacts[yy].getCapContactModel();&#xD;
				newContact.setCapID(newId);&#xD;
				aa.people.createCapContact(newContact);&#xD;
				logDebug(&quot;added contact&quot;);&#xD;
				}&#xD;
			}	&#xD;
&#xD;
		// Copy Addresses&#xD;
		capAddressResult = aa.address.getAddressByCapId(capId);&#xD;
		if (capAddressResult.getSuccess())&#xD;
			{&#xD;
			Address = capAddressResult.getOutput();&#xD;
			for (yy in Address)&#xD;
				{&#xD;
				newAddress = Address[yy];&#xD;
				newAddress.setCapID(newId);&#xD;
				aa.address.createAddress(newAddress);&#xD;
				logDebug(&quot;added address&quot;);&#xD;
				}&#xD;
			}&#xD;
		&#xD;
		return newId;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug( &quot;**ERROR: adding child App: &quot; + appCreateResult.getErrorMessage());&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProf(rlpId,rlpType,pContactType)&#xD;
	{&#xD;
	//Creates/updates a reference licensed prof from a Contact&#xD;
	//06SSP-00074, modified for 06SSP-00238&#xD;
	var updating = false;&#xD;
	var capContResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContResult.getSuccess())&#xD;
		{ conArr = capContResult.getOutput();  }&#xD;
	else&#xD;
		{&#xD;
		logDebug (&quot;**ERROR: getting cap contact: &quot; + capAddResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	if (!conArr.length)&#xD;
		{&#xD;
		logDebug (&quot;**WARNING: No contact available&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//get contact record&#xD;
	if (pContactType==null)&#xD;
		var cont = conArr[0]; //if no contact type specified, use first contact&#xD;
	else&#xD;
		{&#xD;
		var contFound = false;&#xD;
		for (yy in conArr)&#xD;
			{&#xD;
			if (pContactType.equals(conArr[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				{&#xD;
				cont = conArr[yy];&#xD;
				contFound = true;&#xD;
				break;&#xD;
				}&#xD;
			}&#xD;
		if (!contFound)&#xD;
			{&#xD;
			logDebug (&quot;**WARNING: No Contact found of type: &quot;+pContactType);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	peop = cont.getPeople();&#xD;
	addr = peop.getCompactAddress();&#xD;
&#xD;
	newLic.setContactFirstName(cont.getFirstName());&#xD;
	//newLic.setContactMiddleName(cont.getMiddleName());  //method not available&#xD;
	newLic.setContactLastName(cont.getLastName());&#xD;
	newLic.setBusinessName(peop.getBusinessName());&#xD;
	newLic.setAddress1(addr.getAddressLine1());&#xD;
	newLic.setAddress2(addr.getAddressLine2());&#xD;
	newLic.setAddress3(addr.getAddressLine3());&#xD;
	newLic.setCity(addr.getCity());&#xD;
	newLic.setState(addr.getState());&#xD;
	newLic.setZip(addr.getZip());&#xD;
	newLic.setPhone1(peop.getPhone1());&#xD;
	newLic.setPhone2(peop.getPhone2());&#xD;
	newLic.setEMailAddress(peop.getEmail());&#xD;
	newLic.setFax(peop.getFax());&#xD;
&#xD;
	newLic.setAgencyCode(aa.getServiceProviderCode());&#xD;
	newLic.setAuditDate(sysDate);&#xD;
	newLic.setAuditID(currentUserID);&#xD;
	newLic.setAuditStatus(&quot;A&quot;);&#xD;
&#xD;
	if (AInfo[&quot;Insurance Co&quot;]) 		newLic.setInsuranceCo(AInfo[&quot;Insurance Co&quot;]);&#xD;
	if (AInfo[&quot;Insurance Amount&quot;]) 		newLic.setInsuranceAmount(parseFloat(AInfo[&quot;Insurance Amount&quot;]));&#xD;
	if (AInfo[&quot;Insurance Exp Date&quot;]) 	newLic.setInsuranceExpDate(aa.date.parseDate(AInfo[&quot;Insurance Exp Date&quot;]));&#xD;
	if (AInfo[&quot;Policy #&quot;]) 			newLic.setPolicy(AInfo[&quot;Policy #&quot;]);&#xD;
&#xD;
	if (AInfo[&quot;Business License #&quot;]) 	newLic.setBusinessLicense(AInfo[&quot;Business License #&quot;]);&#xD;
	if (AInfo[&quot;Business License Exp Date&quot;]) newLic.setBusinessLicExpDate(aa.date.parseDate(AInfo[&quot;Business License Exp Date&quot;]));&#xD;
&#xD;
	newLic.setLicenseType(rlpType);&#xD;
	newLic.setLicState(addr.getState());&#xD;
	newLic.setStateLicense(rlpId);&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		logMessage(&quot;Successfully added/updated License No. &quot; + rlpId + &quot;, Type: &quot; + rlpType);&#xD;
		return true;&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		logMessage(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
&#xD;
function createRefLicProfFromLicProf()&#xD;
	{&#xD;
	//&#xD;
	// Get the lic prof from the app&#xD;
	//&#xD;
	capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
&#xD;
	if (!capLicenseArr.length)&#xD;
		{ logDebug(&quot;WARNING: no license professional available on the application:&quot;); return false; }&#xD;
&#xD;
	licProfScriptModel = capLicenseArr[0];&#xD;
	rlpId = licProfScriptModel.getLicenseNbr();&#xD;
	//&#xD;
	// Now see if a reference version exists&#xD;
	//&#xD;
	var updating = false;&#xD;
&#xD;
	var newLic = getRefLicenseProf(rlpId)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		updating = true;&#xD;
		logDebug(&quot;Updating existing Ref Lic Prof : &quot; + rlpId);&#xD;
		}&#xD;
	else&#xD;
		var newLic = aa.licenseScript.createLicenseScriptModel();&#xD;
&#xD;
	//&#xD;
	// Now add / update the ref lic prof&#xD;
	//&#xD;
	newLic.setStateLicense(rlpId);&#xD;
	newLic.setAddress1(licProfScriptModel.getAddress1());&#xD;
	newLic.setAddress2(licProfScriptModel.getAddress2());&#xD;
	newLic.setAddress3(licProfScriptModel.getAddress3());&#xD;
	newLic.setAgencyCode(licProfScriptModel.getAgencyCode());&#xD;
	newLic.setAuditDate(licProfScriptModel.getAuditDate());&#xD;
	newLic.setAuditID(licProfScriptModel.getAuditID());&#xD;
	newLic.setAuditStatus(licProfScriptModel.getAuditStatus());&#xD;
	newLic.setBusinessLicense(licProfScriptModel.getBusinessLicense());&#xD;
	newLic.setBusinessName(licProfScriptModel.getBusinessName());&#xD;
	newLic.setCity(licProfScriptModel.getCity());&#xD;
	newLic.setCityCode(licProfScriptModel.getCityCode());&#xD;
	newLic.setContactFirstName(licProfScriptModel.getContactFirstName());&#xD;
	newLic.setContactLastName(licProfScriptModel.getContactLastName());&#xD;
	newLic.setContactMiddleName(licProfScriptModel.getContactMiddleName());&#xD;
	newLic.setContryCode(licProfScriptModel.getCountryCode());&#xD;
	newLic.setCountry(licProfScriptModel.getCountry());&#xD;
	newLic.setEinSs(licProfScriptModel.getEinSs());&#xD;
	newLic.setEMailAddress(licProfScriptModel.getEmail());&#xD;
	newLic.setFax(licProfScriptModel.getFax());&#xD;
	newLic.setLicenseType(licProfScriptModel.getLicenseType());&#xD;
	newLic.setLicOrigIssDate(licProfScriptModel.getLicesnseOrigIssueDate());&#xD;
	newLic.setPhone1(licProfScriptModel.getPhone1());&#xD;
	newLic.setPhone2(licProfScriptModel.getPhone2());&#xD;
	newLic.setSelfIns(licProfScriptModel.getSelfIns());&#xD;
	newLic.setState(licProfScriptModel.getState());&#xD;
	newLic.setLicState(licProfScriptModel.getState());&#xD;
	newLic.setSuffixName(licProfScriptModel.getSuffixName());&#xD;
	newLic.setWcExempt(licProfScriptModel.getWorkCompExempt());&#xD;
	newLic.setZip(licProfScriptModel.getZip());&#xD;
&#xD;
	if (updating)&#xD;
		myResult = aa.licenseScript.editRefLicenseProf(newLic);&#xD;
	else&#xD;
		myResult = aa.licenseScript.createRefLicenseProf(newLic);&#xD;
&#xD;
	if (myResult.getSuccess())&#xD;
		{&#xD;
		logDebug(&quot;Successfully added/updated License ID : &quot; + rlpId)&#xD;
		return rlpId;&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: can't create ref lic prof: &quot; + myResult.getErrorMessage()); }&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAdd(td,amt)&#xD;
	// perform date arithmetic on a string&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or any string that will convert to JS date)&#xD;
	// amt can be positive or negative (5, -3) days&#xD;
	// if optional parameter #3 is present, use working days only&#xD;
	{&#xD;
&#xD;
	var useWorking = false;&#xD;
	if (arguments.length == 3)&#xD;
		useWorking = true;&#xD;
&#xD;
	if (!td)&#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
	var i = 0;&#xD;
	if (useWorking)&#xD;
		if (!aa.calendar.getNextWorkDay)&#xD;
			{&#xD;
			logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * (amt &gt; 0 ? 1 : -1)));&#xD;
				if (dDate.getDay() &gt; 0 &amp;&amp; dDate.getDay() &lt; 6)&#xD;
					i++&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			while (i &lt; Math.abs(amt))&#xD;
				{&#xD;
				dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
				i++;&#xD;
				}&#xD;
			}&#xD;
	else&#xD;
		dDate.setTime(dDate.getTime() + (1000 * 60 * 60 * 24 * amt));&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateAddMonths(pDate, pMonths)&#xD;
	{&#xD;
	// Adds specified # of months (pMonths) to pDate and returns new date as string in format MM/DD/YYYY&#xD;
	// If pDate is null, uses current date&#xD;
	// pMonths can be positive (to add) or negative (to subtract) integer&#xD;
	// If pDate is on the last day of the month, the new date will also be end of month.&#xD;
	// If pDate is not the last day of the month, the new date will have the same day of month, unless such a day doesn't exist in the month, in which case the new date will be on the last day of the month&#xD;
	//&#xD;
	if (!pDate)&#xD;
		baseDate = new Date();&#xD;
	else&#xD;
		baseDate = new Date(pDate);&#xD;
&#xD;
	var day = baseDate.getDate();&#xD;
	baseDate.setMonth(baseDate.getMonth() + pMonths);&#xD;
	if (baseDate.getDate() &lt; day)&#xD;
		{&#xD;
		baseDate.setDate(1);&#xD;
		baseDate.setDate(baseDate.getDate() - 1);&#xD;
		}&#xD;
	return ((baseDate.getMonth() + 1) + &quot;/&quot; + baseDate.getDate() + &quot;/&quot; + baseDate.getFullYear());&#xD;
	}&#xD;
&#xD;
 &#xD;
function dateFormatted(pMonth,pDay,pYear,pFormat)&#xD;
//returns date string formatted as YYYY-MM-DD or MM/DD/YYYY (default)&#xD;
	{&#xD;
	var mth = &quot;&quot;;&#xD;
	var day = &quot;&quot;;&#xD;
	var ret = &quot;&quot;;&#xD;
	if (pMonth &gt; 9)&#xD;
		mth = pMonth.toString();&#xD;
	else&#xD;
		mth = &quot;0&quot;+pMonth.toString();&#xD;
&#xD;
	if (pDay &gt; 9)&#xD;
		day = pDay.toString();&#xD;
	else&#xD;
		day = &quot;0&quot;+pDay.toString();&#xD;
&#xD;
	if (pFormat==&quot;YYYY-MM-DD&quot;)&#xD;
		ret = pYear.toString()+&quot;-&quot;+mth+&quot;-&quot;+day;&#xD;
	else&#xD;
		ret = &quot;&quot;+mth+&quot;/&quot;+day+&quot;/&quot;+pYear.toString();&#xD;
&#xD;
	return ret;&#xD;
	}&#xD;
 &#xD;
function dateNextOccur (pMonth, pDay, pDate)&#xD;
	//optional 4th param pOddEven:&#xD;
	//'ODD' specifies that return date must be next odd year, 'EVEN' means return date is next even year.&#xD;
	//allows wfDate variable to be used as pDate parameter&#xD;
	{&#xD;
	var vDate = new String(pDate);&#xD;
	if (vDate.length==10 &amp;&amp; vDate.indexOf(&quot;-&quot;)==4 &amp;&amp; vDate.indexOf(&quot;-&quot;,7)==7) //is format YYYY-MM-DD&#xD;
		var vBaseDate = new Date(vDate.substr(5,2)+&quot;/&quot;+vDate.substr(8,2)+&quot;/&quot;+vDate.substr(0,4));&#xD;
	else&#xD;
		var vBaseDate = new Date(vDate);&#xD;
&#xD;
	var vCurrentYr = vBaseDate.getFullYear().toString();&#xD;
	var vTestDate = new Date(pMonth+&quot;/&quot;+pDay+&quot;/&quot;+vCurrentYr);&#xD;
	var vUseOddEven = false;&#xD;
	var vOddEven;&#xD;
	var vReturnDate = vTestDate;&#xD;
	if (arguments.length&gt;3) //optional 4th parameter is used&#xD;
		{&#xD;
		var vOddEven = arguments[3].toUpperCase(); //return odd or even year&#xD;
		vUseOddEven = true;&#xD;
		}&#xD;
		&#xD;
	if (vTestDate &gt; vBaseDate)&#xD;
		vReturnDate = vTestDate;&#xD;
	else&#xD;
		{	&#xD;
		vTestDate.setFullYear(vTestDate.getFullYear()+1);&#xD;
		vReturnDate = vTestDate;&#xD;
		}&#xD;
 		&#xD;
	if (vUseOddEven) // use next ODD or EVEN year&#xD;
		{&#xD;
		if (vOddEven==&quot;ODD&quot; &amp;&amp; vReturnDate.getFullYear()%2==0) //vReturnDate is EVEN year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
&#xD;
		if (vOddEven==&quot;EVEN&quot; &amp;&amp; vReturnDate.getFullYear()%2)    //vReturnDate is ODD year&#xD;
			vReturnDate.setFullYear(vReturnDate.getFullYear()+1);&#xD;
		}&#xD;
&#xD;
	return (vReturnDate.getMonth()+1) + &quot;/&quot; + vReturnDate.getDate() + &quot;/&quot; + vReturnDate.getFullYear();  &#xD;
	}&#xD;
&#xD;
 &#xD;
function deactivateTask(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			var completeFlag = fTask.getCompleteFlag();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.adjustTask(capId, stepnumber, processID, &quot;N&quot;, completeFlag, null, null)&#xD;
			else&#xD;
				aa.workflow.adjustTask(capId, stepnumber, &quot;N&quot;, completeFlag, null, null)&#xD;
&#xD;
			logMessage(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			logDebug(&quot;deactivating Workflow Task: &quot; + wfstr);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppName(newname)&#xD;
	{&#xD;
	// 4/30/08 - DQ - Corrected Error where option parameter was ignored&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	capResult = aa.cap.getCap(itemCap)&#xD;
&#xD;
	if (!capResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap : &quot; + capResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	capModel = capResult.getOutput().getCapModel()&#xD;
&#xD;
	capModel.setSpecialText(newname)&#xD;
&#xD;
	setNameResult = aa.cap.editCapByPK(capModel)&#xD;
&#xD;
	if (!setNameResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error setting cap name : &quot; + setNameResult.getErrorMessage()) ; return false }&#xD;
&#xD;
&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function editAppSpecific(itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
   	&#xD;
  	if (useAppSpecificGroupName)&#xD;
		{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
		}&#xD;
   	&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
			{&#xD;
				while (i &lt; appspecObj.length &amp;&amp; !updated)&#xD;
				{&#xD;
					if (appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup))&#xD;
					{&#xD;
						appspecObj[i].setChecklistComment(itemValue);&#xD;
						var actionResult = aa.appSpecificInfo.editAppSpecInfos(appspecObj);&#xD;
						if (actionResult.getSuccess()) {&#xD;
							logMessage(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
							logDebug(&quot;app spec info item &quot; + itemName + &quot; has been given a value of &quot; + itemValue);&#xD;
						} else {&#xD;
							logDebug(&quot;**ERROR: Setting the app spec info item &quot; + itemName + &quot; to &quot; + itemValue + &quot; .\nReason is: &quot; +   actionResult.getErrorType() + &quot;:&quot; + actionResult.getErrorMessage());&#xD;
						}&#xD;
						updated = true;&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
					}&#xD;
					i++;&#xD;
				} // while loop&#xD;
			} // item name blank&#xD;
		} // got app specific object	&#xD;
		else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function editChannelReported(channel) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setReportedChannel(channel);&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated channel reported to &quot; + channel) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editContactType(existingType,newType)&#xD;
//Function will change contact types from exsistingType to newType, &#xD;
//optional paramter capID&#xD;
{&#xD;
	var updateCap = capId&#xD;
	if (arguments.length==3)&#xD;
		updateCap=arguments[2]&#xD;
&#xD;
	capContactResult = aa.people.getCapContactByCapID(updateCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			{&#xD;
			var theContact = Contacts[yy].getCapContactModel();&#xD;
			if(theContact.getContactType() == existingType)&#xD;
				{&#xD;
				theContact.setContactType(newType);&#xD;
				aa.people.editCapContact(theContact);&#xD;
				logDebug(&quot;Contact for &quot; + theContact.getFullName() + &quot; Updated to &quot; + newType);&#xD;
				}&#xD;
			}&#xD;
		}	&#xD;
} &#xD;
function editHouseCount(numHouse) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
	&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
		&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
	&#xD;
	cd.setHouseCount(parseFloat(numHouse));&#xD;
		&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
	&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;Updated house count to &quot; + numHouse); return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
&#xD;
function editLookup(stdChoice,stdValue,stdDesc) &#xD;
	{&#xD;
	//check if stdChoice and stdValue already exist; if they do, update;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	if (bizDomScriptResult.getSuccess())&#xD;
		{&#xD;
		bds = bizDomScriptResult.getOutput();&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist to edit, adding...&quot;);&#xD;
		addLookup(stdChoice,stdValue,stdDesc);&#xD;
		return false;&#xD;
		}&#xD;
	var bd = bds.getBizDomain()&#xD;
		&#xD;
	bd.setDescription(stdDesc);&#xD;
	var editResult = aa.bizDomain.editBizDomain(bd)&#xD;
	&#xD;
	if (editResult.getSuccess())&#xD;
		logDebug(&quot;Successfully edited Std Choice(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + stdDesc);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR editing Std Choice &quot; + editResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function editPriority(priority) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setPriority(priority);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated priority to &quot; + priority) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
&#xD;
function editRefLicProfAttribute(pLicNum,pAttributeName,pNewAttributeValue)&#xD;
	{&#xD;
&#xD;
	var attrfound = false;&#xD;
	var oldValue = null;&#xD;
&#xD;
	licObj = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (!licObj)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional : &quot; + pLicNum + &quot; not found&quot;) ; return false }&#xD;
&#xD;
	licSeqNum = licObj.getLicSeqNbr();&#xD;
	attributeType = licObj.getLicenseType();&#xD;
&#xD;
	if (licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null)&#xD;
		{ logDebug(&quot;**WARNING Licensed Professional Sequence Number or Attribute Type missing&quot;) ; return false }&#xD;
&#xD;
	var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
&#xD;
	if (!peopAttrResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage()); return false }&#xD;
&#xD;
	var peopAttrArray = peopAttrResult.getOutput();&#xD;
&#xD;
	for (i in peopAttrArray)&#xD;
		{&#xD;
		if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()))&#xD;
			{&#xD;
			oldValue = peopAttrArray[i].getAttributeValue()&#xD;
			attrfound = true;&#xD;
			break;&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (attrfound)&#xD;
		{&#xD;
		logDebug(&quot;Updated Ref Lic Prof: &quot; + pLicNum + &quot;, attribute: &quot; + pAttributeName + &quot; from: &quot; + oldValue + &quot; to: &quot; + pNewAttributeValue)&#xD;
		peopAttrArray[i].setAttributeValue(pNewAttributeValue);&#xD;
		aa.people.editPeopleAttribute(peopAttrArray[i].getPeopleAttributeModel());&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**WARNING attribute: &quot; + pAttributeName + &quot; not found for Ref Lic Prof: &quot;+ pLicNum)&#xD;
		/* make a new one with the last model.  Not optimal but it should work&#xD;
		newPAM = peopAttrArray[i].getPeopleAttributeModel();&#xD;
		newPAM.setAttributeName(pAttributeName);&#xD;
		newPAM.setAttributeValue(pNewAttributeValue);&#xD;
		newPAM.setAttributeValueDataType(&quot;Number&quot;);&#xD;
		aa.people.createPeopleAttribute(newPAM);&#xD;
		*/&#xD;
		}&#xD;
	} &#xD;
function editReportedChannel(reportedChannel) // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setReportedChannel(reportedChannel);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd);&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated reported channel to &quot; + reportedChannel) ; return true; }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
} &#xD;
function editTaskComment(wfstr,wfcomment) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
  		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDispositionComment(wfcomment);&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow: &quot; + wfstr + &quot; comment &quot; + wfcomment);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update comment on workflow task: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskDueDate(wfstr,wfdate) // optional process name.  if wfstr == &quot;*&quot;, set for all tasks&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			wfObj[i].setDueDate(aa.date.parseDate(wfdate));&#xD;
			var fTaskModel = wfObj[i].getTaskItem();&#xD;
			var tResult = aa.workflow.adjustTaskWithNoAudit(fTaskModel);&#xD;
			if (tResult.getSuccess())&#xD;
				logDebug(&quot;Set Workflow Task: &quot; + fTask.getTaskDescription() + &quot; due Date &quot; + wfdate);&#xD;
		  	else&#xD;
	  	  		{ logMessage(&quot;**ERROR: Failed to update due date on workflow: &quot; + tResult.getErrorMessage()); return false; }&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function editTaskSpecific(wfName,itemName,itemValue)  // optional: itemCap&#xD;
	{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	itemCap = capId;&#xD;
	if (arguments.length == 4) itemCap = arguments[3]; // use cap ID specified in args&#xD;
	//&#xD;
 	// Get the workflows&#xD;
 	//&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
 	//&#xD;
 	// Loop through workflow tasks&#xD;
 	//&#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		fTask = wfObj[i];&#xD;
 		stepnumber = fTask.getStepNumber();&#xD;
 		processID = fTask.getProcessID();&#xD;
 		if (wfName.equals(fTask.getTaskDescription())) // Found the right Workflow Task&#xD;
 			{&#xD;
  		TSIResult = aa.taskSpecificInfo.getTaskSpecifiInfoByDesc(itemCap,processID,stepnumber,itemName);&#xD;
 			if (TSIResult.getSuccess())&#xD;
 				{&#xD;
	 			var TSI = TSIResult.getOutput();&#xD;
				if (TSI != null)&#xD;
					{&#xD;
					var TSIArray = new Array();&#xD;
					TSInfoModel = TSI.getTaskSpecificInfoModel();&#xD;
					TSInfoModel.setChecklistComment(itemValue);&#xD;
					TSIArray.push(TSInfoModel);&#xD;
					TSIUResult = aa.taskSpecificInfo.editTaskSpecInfos(TSIArray);&#xD;
					if (TSIUResult.getSuccess())&#xD;
						{&#xD;
						logDebug(&quot;Successfully updated TSI Task=&quot; + wfName + &quot; Item=&quot; + itemName + &quot; Value=&quot; + itemValue);&#xD;
						AInfo[itemName] = itemValue;  // Update array used by this script&#xD;
						}&#xD;
					else&#xD;
						{ logDebug(&quot;**ERROR: Failed to Update Task Specific Info : &quot; + TSIUResult.getErrorMessage()); return false; }&#xD;
					}&#xD;
				else&#xD;
					logDebug(&quot;No task specific info field called &quot;+itemName+&quot; found for task &quot;+wfName);&#xD;
	 			}&#xD;
	 		else&#xD;
	 			{&#xD;
	 			logDebug(&quot;**ERROR: Failed to get Task Specific Info objects: &quot; + TSIResult.getErrorMessage());&#xD;
	 			return false;&#xD;
	 			}&#xD;
	 		}  // found workflow task&#xD;
		} // each task&#xD;
	}&#xD;
&#xD;
 &#xD;
function email(pToEmail, pFromEmail, pSubject, pText) &#xD;
	{&#xD;
	//Sends email to specified address&#xD;
	//06SSP-00221&#xD;
	//&#xD;
	aa.sendMail(pFromEmail, pToEmail, &quot;&quot;, pSubject, pText);&#xD;
	logDebug(&quot;Email sent to &quot;+pToEmail);&#xD;
	return true;&#xD;
	}&#xD;
&#xD;
 &#xD;
function emailContact(mSubj,mText)   // optional: Contact Type, default Applicant&#xD;
	{&#xD;
	var replyTo = &quot;noreply@accela.com&quot;;&#xD;
	var contactType = &quot;Applicant&quot;&#xD;
	var emailAddress = &quot;&quot;;&#xD;
	&#xD;
	if (arguments.length == 3) contactType = arguments[2]; // use contact type specified&#xD;
   	&#xD;
	var capContactResult = aa.people.getCapContactByCapID(capId);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var Contacts = capContactResult.getOutput();&#xD;
		for (yy in Contacts)&#xD;
			if (contactType.equals(Contacts[yy].getCapContactModel().getPeople().getContactType()))&#xD;
				if (Contacts[yy].getEmail() != null)&#xD;
					emailAddress = Contacts[yy].getEmail();&#xD;
		}	&#xD;
&#xD;
	if (emailAddress.length) &#xD;
		{&#xD;
		aa.sendMail(replyTo, emailAddress, &quot;&quot;, mSubj, mText);&#xD;
		logDebug(&quot;Successfully sent email to &quot; + contactType);&#xD;
		}&#xD;
	else&#xD;
		logDebug(&quot;Couldn't send email to &quot; + contactType + &quot;, no email address&quot;);&#xD;
	}&#xD;
&#xD;
 &#xD;
function executeASITable(tableArray)&#xD;
	{&#xD;
	// Executes an ASI table as if it were script commands&#xD;
	// No capability for else or continuation statements&#xD;
	// Assumes that there are at least three columns named &quot;Enabled&quot;, &quot;Criteria&quot;, &quot;Action&quot;&#xD;
	// Will replace tokens in the controls&#xD;
	&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
&#xD;
	for (xx in tableArray)&#xD;
		{&#xD;
 &#xD;
		var doTableObj = tableArray[xx]; &#xD;
		var myCriteria = doTableObj[&quot;Criteria&quot;]; aa.print(&quot;cri: &quot; + myCriteria)&#xD;
		var myAction = doTableObj[&quot;Action&quot;];  aa.print(&quot;act: &quot; + myAction)&#xD;
		aa.print(&quot;enabled: &quot; + doTableObj[&quot;Enabled&quot;])&#xD;
      &#xD;
		if (doTableObj[&quot;Enabled&quot;] == &quot;Yes&quot;)&#xD;
			if (eval(token(myCriteria)))&#xD;
				eval(token(myAction));&#xD;
&#xD;
		} // next action&#xD;
	//var thisDate = new Date();&#xD;
	//var thisTime = thisDate.getTime();&#xD;
	//logDebug(&quot;Finished executing ASI Table, Elapsed Time: &quot;  + ((thisTime - startTime) / 1000) + &quot; Seconds&quot;)&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeAmount(feestr) &#xD;
	{&#xD;
    // optional statuses to check for (SR5082)&#xD;
    //&#xD;
    var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
        &#xD;
	var feeTotal = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray)) )&#xD;
			feeTotal+=feeObjArr[ff].getFee()&#xD;
			&#xD;
	return feeTotal;&#xD;
	} &#xD;
&#xD;
function feeBalance(feestr)&#xD;
	{&#xD;
	// Searches payment fee items and returns the unpaid balance of a fee item&#xD;
	// Sums fee items if more than one exists.  Optional second parameter fee schedule&#xD;
	var amtFee = 0;&#xD;
	var amtPaid = 0;&#xD;
	var feeSch;&#xD;
	&#xD;
	if (arguments.length == 2) feeSch = arguments[1]; &#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ((!feestr || feestr.equals(feeObjArr[ff].getFeeCod())) &amp;&amp; (!feeSch || feeSch.equals(feeObjArr[ff].getF4FeeItemModel().getFeeSchudle())))&#xD;
			{&#xD;
			amtFee+=feeObjArr[ff].getFee();&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(capId, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (feeObjArr[ff].getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
			}&#xD;
	return amtFee - amtPaid;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeExists(feestr) // optional statuses to check for&#xD;
	{&#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
&#xD;
	//get optional arguments &#xD;
	if (arguments.length &gt; 1)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=1; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if ( feestr.equals(feeObjArr[ff].getFeeCod()) &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			return true;&#xD;
			&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeGetTotByDateRange(pStartDate, pEndDate) &#xD;
	// gets total for fees assessed during date range&#xD;
	// optional fee statuses to check for						&#xD;
	{&#xD;
	//get End and Start Dates&#xD;
	var jsStartDate = new Date(pStartDate);&#xD;
	jsStartDate.setHours(0,0,0,0); //Bring StartDate to 00:00 AM&#xD;
	var jsEndDate = new Date(pEndDate);&#xD;
	jsEndDate.setHours(23,59,59,999); //Bring EndDate close to midnight&#xD;
	&#xD;
	//logDebug(&quot;Start Date: &quot;+ (jsStartDate.getMonth()+1).toString() +&quot;/&quot;+jsStartDate.getDate()+&quot;/&quot;+jsStartDate.getFullYear() + &quot; End Date: &quot; + (jsEndDate.getMonth()+1).toString() +&quot;/&quot;+jsEndDate.getDate()+&quot;/&quot;+jsEndDate.getFullYear());&#xD;
&#xD;
	//get optional arguments &#xD;
	var checkStatus = false;&#xD;
	var statusArray = new Array(); &#xD;
	if (arguments.length &gt; 2)&#xD;
		{&#xD;
		checkStatus = true;&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			statusArray.push(arguments[i]);&#xD;
		}&#xD;
&#xD;
	//get all feeitems on CAP&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	//get total applicable fees&#xD;
	var feesTotal = 0;&#xD;
	var jsFeeDate = new Date();&#xD;
	for (ff in feeObjArr)&#xD;
		{&#xD;
		jsFeeDate.setTime(feeObjArr[ff].getApplyDate().getEpochMilliseconds());&#xD;
		//logDebug(&quot;Fee Apply Date: &quot;+(jsFeeDate.getMonth()+1).toString() +&quot;/&quot;+ jsFeeDate.getDate()+&quot;/&quot;+jsFeeDate.getFullYear());&#xD;
		if (jsFeeDate  &gt;= jsStartDate &amp;&amp; jsFeeDate &lt;= jsEndDate &amp;&amp; (!checkStatus || exists(feeObjArr[ff].getFeeitemStatus(),statusArray) ) )&#xD;
			{&#xD;
			feesTotal += feeObjArr[ff].getFee(); &#xD;
			//logDebug(&quot;Added to Total: &quot;+feeObjArr[ff].getFee());&#xD;
			}&#xD;
		}&#xD;
			&#xD;
	return feesTotal;&#xD;
	}&#xD;
&#xD;
 &#xD;
function feeQty(feestr)&#xD;
	{&#xD;
	var feeQty = 0;&#xD;
	var feeResult=aa.fee.getFeeItems(capId);&#xD;
	if (feeResult.getSuccess())&#xD;
		{ var feeObjArr = feeResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
	&#xD;
	for (ff in feeObjArr)&#xD;
		if (feestr.equals(feeObjArr[ff].getFeeCod()))&#xD;
			feeQty+=feeObjArr[ff].getFeeUnit();&#xD;
			&#xD;
	return feeQty;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByASI(ASIName,ASIValue,ats)&#xD;
	//&#xD;
	// returns the cap Id string of an application based on App-Specific Info and applicationtype.  Returns first result only!&#xD;
	//&#xD;
	{&#xD;
	var ata = ats.split(&quot;/&quot;);&#xD;
	if (ata.length != 4)&#xD;
		logDebug(&quot;**ERROR: getAppIdByASI in appMatch.  The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
&#xD;
	var getCapResult = aa.cap.getCapIDsByAppSpecificInfoField(ASIName,ASIValue);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		myAppTypeString = myCap.getCapType().toString();&#xD;
		myAppTypeArray = myAppTypeString.split(&quot;/&quot;);&#xD;
&#xD;
		isMatch = true;&#xD;
		for (xx in ata)&#xD;
			if (!ata[xx].equals(myAppTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
				isMatch = false;&#xD;
		&#xD;
		if (isMatch)&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + ASIName + &quot;,&quot; + ASIValue + &quot;,&quot; + ats + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppIdByName(gaGroup,gaType,gaName)&#xD;
//&#xD;
// returns the cap Id string of an application that has group,type,and name&#xD;
//&#xD;
	{&#xD;
	getCapResult = aa.cap.getByAppType(gaGroup,gaType);&#xD;
	if (getCapResult.getSuccess())&#xD;
		var apsArray = getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting caps by app type: &quot; + getCapResult.getErrorMessage()) ; return null }&#xD;
		&#xD;
&#xD;
	for (aps in apsArray)&#xD;
		{&#xD;
		var myCap = aa.cap.getCap(apsArray[aps].getCapID()).getOutput();&#xD;
		if (myCap.getSpecialText().equals(gaName))&#xD;
			{&#xD;
			logDebug(&quot;getAppIdByName(&quot; + gaGroup + &quot;,&quot; + gaType + &quot;,&quot; + gaName + &quot;) Returns &quot; + apsArray[aps].getCapID().toString()); &#xD;
			return apsArray[aps].getCapID().toString()&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function getApplication(appNum) &#xD;
//&#xD;
// returns the capId object of an application&#xD;
//&#xD;
	{&#xD;
	var getCapResult = aa.cap.getCapID(appNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		return getCapResult.getOutput();&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting cap id (&quot; + appNum + &quot;): &quot; + getCapResult.getErrorMessage()) }&#xD;
	}&#xD;
&#xD;
 &#xD;
function getAppSpecific(itemName)  // optional: itemCap&#xD;
{&#xD;
	var updated = false;&#xD;
	var i=0;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
   	&#xD;
	if (useAppSpecificGroupName)&#xD;
	{&#xD;
		if (itemName.indexOf(&quot;.&quot;) &lt; 0)&#xD;
			{ logDebug(&quot;**WARNING: editAppSpecific requires group name prefix when useAppSpecificGroupName is true&quot;) ; return false }&#xD;
		&#xD;
		&#xD;
		var itemGroup = itemName.substr(0,itemName.indexOf(&quot;.&quot;));&#xD;
		var itemName = itemName.substr(itemName.indexOf(&quot;.&quot;)+1);&#xD;
	}&#xD;
	&#xD;
    var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
 	{&#xD;
		var appspecObj = appSpecInfoResult.getOutput();&#xD;
		&#xD;
		if (itemName != &quot;&quot;)&#xD;
		{&#xD;
			for (i in appspecObj)&#xD;
				if( appspecObj[i].getCheckboxDesc() == itemName &amp;&amp; (!useAppSpecificGroupName || appspecObj[i].getCheckboxType() == itemGroup) )&#xD;
				{&#xD;
					return appspecObj[i].getChecklistComment();&#xD;
					break;&#xD;
				}&#xD;
		} // item name blank&#xD;
	} &#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting app specific info for Cap : &quot; + appSpecInfoResult.getErrorMessage()) }&#xD;
}&#xD;
&#xD;
 &#xD;
function getCapByAddress(ats) &#xD;
//&#xD;
// returns the capid that matches the current address and app type string&#xD;
// if multiple records will return the first and warning.&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (aoArray.length)&#xD;
		{ var ao = aoArray[0]; }&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: no address for comparison:&quot;); return false; }&#xD;
	&#xD;
	// get caps with same address&#xD;
	var capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),ao.getZip(),ao.getStreetDirection(),null);&#xD;
	if (capAddResult.getSuccess())&#xD;
	 	{ var capIdArray=capAddResult.getOutput(); }&#xD;
	else&#xD;
	 	{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
	&#xD;
	&#xD;
	// loop through related caps&#xD;
	for (cappy in capIdArray)&#xD;
		{&#xD;
		// get file date&#xD;
		var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
		&#xD;
		// get cap type&#xD;
		&#xD;
		reltype = relcap.getCapType().toString();&#xD;
		&#xD;
		var isMatch = true;&#xD;
		var ata = ats.split(&quot;/&quot;);&#xD;
		if (ata.length != 4)&#xD;
			logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
		else&#xD;
			for (xx in ata)&#xD;
				if (!ata[xx].equals(appTypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
					isMatch = false;&#xD;
&#xD;
		if (isMatch)			&#xD;
			retArr.push(capIdArray[cappy]);&#xD;
&#xD;
		} // loop through related caps&#xD;
		&#xD;
	if (retArr.length &gt; 1)&#xD;
		{&#xD;
		logDebug(&quot;**WARNING: Multiple caps returned for this address/apptype&quot;) ; return retArr[0] &#xD;
		}&#xD;
	&#xD;
	if (retArr.length == 0)&#xD;
		return retArr[0];&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getChildren(pCapType, pParentCapId) &#xD;
	{&#xD;
	// Returns an array of children capId objects whose cap type matches pCapType parameter&#xD;
	// Wildcard * may be used in pCapType, e.g. &quot;Building/Commercial/*/*&quot;&#xD;
	// Optional 3rd parameter pChildCapIdSkip: capId of child to skip&#xD;
&#xD;
	var retArray = new Array();&#xD;
	if (pParentCapId!=null) //use cap in parameter &#xD;
		var vCapId = pParentCapId;&#xD;
	else // use current cap&#xD;
		var vCapId = capId;&#xD;
		&#xD;
	if (arguments.length&gt;2)&#xD;
		var childCapIdSkip = arguments[2];&#xD;
	else&#xD;
		var childCapIdSkip = null;&#xD;
		&#xD;
	var typeArray = pCapType.split(&quot;/&quot;);&#xD;
	if (typeArray.length != 4)&#xD;
		logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
		&#xD;
	var getCapResult = aa.cap.getChildByMasterID(vCapId);&#xD;
	if (!getCapResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: getChildren returned an error: &quot; + getCapResult.getErrorMessage()); return null }&#xD;
		&#xD;
	var childArray = getCapResult.getOutput();&#xD;
	if (!childArray.length)&#xD;
		{ logDebug( &quot;**WARNING: getChildren function found no children&quot;); return null ; }&#xD;
&#xD;
	var childCapId;&#xD;
	var capTypeStr = &quot;&quot;;&#xD;
	var childTypeArray;&#xD;
	var isMatch;&#xD;
	for (xx in childArray)&#xD;
		{&#xD;
		childCapId = childArray[xx].getCapID();&#xD;
		if (childCapIdSkip!=null &amp;&amp; childCapIdSkip.getCustomID().equals(childCapId.getCustomID())) //skip over this child&#xD;
			continue;&#xD;
&#xD;
		capTypeStr = aa.cap.getCap(childCapId).getOutput().getCapType().toString();	// Convert cap type to string (&quot;Building/A/B/C&quot;)&#xD;
		childTypeArray = capTypeStr.split(&quot;/&quot;);&#xD;
		isMatch = true;&#xD;
		for (yy in childTypeArray) //looking for matching cap type&#xD;
			{&#xD;
			if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
				{&#xD;
				isMatch = false;&#xD;
				continue;&#xD;
				}&#xD;
			}&#xD;
		if (isMatch)&#xD;
			retArray.push(childCapId);&#xD;
		}&#xD;
		&#xD;
	logDebug(&quot;getChildren returned &quot; + retArray.length + &quot; capIds&quot;);&#xD;
	return retArray;&#xD;
&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getContactArray()&#xD;
	{&#xD;
	// Returns an array of associative arrays with contact attributes.  Attributes are UPPER CASE&#xD;
	// optional capid&#xD;
	var thisCap = capId;&#xD;
	if (arguments.length == 1) thisCap = arguments[0]; &#xD;
&#xD;
	var cArray = new Array();&#xD;
&#xD;
	var capContactResult = aa.people.getCapContactByCapID(thisCap);&#xD;
	if (capContactResult.getSuccess())&#xD;
		{&#xD;
		var capContactArray = capContactResult.getOutput();&#xD;
		for (yy in capContactArray)&#xD;
			{&#xD;
			var aArray = new Array();&#xD;
			aArray[&quot;lastName&quot;] = capContactArray[yy].getPeople().lastName;&#xD;
			aArray[&quot;firstName&quot;] = capContactArray[yy].getPeople().firstName;&#xD;
			aArray[&quot;businessName&quot;] = capContactArray[yy].getPeople().businessName;&#xD;
			aArray[&quot;contactSeqNumber&quot;] =capContactArray[yy].getPeople().contactSeqNumber;&#xD;
			aArray[&quot;contactType&quot;] =capContactArray[yy].getPeople().contactType;&#xD;
			aArray[&quot;relation&quot;] = capContactArray[yy].getPeople().relation;&#xD;
			aArray[&quot;phone1&quot;] = capContactArray[yy].getPeople().phone1;			&#xD;
			aArray[&quot;phone2&quot;] = capContactArray[yy].getPeople().phone2;			&#xD;
			aArray[&quot;email&quot;] = capContactArray[yy].getPeople().email;&#xD;
			aArray[&quot;addressLine1&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine1();&#xD;
			aArray[&quot;addressLine2&quot;] = capContactArray[yy].getPeople().getCompactAddress().getAddressLine2();&#xD;
			aArray[&quot;city&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCity();&#xD;
			aArray[&quot;state&quot;] = capContactArray[yy].getPeople().getCompactAddress().getState();&#xD;
			aArray[&quot;zip&quot;] = capContactArray[yy].getPeople().getCompactAddress().getZip();&#xD;
			aArray[&quot;fax&quot;] = capContactArray[yy].getPeople().fax;&#xD;
			aArray[&quot;notes&quot;] = capContactArray[yy].getPeople().notes;&#xD;
			aArray[&quot;country&quot;] = capContactArray[yy].getPeople().getCompactAddress().getCountry();&#xD;
			aArray[&quot;fullName&quot;] = capContactArray[yy].getPeople().fullName;&#xD;
&#xD;
&#xD;
			var pa = capContactArray[yy].getCapContactModel().getPeople().getAttributes().toArray();&#xD;
	                for (xx1 in pa)&#xD;
                   		aArray[pa[xx1].attributeName] = pa[xx1].attributeValue;&#xD;
			cArray.push(aArray);                &#xD;
			}&#xD;
		}&#xD;
	return cArray;&#xD;
	}	&#xD;
&#xD;
 &#xD;
function getCSLBInfo(doPop,doWarning)   // doPop = true populate the cap lic prof with this data  &#xD;
					// doWarning = true, message if license is expired.&#xD;
	{&#xD;
	// Requires getNode and getProp functions.&#xD;
	//&#xD;
	// Get the first lic prof from the app&#xD;
	//&#xD;
	var capLicenseResult = aa.licenseScript.getLicenseProf(capId);&#xD;
	if (capLicenseResult.getSuccess())&#xD;
		{ var capLicenseArr = capLicenseResult.getOutput();  }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: getting lic prof: &quot; + capLicenseResult.getErrorMessage()); return false; }&#xD;
		&#xD;
	if (capLicenseArr == null || !capLicenseArr.length)&#xD;
		{ logDebug(&quot;**WARNING: no licensed professionals on this CAP&quot;); return false; }&#xD;
&#xD;
	var licProfScriptModel = capLicenseArr[0];&#xD;
	var rlpId = licProfScriptModel.getLicenseNbr();&#xD;
&#xD;
	//&#xD;
	// Now make the call to the California State License Board&#xD;
	//&#xD;
	&#xD;
	var getout = aa.util.httpPost(&quot;http://www2.cslb.ca.gov/IVR/License+Detail.asp?LicNum=&quot; + rlpId,&quot;&quot;);&#xD;
	if (getout.getSuccess())&#xD;
	  var lpXML = getout.getOutput();&#xD;
	else&#xD;
	   { logDebug(&quot;**ERROR: communicating with CSLB: &quot; + getout.getErrorMessage()); return false; }&#xD;
	&#xD;
	// Check to see if error message in the XML:&#xD;
	&#xD;
	if (lpXML.indexOf(&quot;&lt;Error&gt;&quot;) &gt; 0 )&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: CSLB information returned an error: &quot; + getNode(getNode(lpXML,&quot;License&quot;),&quot;**ERROR&quot;))&#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var lpBiz = getNode(lpXML,&quot;BusinessInfo&quot;);&#xD;
	var lpStatus = getNode(lpXML,&quot;PrimaryStatus&quot;);&#xD;
	var lpClass = getNode(lpXML,&quot;Classifications&quot;);&#xD;
	var lpBonds = getNode(lpXML,&quot;ContractorBond&quot;); &#xD;
	var lpWC = getNode(lpXML,&quot;WorkersComp&quot;);&#xD;
&#xD;
	if (doWarning)&#xD;
		{&#xD;
		var expDate = new Date(getNode(lpBiz,&quot;ExpireDt&quot;));&#xD;
		if (expDate &lt; startDate)		&#xD;
			{&#xD;
			showMessage = true ;&#xD;
			comment(&quot;**WARNING: Professional License expired on &quot; + expDate.toString());&#xD;
			}&#xD;
		}&#xD;
&#xD;
	if (doPop)  &#xD;
		{ 	&#xD;
		licProfScriptModel.setAddress1(getNode(lpBiz,&quot;Addr1&quot;).replace(/\+/g,&quot; &quot;)); &#xD;
		licProfScriptModel.setAddress2(getNode(lpBiz,&quot;Addr2&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setBusinessName(getNode(lpBiz,&quot;Name&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setCity(getNode(lpBiz,&quot;City&quot;).replace(/\+/g,&quot; &quot;));&#xD;
		licProfScriptModel.setLicenseExpirDate(aa.date.parseDate(getNode(lpBiz,&quot;ExpireDt&quot;)))&#xD;
		licProfScriptModel.setLicesnseOrigIssueDate(aa.date.parseDate(getNode(lpBiz,&quot;IssueDt&quot;)))  &#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setPhone1(getNode(lpBiz,&quot;BusinessPhoneNum&quot;))&#xD;
		licProfScriptModel.setState(getNode(lpBiz,&quot;State&quot;).replace(/\+/g,&quot; &quot;))&#xD;
		licProfScriptModel.setZip(getNode(lpBiz,&quot;Zip&quot;))&#xD;
		aa.m_licenseProfessional.editLicensedProfessional(licProfScriptModel);&#xD;
		}&#xD;
	}&#xD;
		&#xD;
 &#xD;
function getDepartmentName(username)&#xD;
	{&#xD;
	var suo = aa.person.getUser(username).getOutput(); &#xD;
	var dpt = aa.people.getDepartmentList(null).getOutput();&#xD;
	for (var thisdpt in dpt)&#xD;
	  	{&#xD;
	  	var m = dpt[thisdpt]&#xD;
	  	var  n = m.getServiceProviderCode() + &quot;/&quot; + m.getAgencyCode() + &quot;/&quot; + m.getBureauCode() + &quot;/&quot; + m.getDivisionCode() + &quot;/&quot; + m.getSectionCode() + &quot;/&quot; + m.getGroupCode() + &quot;/&quot; + m.getOfficeCode() &#xD;
	  &#xD;
	  	if (n.equals(suo.deptOfUser)) &#xD;
	  	return(m.getDeptName())&#xD;
  		}&#xD;
  	}&#xD;
  &#xD;
   &#xD;
function getGISBufferInfo(svc,layer,numDistance)&#xD;
	{&#xD;
	// returns an array of associative arrays&#xD;
	// each additional parameter will return another value in the array&#xD;
	//x = getGISBufferInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;PARCEL_ID1&quot;,&quot;MAP&quot;,&quot;BOOK&quot;,&quot;PARCEL&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	//for (x1 in x)&#xD;
	//   {&#xD;
	//   aa.print(&quot;Object &quot; + x1)&#xD;
	//   for (x2 in x[x1])&#xD;
	//      aa.print(&quot;  &quot; + x2 + &quot; = &quot; + x[x1][x2])&#xD;
	//   }&#xD;
&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		for (argnum = 3; argnum &lt; arguments.length ; argnum++)&#xD;
			buf.addAttributeName(arguments[argnum]);&#xD;
		}&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ aa.print(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ aa.print(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var n = proxObj[z1].getAttributeNames();&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				&#xD;
				var valArray = new Array();&#xD;
				&#xD;
				//&#xD;
				// 09/18/08 JHS Explicitly adding the key field of the object, since getBufferByRadius will not pull down the key field&#xD;
				// hardcoded this to GIS_ID&#xD;
				//&#xD;
				&#xD;
				valArray[&quot;GIS_ID&quot;] = proxObj[z1].getGisId()&#xD;
				for (n1 in n)&#xD;
					{&#xD;
					valArray[n[n1]] = v[n1];&#xD;
					}&#xD;
				retArray.push(valArray);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfo(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retString;&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retString&#xD;
	}&#xD;
&#xD;
 &#xD;
function getGISInfoArray(svc,layer,attributename)&#xD;
	{&#xD;
	// use buffer info to get info on the current object by using distance 0&#xD;
	// usage: &#xD;
	//&#xD;
	// x = getGISInfo(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;LOT_AREA&quot;);&#xD;
	//&#xD;
	&#xD;
	var distanceType = &quot;feet&quot;;&#xD;
	var retArray = new Array();&#xD;
   	&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributename);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap.  We'll only send the last value&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], &quot;0&quot;, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues();&#xD;
				retArray.push(v[0]);&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	return retArray;&#xD;
	}&#xD;
&#xD;
 &#xD;
// function getInspector: returns the inspector ID (string) of the scheduled inspection.  Returns the first result&#xD;
//&#xD;
function getInspector(insp2Check)&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getLastInspector(insp2Check)&#xD;
	// function getLastInspector: returns the inspector ID (string) of the last inspector to result the inspection.&#xD;
	//&#xD;
	{&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		inspList = inspResultObj.getOutput();&#xD;
		&#xD;
		inspList.sort(compareInspDateDesc)&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; !inspList[xx].getInspectionStatus().equals(&quot;Scheduled&quot;))&#xD;
				{&#xD;
				// have to re-grab the user since the id won't show up in this object.&#xD;
				inspUserObj = aa.person.getUser(inspList[xx].getInspector().getFirstName(),inspList[xx].getInspector().getMiddleName(),inspList[xx].getInspector().getLastName()).getOutput();&#xD;
				return inspUserObj.getUserID();&#xD;
				}&#xD;
		}&#xD;
	return null;&#xD;
	}&#xD;
&#xD;
function compareInspDateDesc(a,b) { return (a.getScheduledDate().getEpochMilliseconds() &lt; b.getScheduledDate().getEpochMilliseconds()); }&#xD;
 &#xD;
function getNode(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 endPos = fString.indexOf(endTag);&#xD;
	 // make sure startPos and endPos are valid before using them&#xD;
	 if (startPos &gt; 0 &amp;&amp; startPos &lt; endPos)&#xD;
		  fValue = fString.substring(startPos,endPos);&#xD;
&#xD;
	 return unescape(fValue);&#xD;
	}&#xD;
	&#xD;
 &#xD;
function getParent() &#xD;
	{&#xD;
	// returns the capId object of the parent.  Assumes only one parent!&#xD;
	//&#xD;
	getCapResult = aa.cap.getProjectParents(capId,1);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
			return parentArray[0].getCapID();&#xD;
		else&#xD;
			{&#xD;
			logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
			return false;&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getParents(pAppType) &#xD;
	{&#xD;
		// returns the capId array of all parent caps&#xD;
	    //Dependency: appMatch function&#xD;
		//&#xD;
        &#xD;
		var i = 1;&#xD;
        while (true)&#xD;
        {&#xD;
			if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
				break;&#xD;
         &#xD;
			i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
		getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
&#xD;
		if (getCapResult.getSuccess())&#xD;
		{&#xD;
			parentArray = getCapResult.getOutput();&#xD;
			&#xD;
			if (parentArray.length)&#xD;
			{&#xD;
				for(x in parentArray)&#xD;
				{&#xD;
					if (pAppType != null)&#xD;
					{&#xD;
						//If parent type matches apType pattern passed in, add to return array&#xD;
						if ( appMatch( pAppType, parentArray[x].getCapID() ) )&#xD;
							myArray.push(parentArray[x].getCapID());&#xD;
					}&#xD;
					else&#xD;
						myArray.push(parentArray[x].getCapID());&#xD;
				}		&#xD;
				&#xD;
				return myArray;&#xD;
			}&#xD;
			else&#xD;
			{&#xD;
				logDebug( &quot;**WARNING: GetParent found no project parent for this application&quot;);&#xD;
				return null;&#xD;
			}&#xD;
		}&#xD;
		else&#xD;
		{ &#xD;
			logDebug( &quot;**WARNING: getting project parents:  &quot; + getCapResult.getErrorMessage());&#xD;
			return null;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getProp(fString,fName)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	 var startTag = fName + &quot;='&quot;;&#xD;
	 var endTag = &quot;'&quot;;&#xD;
	 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
	 if (startPos &gt; 0)&#xD;
	   fValue = fString.substring(startPos);&#xD;
&#xD;
	 endPos = fValue.indexOf(endTag);&#xD;
	 if (endPos &gt; 0)&#xD;
	  fValue = fValue.substring(0,endPos);&#xD;
&#xD;
	return unescape(fValue);&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRefLicenseProf(refstlic)&#xD;
	{&#xD;
	var refLicObj = null;&#xD;
	var refLicenseResult = aa.licenseScript.getRefLicensesProfByLicNbr(aa.getServiceProviderCode(),refstlic);&#xD;
	if (!refLicenseResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR retrieving Ref Lic Profs : &quot; + refLicenseResult.getErrorMessage()); return false; }&#xD;
	else&#xD;
		{&#xD;
		var newLicArray = refLicenseResult.getOutput();&#xD;
		if (!newLicArray) return null;&#xD;
		for (var thisLic in newLicArray)&#xD;
			if (refstlic &amp;&amp; refstlic.toUpperCase().equals(newLicArray[thisLic].getStateLicense().toUpperCase()))&#xD;
				refLicObj = newLicArray[thisLic];&#xD;
		}&#xD;
&#xD;
	return refLicObj;&#xD;
	} &#xD;
&#xD;
function getRelatedCapsByAddress(ats) &#xD;
//&#xD;
// returns and array of capids that share the same address as the current cap&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	// get address data&#xD;
	var addResult = aa.address.getAddressByCapId(capId);&#xD;
	if (addResult.getSuccess())&#xD;
		{ var aoArray = addResult.getOutput(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting address by cap ID: &quot; + addResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (zzz in aoArray)&#xD;
		{&#xD;
		var ao = aoArray[zzz];&#xD;
		// get caps with same address&#xD;
		capAddResult = aa.cap.getCapListByDetailAddress(ao.getStreetName(),ao.getHouseNumberStart(),ao.getStreetSuffix(),null,ao.getStreetDirection(),null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar addresses: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
&#xD;
			// get cap id&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
&#xD;
&#xD;
			// get cap type&#xD;
&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		&#xD;
		}&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function getRelatedCapsByParcel(ats) &#xD;
//&#xD;
// returns and array of capids that match parcels on the current app.  Includes all parcels.&#xD;
// ats, app type string to check for&#xD;
//&#xD;
	{&#xD;
	var retArr = new Array();&#xD;
	&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (capParcelResult.getSuccess())&#xD;
		{ var Parcels = capParcelResult.getOutput().toArray(); }&#xD;
	else	&#xD;
		{ logDebug(&quot;**ERROR: getting parcels by cap ID: &quot; + capParcelResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		var ParcelValidatedNumber = Parcels[zz].getParcelNumber();&#xD;
&#xD;
		// get caps with same parcel&#xD;
		var capAddResult = aa.cap.getCapListByParcelID(ParcelValidatedNumber,null);&#xD;
		if (capAddResult.getSuccess())&#xD;
			{ var capIdArray=capAddResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: getting similar parcels: &quot; + capAddResult.getErrorMessage());  return false; }&#xD;
&#xD;
		// loop through related caps&#xD;
		for (cappy in capIdArray)&#xD;
			{&#xD;
			// skip if current cap&#xD;
			if (capId.getCustomID().equals(capIdArray[cappy].getCustomID()))&#xD;
				continue;&#xD;
			&#xD;
			// get cap ids			&#xD;
			var relcap = aa.cap.getCap(capIdArray[cappy].getCapID()).getOutput();&#xD;
			// get cap type&#xD;
			var reltypeArray = relcap.getCapType().toString().split(&quot;/&quot;);&#xD;
&#xD;
			var isMatch = true;&#xD;
			var ata = ats.split(&quot;/&quot;);&#xD;
			if (ata.length != 4)&#xD;
				logDebug(&quot;**ERROR: The following Application Type String is incorrectly formatted: &quot; + ats);&#xD;
			else&#xD;
				for (xx in ata)&#xD;
					if (!ata[xx].equals(reltypeArray[xx]) &amp;&amp; !ata[xx].equals(&quot;*&quot;))&#xD;
						isMatch = false;&#xD;
&#xD;
			if (isMatch)			&#xD;
				retArr.push(capIdArray[cappy]);&#xD;
&#xD;
			} // loop through related caps&#xD;
		}&#xD;
		&#xD;
	if (retArr.length &gt; 0)&#xD;
		return retArr;&#xD;
		&#xD;
	}&#xD;
&#xD;
 &#xD;
function getReportedChannel() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getReportedChannel();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getScheduledInspId(insp2Check)&#xD;
	{&#xD;
	// warning, returns only the first scheduled occurrence&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(insp2Check).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				return inspList[xx].getIdNumber();&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function getShortNotes() // option CapId&#xD;
{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0) &#xD;
		itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	var sReturn = cd.getShortNotes();&#xD;
	&#xD;
	if(sReturn != null)&#xD;
		return sReturn;&#xD;
	else&#xD;
		return &quot;&quot;;&#xD;
} &#xD;
function getTaskDueDate(wfstr) // optional process name.&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
  		if ((fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase()) || wfstr == &quot;*&quot;)  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dueDate = wfObj[i].getDueDate();&#xD;
			if (dueDate)&#xD;
				return new Date(dueDate.getMonth() + &quot;/&quot; + dueDate.getDayOfMonth() + &quot;/&quot; + dueDate.getYear());&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function getTaskStatusForEmail(stask)&#xD;
	{&#xD;
	// returns a string of task statuses for a workflow group&#xD;
	var returnStr = &quot;&quot;&#xD;
	var taskResult = aa.workflow.getTasks(capId);&#xD;
	if (taskResult.getSuccess())&#xD;
		{ var taskArr = taskResult.getOutput(); }&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
		&#xD;
	for (xx in taskArr)&#xD;
		if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getCompleteFlag().equals(&quot;Y&quot;))&#xD;
			{&#xD;
			returnStr+=&quot;Task Name: &quot; + taskArr[xx].getTaskDescription() + &quot;\n&quot;;&#xD;
			returnStr+=&quot;Task Status: &quot; + taskArr[xx].getDisposition() + &quot;\n&quot;;&#xD;
			if (taskArr[xx].getDispositionComment() != null) &#xD;
				returnStr+=&quot;Task Comments: &quot; + taskArr[xx].getDispositionComment() + &quot;\n&quot; ;&#xD;
			returnStr+=&quot;\n&quot;;&#xD;
			}&#xD;
	logDebug(returnStr);&#xD;
	return returnStr;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function xmlEscapeXMLToHTML(xmlData) {&#xD;
    /*************************************************************************************&#xD;
    Function:       xmlEscapeXMLToHTML&#xD;
&#xD;
    author:         xwisdom@yahoo.com&#xD;
&#xD;
    description:&#xD;
        Encodes XML data for use in a web page&#xD;
&#xD;
    ************************************************************************************/&#xD;
    var gt;&#xD;
&#xD;
    var str = xmlData;&#xD;
&#xD;
    //replace &amp; with &amp;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&amp;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&amp;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&amp;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &lt; with &lt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&lt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&lt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace &gt; with &gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;&gt;&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;&gt;&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    //replace \n with &lt;br&gt;&#xD;
    gt = -1;&#xD;
    while (str.indexOf(&quot;\n&quot;, gt + 1) &gt; -1) {&#xD;
        var gt = str.indexOf(&quot;\n&quot;, gt + 1);&#xD;
        var newStr = str.substr(0, gt);&#xD;
        newStr += &quot;&lt;br&gt;&quot;;&#xD;
        newStr = newStr + str.substr(gt + 1, str.length);&#xD;
        str = newStr;&#xD;
    }&#xD;
&#xD;
    return str&#xD;
&#xD;
}  // end function xmlEscapeXMLToHTML&#xD;
&#xD;
 &#xD;
function inspCancelAll()&#xD;
	{&#xD;
	var isCancelled = false;&#xD;
	var inspResults = aa.inspection.getInspections(capId);&#xD;
	if (inspResults.getSuccess())&#xD;
		{&#xD;
		var inspAll = inspResults.getOutput();&#xD;
		var inspectionId;&#xD;
		var cancelResult;&#xD;
		for (ii in inspAll)&#xD;
			{&#xD;
			if (inspAll[ii].getDocumentDescription().equals(&quot;Insp Scheduled&quot;) &amp;&amp; inspAll[ii].getAuditStatus().equals(&quot;A&quot;))&#xD;
				{&#xD;
				inspectionId = inspAll[ii].getIdNumber();		// Inspection identifier	&#xD;
				cancelResult = aa.inspection.cancelInspection(capId,inspectionId);&#xD;
				if (cancelResult.getSuccess())&#xD;
					{&#xD;
					logMessage(&quot;Cancelling inspection: &quot; + inspAll[ii].getInspectionType());&#xD;
					isCancelled = true;&#xD;
					}&#xD;
				else&#xD;
					logMessage(&quot;**ERROR&quot;,&quot;**ERROR: Cannot cancel inspection: &quot;+inspAll[ii].getInspectionType()+&quot;, &quot;+cancelResult.getErrorMessage());&#xD;
				}&#xD;
		  }&#xD;
		}&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: getting inspections: &quot; + inspResults.getErrorMessage());&#xD;
	&#xD;
	return isCancelled;&#xD;
	}&#xD;
&#xD;
 &#xD;
function invoiceFee(fcode,fperiod)&#xD;
    {&#xD;
    //invoices all assessed fees having fcode and fperiod&#xD;
    // SR5085 LL&#xD;
    var feeFound=false;&#xD;
    getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
    if (getFeeResult.getSuccess())&#xD;
        {&#xD;
        var feeList = getFeeResult.getOutput();&#xD;
        for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;))  &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				feeSeqList.push(feeSeq);&#xD;
				paymentPeriodList.push(fperiod);&#xD;
                feeFound=true;&#xD;
                logDebug(&quot;Assessed fee &quot;+fcode+&quot; found and tagged for invoicing&quot;);&#xD;
                }&#xD;
        }&#xD;
    else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
    return feeFound;&#xD;
    } &#xD;
function isScheduled(inspType)&#xD;
	{&#xD;
	var found = false;&#xD;
	var inspResultObj = aa.inspection.getInspections(capId);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()))&#xD;
				found = true;&#xD;
		}&#xD;
	return found;&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskActive(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getActiveFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function isTaskComplete(wfstr) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 2) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getCompleteFlag().equals(&quot;Y&quot;))&#xD;
				return true;&#xD;
			else&#xD;
				return false;&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
function isTaskStatus(wfstr,wfstat) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 2) &#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			if (fTask.getDisposition()!=null)&#xD;
				{&#xD;
				if (fTask.getDisposition().toUpperCase().equals(wfstat.toUpperCase()))&#xD;
					return true;&#xD;
				else&#xD;
					return false;&#xD;
				}&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function jsDateToASIDate(dateValue)&#xD;
{&#xD;
  //Converts Javascript Date to ASI 0 pad MM/DD/YYYY&#xD;
  //&#xD;
  if (dateValue != null)&#xD;
  {&#xD;
	if (Date.prototype.isPrototypeOf(dateValue))&#xD;
	{&#xD;
	    var M = &quot;&quot; + (dateValue.getMonth()+1); &#xD;
	    var MM = &quot;0&quot; + M; &#xD;
	    MM = MM.substring(MM.length-2, MM.length); &#xD;
	    var D = &quot;&quot; + (dateValue.getDate()); &#xD;
	    var DD = &quot;0&quot; + D; &#xD;
	    DD = DD.substring(DD.length-2, DD.length); &#xD;
	    var YYYY = &quot;&quot; + (dateValue.getFullYear()); &#xD;
	    return MM + &quot;/&quot; + DD + &quot;/&quot; + YYYY;&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
		return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
	}&#xD;
  }&#xD;
  else&#xD;
  {&#xD;
	logDebug(&quot;Parameter is null&quot;);&#xD;
	return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
  }&#xD;
}&#xD;
&#xD;
 &#xD;
function jsDateToMMDDYYYY(pJavaScriptDate)&#xD;
	{&#xD;
	//converts javascript date to string in MM/DD/YYYY format&#xD;
	//&#xD;
	if (pJavaScriptDate != null)&#xD;
		{&#xD;
		if (Date.prototype.isPrototypeOf(pJavaScriptDate))&#xD;
	return (pJavaScriptDate.getMonth()+1).toString()+&quot;/&quot;+pJavaScriptDate.getDate()+&quot;/&quot;+pJavaScriptDate.getFullYear();&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Parameter is not a javascript date&quot;);&#xD;
			return (&quot;INVALID JAVASCRIPT DATE&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Parameter is null&quot;);&#xD;
		return (&quot;NULL PARAMETER VALUE&quot;);&#xD;
		}&#xD;
	} &#xD;
function licEditExpInfo (pExpStatus, pExpDate)&#xD;
	{&#xD;
	//Edits expiration status and/or date&#xD;
	//Needs licenseObject function&#xD;
	//06SSP-00238&#xD;
	//&#xD;
	var lic = new licenseObject(null);&#xD;
	if (pExpStatus!=null)&#xD;
		{&#xD;
		lic.setStatus(pExpStatus);&#xD;
		}&#xD;
		&#xD;
	if (pExpDate!=null)&#xD;
		{&#xD;
		lic.setExpiration(pExpDate);&#xD;
		}&#xD;
	}&#xD;
	&#xD;
 &#xD;
&#xD;
function licenseObject(licnumber)&#xD;
	{&#xD;
	// available statuses (from various R1_SERVER_CONSTANT values&#xD;
	var licenseStatus = new Array(&quot;&quot;,&quot;Active&quot;,&quot;About To Expire&quot;,&quot;Delinquent&quot;,&quot;Expired&quot;,&quot;Invalid&quot;,&quot;Pending&quot;);&#xD;
&#xD;
	this.refProf = null;		// licenseScriptModel (reference licensed professional)&#xD;
	this.b1Exp = null;		// b1Expiration record (renewal status on application)&#xD;
	this.b1ExpDate = null;&#xD;
	this.b1ExpCode = null;&#xD;
	this.b1Status = null;&#xD;
	this.refExpDate = null;&#xD;
	this.licNum = licnumber;	// License Number&#xD;
&#xD;
&#xD;
	// Load the reference License Professional if we're linking the two&#xD;
	if (licnumber) // we're linking&#xD;
		{&#xD;
		var newLic = getRefLicenseProf(licnumber)&#xD;
&#xD;
		if (newLic)&#xD;
				{&#xD;
				this.refProf = newLic;&#xD;
				tmpDate = newLic.getLicenseExpirationDate();&#xD;
				if (tmpDate)&#xD;
						this.refExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
				logDebug(&quot;Loaded reference license professional with Expiration of &quot; + this.refExpDate);&#xD;
				}&#xD;
		}&#xD;
&#xD;
   	// Load the renewal info (B1 Expiration)&#xD;
   	// The only way to pull up a renewal is to supply a status.  I don't understand since it has a 1 to 1 relationship with b1permit, but oh well.&#xD;
   	// the silly thing returns a blank record, so have to check the B1expirationModel to see if it's valid&#xD;
&#xD;
   	for (myStatus in licenseStatus)&#xD;
   		{&#xD;
   		b1ExpResult = aa.expiration.getLicensesByCapID(capId,licenseStatus[myStatus]);&#xD;
   		if (b1ExpResult.getSuccess())&#xD;
   			{&#xD;
   			this.b1Exp = b1ExpResult.getOutput();&#xD;
   			exptest = this.b1Exp.getB1Expiration();&#xD;
    			if (exptest)&#xD;
    				{&#xD;
    				tmpDate = this.b1Exp.getExpDate();&#xD;
    				if (tmpDate)&#xD;
    					this.b1ExpDate = tmpDate.getMonth() + &quot;/&quot; + tmpDate.getDayOfMonth() + &quot;/&quot; + tmpDate.getYear();&#xD;
    				this.b1Status = this.b1Exp.getExpStatus();&#xD;
    				logDebug(&quot;Found renewal record of status : &quot; + this.b1Status + &quot;, Expires on &quot; + this.b1ExpDate);&#xD;
    				break&#xD;
    				}&#xD;
			}&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Getting B1Expiration Object for Cap.  Reason is: &quot; + b1ExpResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
		}&#xD;
&#xD;
&#xD;
   	this.setExpiration = function(expDate)&#xD;
   		// Update expiration date&#xD;
   		{&#xD;
   		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
   		if (this.refProf) {&#xD;
   			this.refProf.setLicenseExpirationDate(expAADate);&#xD;
   			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
   			logDebug(&quot;Updated reference license expiration to &quot; + expDate); }&#xD;
&#xD;
   		if (this.b1Exp)  {&#xD;
 				this.b1Exp.setExpDate(expAADate);&#xD;
				aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
				logDebug(&quot;Updated renewal to &quot; + expDate); }&#xD;
   		}&#xD;
&#xD;
	this.setIssued = function(expDate)&#xD;
		// Update Issued date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate);&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseIssueDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
&#xD;
		}&#xD;
	this.setLastRenewal = function(expDate)&#xD;
		// Update expiration date&#xD;
		{&#xD;
		var expAADate = aa.date.parseDate(expDate)&#xD;
&#xD;
		if (this.refProf) {&#xD;
			this.refProf.setLicenseLastRenewalDate(expAADate);&#xD;
			aa.licenseScript.editRefLicenseProf(this.refProf);&#xD;
			logDebug(&quot;Updated reference license issued to &quot; + expDate); }&#xD;
		}&#xD;
&#xD;
	this.setStatus = function(licStat)&#xD;
		// Update expiration status&#xD;
		{&#xD;
		if (this.b1Exp)  {&#xD;
			this.b1Exp.setExpStatus(licStat);&#xD;
			aa.expiration.editB1Expiration(this.b1Exp.getB1Expiration());&#xD;
			logDebug(&quot;Updated renewal to status &quot; + licStat); }&#xD;
		}&#xD;
&#xD;
	this.getStatus = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpStatus();&#xD;
			}&#xD;
		}&#xD;
&#xD;
	this.getCode = function()&#xD;
		// Get Expiration Status&#xD;
		{&#xD;
		if (this.b1Exp) {&#xD;
			return this.b1Exp.getExpCode();&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadAppSpecific(thisArr) {&#xD;
	// &#xD;
	// Returns an associative array of App Specific Info&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
    	var appSpecInfoResult = aa.appSpecificInfo.getByCapID(itemCap);&#xD;
	if (appSpecInfoResult.getSuccess())&#xD;
	 	{&#xD;
		var fAppSpecInfoObj = appSpecInfoResult.getOutput();&#xD;
&#xD;
		for (loopk in fAppSpecInfoObj)&#xD;
			{&#xD;
			if (useAppSpecificGroupName)&#xD;
				thisArr[fAppSpecInfoObj[loopk].getCheckboxType() + &quot;.&quot; + fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			else&#xD;
				thisArr[fAppSpecInfoObj[loopk].checkboxDesc] = fAppSpecInfoObj[loopk].checklistComment;&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadASITable(tname) {&#xD;
&#xD;
 	//&#xD;
 	// Returns a single ASI Table array of arrays&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
      if (!tn.equals(tname)) continue;&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty())&#xD;
	  	{&#xD;
			logDebug(&quot;Couldn't load ASI Table &quot; + tname + &quot; it is empty&quot;);&#xD;
			return false;&#xD;
		}&#xD;
&#xD;
   	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  }&#xD;
	  return tempArray;&#xD;
	} &#xD;
function loadASITables() {&#xD;
&#xD;
 	//&#xD;
 	// Loads App Specific tables into their own array of arrays.  Creates global array objects&#xD;
	//&#xD;
	// Optional parameter, cap ID to load from&#xD;
	//&#xD;
&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
	var gm = aa.appSpecificTableScript.getAppSpecificTableGroupModel(itemCap).getOutput();&#xD;
	var ta = gm.getTablesArray()&#xD;
	var tai = ta.iterator();&#xD;
&#xD;
	while (tai.hasNext())&#xD;
	  {&#xD;
	  var tsm = tai.next();&#xD;
&#xD;
	  if (tsm.rowIndex.isEmpty()) continue;  // empty table&#xD;
&#xD;
	  var tempObject = new Array();&#xD;
	  var tempArray = new Array();&#xD;
	  var tn = tsm.getTableName();&#xD;
&#xD;
	  tn = String(tn).replace(/[^a-zA-Z0-9]+/g,'');&#xD;
&#xD;
	  if (!isNaN(tn.substring(0,1))) tn = &quot;TBL&quot; + tn  // prepend with TBL if it starts with a number&#xD;
&#xD;
  	  var tsmfldi = tsm.getTableField().iterator();&#xD;
	  var tsmcoli = tsm.getColumns().iterator();&#xD;
	  var numrows = 1;&#xD;
&#xD;
	  while (tsmfldi.hasNext())  // cycle through fields&#xD;
		{&#xD;
		if (!tsmcoli.hasNext())  // cycle through columns&#xD;
			{&#xD;
&#xD;
			var tsmcoli = tsm.getColumns().iterator();&#xD;
			tempArray.push(tempObject);  // end of record&#xD;
			var tempObject = new Array();  // clear the temp obj&#xD;
			numrows++;&#xD;
			}&#xD;
		var tcol = tsmcoli.next();&#xD;
		var tval = tsmfldi.next();&#xD;
		tempObject[tcol.getColumnName()] = tval;&#xD;
		}&#xD;
	  tempArray.push(tempObject);  // end of record&#xD;
	  var copyStr = &quot;&quot; + tn + &quot; = tempArray&quot;;&#xD;
	  aa.print(&quot;ASI Table Array : &quot; + tn + &quot; (&quot; + numrows + &quot; Rows)&quot;);&#xD;
	  eval(copyStr);  // move to table name&#xD;
	  }&#xD;
&#xD;
	}&#xD;
 &#xD;
&#xD;
function loadFees()  // option CapId&#xD;
	{&#xD;
	//  load the fees into an array of objects.  Does not&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 0)&#xD;
		{&#xD;
		ltcapidstr = arguments[0]; // use cap ID specified in args&#xD;
		if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
				var ltresult = aa.cap.getCapID(ltcapidstr);&#xD;
	 			if (ltresult.getSuccess())&#xD;
  				 	itemCap = ltresult.getOutput();&#xD;
	  			else&#xD;
  				  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
		else&#xD;
			itemCap = ltcapidstr;&#xD;
		}&#xD;
&#xD;
  	var feeArr = new Array();&#xD;
&#xD;
	var feeResult=aa.fee.getFeeItems(itemCap);&#xD;
		if (feeResult.getSuccess())&#xD;
			{ var feeObjArr = feeResult.getOutput(); }&#xD;
		else&#xD;
			{ logDebug( &quot;**ERROR: getting fee items: &quot; + capContResult.getErrorMessage()); return false }&#xD;
&#xD;
		for (ff in feeObjArr)&#xD;
			{&#xD;
			fFee = feeObjArr[ff];&#xD;
			var myFee = new Fee();&#xD;
			var amtPaid = 0;&#xD;
&#xD;
			var pfResult = aa.finance.getPaymentFeeItems(itemCap, null);&#xD;
			if (pfResult.getSuccess())&#xD;
				{&#xD;
				var pfObj = pfResult.getOutput();&#xD;
				for (ij in pfObj)&#xD;
					if (fFee.getFeeSeqNbr() == pfObj[ij].getFeeSeqNbr())&#xD;
						amtPaid+=pfObj[ij].getFeeAllocation()&#xD;
				}&#xD;
&#xD;
			myFee.sequence = fFee.getFeeSeqNbr();&#xD;
			myFee.code =  fFee.getFeeCod();&#xD;
			myFee.description = fFee.getFeeDescription();&#xD;
			myFee.unit = fFee.getFeeUnit();&#xD;
			myFee.amount = fFee.getFee();&#xD;
			myFee.amountPaid = amtPaid;&#xD;
			if (fFee.getApplyDate()) myFee.applyDate = convertDate(fFee.getApplyDate());&#xD;
			if (fFee.getEffectDate()) myFee.effectDate = convertDate(fFee.getEffectDate());&#xD;
			if (fFee.getExpireDate()) myFee.expireDate = convertDate(fFee.getExpireDate());&#xD;
			myFee.status = fFee.getFeeitemStatus();&#xD;
			myFee.period = fFee.getPaymentPeriod();&#xD;
			myFee.display = fFee.getDisplay();&#xD;
			myFee.accCodeL1 = fFee.getAccCodeL1();&#xD;
			myFee.accCodeL2 = fFee.getAccCodeL2();&#xD;
			myFee.accCodeL3 = fFee.getAccCodeL3();&#xD;
			myFee.formula = fFee.getFormula();&#xD;
			myFee.udes = fFee.getUdes();&#xD;
			myFee.UDF1 = fFee.getUdf1();&#xD;
			myFee.UDF2 = fFee.getUdf2();&#xD;
			myFee.UDF3 = fFee.getUdf3();&#xD;
			myFee.UDF4 = fFee.getUdf4();&#xD;
			myFee.subGroup = fFee.getSubGroup();&#xD;
			myFee.calcFlag = fFee.getCalcFlag();;&#xD;
			myFee.calcProc = fFee.getFeeCalcProc();&#xD;
&#xD;
			feeArr.push(myFee)&#xD;
			}&#xD;
&#xD;
		return feeArr;&#xD;
		}&#xD;
&#xD;
&#xD;
//////////////////&#xD;
&#xD;
function Fee() // Fee Object&#xD;
	{&#xD;
	this.sequence = null;&#xD;
	this.code =  null;&#xD;
	this.description = null;  // getFeeDescription()&#xD;
	this.unit = null; //  getFeeUnit()&#xD;
	this.amount = null; //  getFee()&#xD;
	this.amountPaid = null;&#xD;
	this.applyDate = null; // getApplyDate()&#xD;
	this.effectDate = null; // getEffectDate();&#xD;
	this.expireDate = null; // getExpireDate();&#xD;
	this.status = null; // getFeeitemStatus()&#xD;
	this.recDate = null;&#xD;
	this.period = null; // getPaymentPeriod()&#xD;
	this.display = null; // getDisplay()&#xD;
	this.accCodeL1 = null; // getAccCodeL1()&#xD;
	this.accCodeL2 = null; // getAccCodeL2()&#xD;
	this.accCodeL3 = null; // getAccCodeL3()&#xD;
	this.formula = null; // getFormula()&#xD;
	this.udes = null; // String getUdes()&#xD;
	this.UDF1 = null; // getUdf1()&#xD;
	this.UDF2 = null; // getUdf2()&#xD;
	this.UDF3 = null; // getUdf3()&#xD;
	this.UDF4 = null; // getUdf4()&#xD;
	this.subGroup = null; // getSubGroup()&#xD;
	this.calcFlag = null; // getCalcFlag();&#xD;
	this.calcProc = null; // getFeeCalcProc()&#xD;
	this.auditDate = null; // getAuditDate()&#xD;
	this.auditID = null; // getAuditID()&#xD;
	this.auditStatus = null; // getAuditStatus()&#xD;
	}&#xD;
&#xD;
 &#xD;
function loadParcelAttributes(thisArr) {&#xD;
	//&#xD;
	// Returns an associative array of Parcel Attributes&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var fcapParcelObj = null;&#xD;
   	var capParcelResult = aa.parcel.getParcelandAttribute(itemCap, null);&#xD;
   	if (capParcelResult.getSuccess())&#xD;
   		var fcapParcelObj = capParcelResult.getOutput().toArray();&#xD;
   	else&#xD;
     		logDebug(&quot;**ERROR: Failed to get Parcel object: &quot; + capParcelResult.getErrorType() + &quot;:&quot; + capParcelResult.getErrorMessage())&#xD;
  	&#xD;
  	for (i in fcapParcelObj)&#xD;
  		{&#xD;
  		parcelArea += fcapParcelObj[i].getParcelArea()&#xD;
  		parcelAttrObj = fcapParcelObj[i].getParcelAttribute().toArray();&#xD;
  		for (z in parcelAttrObj)&#xD;
			thisArr[&quot;ParcelAttribute.&quot; + parcelAttrObj[z].getB1AttributeName()]=parcelAttrObj[z].getB1AttributeValue();&#xD;
&#xD;
		// Explicitly load some standard values&#xD;
		thisArr[&quot;ParcelAttribute.Block&quot;] = fcapParcelObj[i].getBlock();&#xD;
		thisArr[&quot;ParcelAttribute.Book&quot;] = fcapParcelObj[i].getBook();&#xD;
		thisArr[&quot;ParcelAttribute.CensusTract&quot;] = fcapParcelObj[i].getCensusTract();&#xD;
		thisArr[&quot;ParcelAttribute.CouncilDistrict&quot;] = fcapParcelObj[i].getCouncilDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.ExemptValue&quot;] = fcapParcelObj[i].getExemptValue();&#xD;
		thisArr[&quot;ParcelAttribute.ImprovedValue&quot;] = fcapParcelObj[i].getImprovedValue();&#xD;
		thisArr[&quot;ParcelAttribute.InspectionDistrict&quot;] = fcapParcelObj[i].getInspectionDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.LandValue&quot;] = fcapParcelObj[i].getLandValue();&#xD;
		thisArr[&quot;ParcelAttribute.LegalDesc&quot;] = fcapParcelObj[i].getLegalDesc();&#xD;
		thisArr[&quot;ParcelAttribute.Lot&quot;] = fcapParcelObj[i].getLot();&#xD;
		thisArr[&quot;ParcelAttribute.MapNo&quot;] = fcapParcelObj[i].getMapNo();&#xD;
		thisArr[&quot;ParcelAttribute.MapRef&quot;] = fcapParcelObj[i].getMapRef();&#xD;
		thisArr[&quot;ParcelAttribute.ParcelStatus&quot;] = fcapParcelObj[i].getParcelStatus();&#xD;
		thisArr[&quot;ParcelAttribute.SupervisorDistrict&quot;] = fcapParcelObj[i].getSupervisorDistrict();&#xD;
		thisArr[&quot;ParcelAttribute.Tract&quot;] = fcapParcelObj[i].getTract();&#xD;
		thisArr[&quot;ParcelAttribute.PlanArea&quot;] = fcapParcelObj[i].getPlanArea();&#xD;
  		}&#xD;
	}&#xD;
 &#xD;
function loadTasks(ltcapidstr)&#xD;
	{&#xD;
	if (typeof(ltcapidstr) == &quot;string&quot;)&#xD;
                {&#xD;
		var ltresult = aa.cap.getCapID(ltcapidstr); &#xD;
	 	if (ltresult.getSuccess())&#xD;
  		 	ltCapId = ltresult.getOutput();&#xD;
	  	else&#xD;
  		  	{ logMessage(&quot;**ERROR: Failed to get cap ID: &quot; + ltcapidstr + &quot; error: &quot; +  ltresult.getErrorMessage()); return false; }&#xD;
                }&#xD;
	else&#xD;
		ltCapId = ltcapidstr;&#xD;
&#xD;
  	var taskArr = new Array();&#xD;
  	&#xD;
	var workflowResult = aa.workflow.getTasks(ltCapId);&#xD;
	if (workflowResult.getSuccess())&#xD;
		wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		fTask = wfObj[i];&#xD;
		var myTask = new Task();&#xD;
		myTask.status = fTask.getDisposition();&#xD;
		myTask.comment = fTask.getDispositionComment();&#xD;
		myTask.process = fTask.getProcessCode();&#xD;
                if (fTask.getStatusDate()) myTask.statusdate = &quot;&quot; + fTask.getStatusDate().getMonth() + &quot;/&quot; + fTask.getStatusDate().getDate() + &quot;/&quot; + (fTask.getStatusDate().getYear() + 1900);&#xD;
		myTask.processID = fTask.getProcessID();&#xD;
		myTask.note = fTask.getDispositionNote();&#xD;
		taskArr[fTask.getTaskDescription()] = myTask;&#xD;
		}			&#xD;
	return taskArr;&#xD;
	}&#xD;
&#xD;
function Task() // Task Object&#xD;
	{&#xD;
	this.status = null&#xD;
	this.comment = null;&#xD;
	this.note = null;&#xD;
        this.statusdate = null;&#xD;
	this.process = null;&#xD;
	this.processID = null;&#xD;
	}	&#xD;
 &#xD;
function loadTaskSpecific(thisArr) &#xD;
	{&#xD;
 	// &#xD;
 	// Appends the Task Specific Info to App Specific Array&#xD;
 	// If useTaskSpecificGroupName==true, appends wf process code.wftask. to TSI field label&#xD;
	// Optional second parameter, cap ID to load from&#xD;
	//&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 2) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
 	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
 		var wfObj = workflowResult.getOutput();&#xD;
 	else&#xD;
 		{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()) ; return false; }&#xD;
 &#xD;
 	for (i in wfObj)&#xD;
 		{&#xD;
 		var fTask = wfObj[i];&#xD;
 		var stepnumber = fTask.getStepNumber();&#xD;
 		var processID = fTask.getProcessID();&#xD;
 		var TSIResult = aa.taskSpecificInfo.getTaskSpecificInfoByTask(itemCap, processID, stepnumber)&#xD;
 		if (TSIResult.getSuccess())&#xD;
 			{&#xD;
 			var TSI = TSIResult.getOutput();&#xD;
 			for (a1 in TSI)&#xD;
  				{&#xD;
  				if (useTaskSpecificGroupName)&#xD;
  	  				thisArr[fTask.getProcessCode() + &quot;.&quot; + fTask.getTaskDescription() + &quot;.&quot; + TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
  	  			else&#xD;
	  				thisArr[TSI[a1].getCheckboxDesc()] = TSI[a1].getChecklistComment();&#xD;
				}&#xD;
 			}&#xD;
 		}&#xD;
	}&#xD;
 &#xD;
function lookup(stdChoice,stdValue) &#xD;
	{&#xD;
	var strControl;&#xD;
	var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoice,stdValue);&#xD;
	&#xD;
   	if (bizDomScriptResult.getSuccess())&#xD;
   		{&#xD;
		var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
		var strControl = &quot;&quot; + bizDomScriptObj.getDescription(); // had to do this or it bombs.  who knows why?&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) = &quot; + strControl);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;lookup(&quot; + stdChoice + &quot;,&quot; + stdValue + &quot;) does not exist&quot;);&#xD;
		}&#xD;
	return strControl;&#xD;
	}&#xD;
&#xD;
 &#xD;
function lookupDateRange(stdChoiceEntry,dateValue) // optional val number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 3) valNumber = arguments[2];&#xD;
&#xD;
	var compDate = new Date(dateValue);&#xD;
	var domArr&#xD;
	for (var count=1; count &lt;= 9999; count++)  // Must be sequential from 01 up to 9999&#xD;
		{&#xD;
		var countstr = &quot;0000&quot; + count;&#xD;
		var countstr = String(countstr).substring(countstr.length,countstr.length - 4);&#xD;
		var bizDomScriptResult = aa.bizDomain.getBizDomainByValue(stdChoiceEntry,countstr);&#xD;
	   	&#xD;
	   	if (bizDomScriptResult.getSuccess())&#xD;
	   		{&#xD;
			var bizDomScriptObj = bizDomScriptResult.getOutput();&#xD;
			var domVal = bizDomScriptObj.getDescription();&#xD;
			if (bizDomScriptObj.getAuditStatus() != 'I')&#xD;
				{&#xD;
				var domOld = domArr;&#xD;
				var domArr = domVal.split(&quot;\\^&quot;)&#xD;
				var domDate = new Date(domArr[0])&#xD;
				if (domDate &gt;= compDate)     //  found the next tier, use the last value&#xD;
					if (domOld)&#xD;
						return domOld[valNumber];&#xD;
					else&#xD;
						break;&#xD;
				}					&#xD;
			}&#xD;
		else&#xD;
			if (domArr)&#xD;
				return domArr[valNumber];&#xD;
			else&#xD;
				break;&#xD;
		}&#xD;
	}	&#xD;
 &#xD;
function lookupFeesByValuation(stdChoiceEntry,stdChoiceValue,capval) // optional arg number &#xD;
	{&#xD;
	var valNumber = 1;&#xD;
	if (arguments.length == 4) valNumber = arguments[3];&#xD;
&#xD;
	var saveVal ; &#xD;
	var lookupStr = lookup(stdChoiceEntry,stdChoiceValue);&#xD;
	&#xD;
	if (lookupStr)&#xD;
		{&#xD;
		workArr = lookupStr.split(&quot;^&quot;);&#xD;
		for (var i in workArr)&#xD;
			{&#xD;
                        aa.print(workArr[i]);&#xD;
			workVals = workArr[i].split(&quot;|&quot;);&#xD;
			if (workVals[0] &gt; capval) &#xD;
				return saveVal;&#xD;
			else&#xD;
				if (valNumber == 1)&#xD;
					saveVal = workVals[valNumber];&#xD;
				else&#xD;
					{&#xD;
					saveVal = parseInt((capval - workVals[0])/100);&#xD;
					if ((capval - workVals[0]) % 100 &gt; 0) saveVal++;&#xD;
					saveVal = saveVal * workVals[valNumber];&#xD;
					}&#xD;
			}&#xD;
		}&#xD;
	return saveVal;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function loopTask(wfstr,wfstat,wfcomment,wfnote) // optional process name&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 5) &#xD;
		{&#xD;
		processName = arguments[4]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
	&#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj ,&quot;L&quot;);&#xD;
			&#xD;
			logMessage(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			logDebug(&quot;Closing Workflow Task: &quot; + wfstr + &quot; with status &quot; + wfstat + &quot;, Looping...&quot;);&#xD;
			}			&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function nextWorkDay(td)   &#xD;
	// uses app server to return the next work day.&#xD;
	// Only available in 6.3.2&#xD;
	// td can be &quot;mm/dd/yyyy&quot; (or anything that will convert to JS date)&#xD;
	{&#xD;
	&#xD;
	if (!td) &#xD;
		dDate = new Date();&#xD;
	else&#xD;
		dDate = new Date(td);&#xD;
&#xD;
	if (!aa.calendar.getNextWorkDay)&#xD;
		{&#xD;
		logDebug(&quot;getNextWorkDay function is only available in Accela Automation 6.3.2 or higher.&quot;);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var dDate = new Date(aa.calendar.getNextWorkDay(aa.date.parseDate(dDate.getMonth()+1 + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear())).getOutput().getTime());&#xD;
		}&#xD;
&#xD;
	return (dDate.getMonth()+1) + &quot;/&quot; + dDate.getDate() + &quot;/&quot; + dDate.getFullYear();;&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function openUrlInNewWindow(myurl)&#xD;
 {&#xD;
 //&#xD;
 // showDebug or showMessage must be true for this to work&#xD;
 //&#xD;
 newurl = &quot;&lt;invalidTag LANGUAGE=\&quot;JavaScript\&quot;&gt;\r\n&lt;!--\r\n newwin = window.open(\&quot;&quot;&#xD;
 newurl+=myurl&#xD;
 newurl+=&quot;\&quot;); \r\n  //--&gt; \r\n &lt;/SCRIPT&gt;&quot;&#xD;
 &#xD;
 comment(newurl)&#xD;
 }&#xD;
&#xD;
 &#xD;
function parcelConditionExists(condtype)&#xD;
	{&#xD;
	var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
	if (!capParcelResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error getting cap parcels : &quot; + capParcelResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var Parcels = capParcelResult.getOutput().toArray();&#xD;
	for (zz in Parcels)&#xD;
		{&#xD;
		pcResult = aa.parcelCondition.getParcelConditions(Parcels[zz].getParcelNumber());&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			if (pcs[pc1].getConditionType().equals(condtype)) return true;&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function paymentGetNotAppliedTot() //gets total Amount Not Applied on current CAP&#xD;
	{&#xD;
	var amtResult = aa.cashier.getSumNotAllocated(capId);&#xD;
	if (amtResult.getSuccess())&#xD;
		{&#xD;
		var appliedTot = amtResult.getOutput();&#xD;
		//logDebug(&quot;Total Amount Not Applied = $&quot;+appliedTot.toString());&#xD;
		return parseFloat(appliedTot);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;**ERROR: Getting total not applied: &quot; + amtResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	return false;&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximity(svc,layer,numDistance)  // optional: distanceType&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// 6/20/07 JHS - Changed errors to Warnings in case GIS server unavailable.&#xD;
&#xD;
	var distanceType = &quot;feet&quot;&#xD;
	if (arguments.length == 4) distanceType = arguments[3]; // use distance type in arg list&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(layer + &quot;_ID&quot;);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess())&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**WARNING: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**WARNING: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }&#xD;
&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			var proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			if (proxObj.length)&#xD;
				{&#xD;
				return true;&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function proximityToAttribute(svc,layer,numDistance,distanceType,attributeName,attributeValue)&#xD;
	{&#xD;
	// returns true if the app has a gis object in proximity that contains the attributeName = attributeValue&#xD;
	// use with all events except ApplicationSubmitBefore&#xD;
	// example usage:&#xD;
	// 01 proximityToAttribute(&quot;flagstaff&quot;,&quot;Parcels&quot;,&quot;50&quot;,&quot;feet&quot;,&quot;BOOK&quot;,&quot;107&quot;) ^ DoStuff...&#xD;
&#xD;
	var bufferTargetResult = aa.gis.getGISType(svc,layer); // get the buffer target&#xD;
	if (bufferTargetResult.getSuccess())&#xD;
		{&#xD;
		var buf = bufferTargetResult.getOutput();&#xD;
		buf.addAttributeName(attributeName);&#xD;
		}&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS Type for Buffer Target.  Reason is: &quot; + bufferTargetResult.getErrorType() + &quot;:&quot; + bufferTargetResult.getErrorMessage()) ; return false }&#xD;
			&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var bufchk = aa.gis.getBufferByRadius(fGisObj[a1], numDistance, distanceType, buf);&#xD;
&#xD;
		if (bufchk.getSuccess())&#xD;
			var proxArr = bufchk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving Buffer Check Results.  Reason is: &quot; + bufchk.getErrorType() + &quot;:&quot; + bufchk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		for (a2 in proxArr)&#xD;
			{&#xD;
			proxObj = proxArr[a2].getGISObjects();  // if there are GIS Objects here, we're done&#xD;
			for (z1 in proxObj)&#xD;
				{&#xD;
				var v = proxObj[z1].getAttributeValues()&#xD;
				retString = v[0];&#xD;
				&#xD;
				if (retString &amp;&amp; retString.equals(attributeValue))&#xD;
					return true;&#xD;
				}&#xD;
			&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function refLicProfGetAttribute(pLicNum, pAttributeName)&#xD;
	{&#xD;
	//Gets value of custom attribute from reference license prof record&#xD;
	//07SSP-00033/SP5014&#xD;
&#xD;
	//validate parameter values&#xD;
	if (pLicNum==null || pLicNum.length==0 || pAttributeName==null || pAttributeName.length==0)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number or attribute name parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	//get reference License Professional record&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	//get reference License Professional's license seq num&#xD;
	var licSeqNum = 0;&#xD;
	var attributeType = &quot;&quot;;&#xD;
	if (newLic)&#xD;
		{&#xD;
		licSeqNum = newLic.getLicSeqNbr();&#xD;
		attributeType = newLic.getLicenseType();&#xD;
		logDebug(&quot;License Seq Num: &quot;+licSeqNum + &quot;, License Type: &quot;+attributeType);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logMessage(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		logDebug(&quot;No reference licensed professional found with state license number of &quot;+pLicNum);&#xD;
		return (&quot;NO LICENSE FOUND&quot;);&#xD;
		}&#xD;
&#xD;
	//get ref Lic Prof custom attribute using license seq num &amp; attribute type&#xD;
	if ( !(licSeqNum==0 || licSeqNum==null || attributeType==&quot;&quot; || attributeType==null) )&#xD;
		{&#xD;
		var peopAttrResult = aa.people.getPeopleAttributeByPeople(licSeqNum, attributeType);&#xD;
			if (!peopAttrResult.getSuccess())&#xD;
			{&#xD;
			logDebug(&quot;**ERROR retrieving reference license professional attribute: &quot; + peopAttrResult.getErrorMessage());&#xD;
			return false;&#xD;
			}&#xD;
&#xD;
		var peopAttrArray = peopAttrResult.getOutput();&#xD;
		if (peopAttrArray)&#xD;
			{&#xD;
			for (i in peopAttrArray)&#xD;
				{&#xD;
				if ( pAttributeName.equals(peopAttrArray[i].getAttributeName()) )&#xD;
					{&#xD;
					logDebug(&quot;Reference record for license &quot;+pLicNum+&quot;, attribute &quot;+pAttributeName+&quot;: &quot;+peopAttrArray[i].getAttributeValue());&#xD;
					return peopAttrArray[i].getAttributeValue();&#xD;
					}&#xD;
				}&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no attribute named &quot;+pAttributeName);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no custom attributes&quot;);&#xD;
			return (&quot;ATTRIBUTE NOT FOUND&quot;);&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		logDebug(&quot;Missing seq nbr or license type&quot;);&#xD;
		return false;&#xD;
		}&#xD;
	}&#xD;
 &#xD;
function refLicProfGetDate (pLicNum, pDateType)&#xD;
	{&#xD;
	//Returns expiration date from reference licensed professional record.  Skips disabled reference licensed professionals.&#xD;
	//pDateType parameter decides which date field is returned.  Options: &quot;EXPIRE&quot; (default), &quot;RENEW&quot;,&quot;ISSUE&quot;,&quot;BUSINESS&quot;,&quot;INSURANCE&quot;&#xD;
	//Internal Functions needed: convertDate(), jsDateToMMDDYYYY()&#xD;
	//07SSP-00033/SP5014  Edited for SR5054A.R70925&#xD;
	//&#xD;
	if (pDateType==null || pDateType==&quot;&quot;)&#xD;
		var dateType = &quot;EXPIRE&quot;;&#xD;
	else&#xD;
		{&#xD;
		var dateType = pDateType.toUpperCase();&#xD;
		if ( !(dateType==&quot;ISSUE&quot; || dateType==&quot;RENEW&quot; || dateType==&quot;BUSINESS&quot; || dateType==&quot;INSURANCE&quot;) )&#xD;
			dateType = &quot;EXPIRE&quot;;&#xD;
		}&#xD;
&#xD;
	if (pLicNum==null || pLicNum==&quot;&quot;)&#xD;
		{&#xD;
		logDebug(&quot;Invalid license number parameter&quot;);&#xD;
		return (&quot;INVALID PARAMETER&quot;);&#xD;
		}&#xD;
&#xD;
	var newLic = getRefLicenseProf(pLicNum)&#xD;
&#xD;
	if (newLic)&#xD;
		{&#xD;
		var jsExpDate = new Date();&#xD;
&#xD;
 		if (dateType==&quot;EXPIRE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseExpirationDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseExpirationDate());&#xD;
				logDebug(pLicNum+&quot; License Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no License Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;INSURANCE&quot;)&#xD;
			{&#xD;
			if (newLic.getInsuranceExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getInsuranceExpDate());&#xD;
				logDebug(pLicNum+&quot; Insurance Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Insurance Expiration Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;BUSINESS&quot;)&#xD;
			{&#xD;
			if (newLic.getBusinessLicExpDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getBusinessLicExpDate());&#xD;
				logDebug(pLicNum+&quot; Business Lic Expiration Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Business Lic Exp Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;ISSUE&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseIssueDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseIssueDate());&#xD;
				logDebug(pLicNum+&quot; License Issue Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Issue Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else if (dateType==&quot;RENEW&quot;)&#xD;
			{&#xD;
			if (newLic.getLicenseLastRenewalDate())&#xD;
				{&#xD;
				jsExpDate = convertDate(newLic.getLicenseLastRenewalDate());&#xD;
				logDebug(pLicNum+&quot; License Last Renewal Date: &quot;+jsDateToMMDDYYYY(jsExpDate));&#xD;
				return jsExpDate;&#xD;
				}&#xD;
			else&#xD;
				{&#xD;
				logDebug(&quot;Reference record for license &quot;+pLicNum+&quot; has no Last Renewal Date&quot;);&#xD;
				return (&quot;NO DATE FOUND&quot;);&#xD;
				}&#xD;
			}&#xD;
		else&#xD;
			return (&quot;NO DATE FOUND&quot;);&#xD;
		}&#xD;
	} &#xD;
  function removeASITable(tableName) // optional capId&#xD;
  	{&#xD;
	//  tableName is the name of the ASI table&#xD;
	//  tableValues is an associative array of values.  All elements MUST be strings.&#xD;
  	var itemCap = capId&#xD;
	if (arguments.length &gt; 2) &#xD;
		itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
	&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
		&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	var fld = tsm.getTableField();&#xD;
	&#xD;
	tsm.getColumns().clear();&#xD;
&#xD;
	tsm.setTableField(fld);&#xD;
	&#xD;
	var addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, currentUserID);&#xD;
	&#xD;
	// Even when this works it gives an error of &quot;0&quot;&#xD;
	//if (!addResult .getSuccess())&#xD;
	//	{ logDebug(&quot;**WARNING: error removing all rows from ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	//else&#xD;
		logDebug(&quot;Successfully removed all rows from ASI Table: &quot; + tableName);&#xD;
&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
function removeCapCondition(cType,cDesc)&#xD;
	{&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var capCondResult = aa.capCondition.getCapConditions(itemCap,cType);&#xD;
&#xD;
	if (!capCondResult.getSuccess())&#xD;
		{logDebug(&quot;**WARNING: error getting cap conditions : &quot; + capCondResult.getErrorMessage()) ; return false }&#xD;
	&#xD;
	var ccs = capCondResult.getOutput();&#xD;
		for (pc1 in ccs)&#xD;
			{&#xD;
			if (ccs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmCapCondResult = aa.capCondition.deleteCapCondition(itemCap,ccs[pc1].getConditionNumber()); &#xD;
				if (rmCapCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to CAP : &quot; + itemCap + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				else&#xD;
					logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
				}&#xD;
			}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function removeFee(fcode,fperiod) // Removes all fee items for a fee code and period&#xD;
	{&#xD;
	getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{	&#xD;
		var feeList = getFeeResult.getOutput();&#xD;
		for (feeNum in feeList)&#xD;
			{&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;)) &#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				&#xD;
				var editResult = aa.finance.removeFeeItem(capId, feeSeq);&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Removed existing Fee Item: &quot; + fcode);&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: removing fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
				logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, not removed&quot;);&#xD;
				}&#xD;
			}&#xD;
		}		&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
	&#xD;
	}&#xD;
&#xD;
 &#xD;
function removeParcelCondition(parcelNum,cType,cDesc)&#xD;
//if parcelNum is null, condition is added to all parcels on CAP&#xD;
	{&#xD;
	if (!parcelNum)&#xD;
		{&#xD;
		var capParcelResult = aa.parcel.getParcelandAttribute(capId,null);&#xD;
		if (capParcelResult.getSuccess())&#xD;
			{&#xD;
			var Parcels = capParcelResult.getOutput().toArray();&#xD;
			for (zz in Parcels)&#xD;
				{&#xD;
				parcelNum = Parcels[zz].getParcelNumber()&#xD;
				logDebug(&quot;Adding Condition to parcel #&quot; + zz + &quot; = &quot; + parcelNum);&#xD;
				var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
				if (!pcResult.getSuccess())&#xD;
					{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
				var pcs = pcResult.getOutput();&#xD;
				for (pc1 in pcs)&#xD;
					{&#xD;
					if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
						{&#xD;
						var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
						if (rmParcelCondResult.getSuccess())&#xD;
							logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
						}&#xD;
					else&#xD;
						logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
					}&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		var pcResult = aa.parcelCondition.getParcelConditions(parcelNum);&#xD;
		if (!pcResult.getSuccess())&#xD;
			{ logDebug(&quot;**WARNING: error getting parcel conditions : &quot; + pcResult.getErrorMessage()) ; return false }&#xD;
		var pcs = pcResult.getOutput();&#xD;
		for (pc1 in pcs)&#xD;
			{&#xD;
			if (pcs[pc1].getConditionType().equals(cType) &amp;&amp; pcs[pc1].getConditionDescription().equals(cDesc))&#xD;
				{&#xD;
				var rmParcelCondResult = aa.parcelCondition.removeParcelCondition(pcs[pc1].getConditionNumber(),parcelNum); &#xD;
			        if (rmParcelCondResult.getSuccess())&#xD;
					logDebug(&quot;Successfully removed condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;) &quot; + cDesc);&#xD;
				}&#xD;
			else&#xD;
				logDebug( &quot;**ERROR: removing condition to Parcel &quot; + parcelNum + &quot;  (&quot; + cType + &quot;): &quot; + addParcelCondResult.getErrorMessage());&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
&#xD;
function replaceNode(fString,fName,fContents)&#xD;
	{&#xD;
	 var fValue = &quot;&quot;;&#xD;
	var startTag = &quot;&lt;&quot;+fName+&quot;&gt;&quot;;&#xD;
	 var endTag = &quot;&lt;/&quot;+fName+&quot;&gt;&quot;;&#xD;
&#xD;
		 startPos = fString.indexOf(startTag) + startTag.length;&#xD;
		 endPos = fString.indexOf(endTag);&#xD;
		 // make sure startPos and endPos are valid before using them&#xD;
		 if (startPos &gt; 0 &amp;&amp; startPos &lt;= endPos)&#xD;
		 		{&#xD;
				  fValue = fString.substring(0,startPos) + fContents + fString.substring(endPos);&#xD;
 					return unescape(fValue);&#xD;
			}&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function resultInspection(inspType,inspStatus,resultDate,resultComment)  //optional capId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 4) itemCap = arguments[4]; // use cap ID specified in args&#xD;
&#xD;
	var foundID;&#xD;
	var inspResultObj = aa.inspection.getInspections(itemCap);&#xD;
	if (inspResultObj.getSuccess())&#xD;
		{&#xD;
		var inspList = inspResultObj.getOutput();&#xD;
		for (xx in inspList)&#xD;
			if (String(inspType).equals(inspList[xx].getInspectionType()) &amp;&amp; inspList[xx].getInspectionStatus().toUpperCase().equals(&quot;SCHEDULED&quot;))&#xD;
				foundID = inspList[xx].getIdNumber();&#xD;
		}&#xD;
&#xD;
	if (foundID)&#xD;
		{&#xD;
		resultResult = aa.inspection.resultInspection(itemCap, foundID, inspStatus, resultDate, resultComment, currentUserID)&#xD;
&#xD;
		if (resultResult.getSuccess())&#xD;
			logDebug(&quot;Successfully resulted inspection: &quot; + inspType + &quot; to Status: &quot; + inspStatus)&#xD;
		else&#xD;
			logDebug(&quot;**WARNING could not result inspection : &quot; + inspType + &quot;, &quot; + resultResult.getErrorMessage())&#xD;
		}&#xD;
	else&#xD;
			logDebug(&quot;Could not result inspection : &quot; + inspType + &quot;, not scheduled&quot;)&#xD;
&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspectDate(iType,DateToSched) // optional inspector ID. &#xD;
// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110)&#xD;
// DQ - Added Optional 5th parameter inspComm &#xD;
	{&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
	&#xD;
        if (arguments.length &gt;= 4)&#xD;
            if(arguments[3] != null)&#xD;
		        inspTime = arguments[3];&#xD;
		        &#xD;
		if (arguments.length &gt;= 5)&#xD;
		    if(arguments[4] != null)&#xD;
		        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(DateToSched), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + DateToSched);&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function scheduleInspection(iType,DaysAhead) // optional inspector ID.  This function requires dateAdd function&#xD;
	{&#xD;
	// DQ - Added Optional 4th parameter inspTime Valid format is HH12:MIAM or AM (SR5110) &#xD;
	// DQ - Added Optional 5th parameter inspComm ex. to call without specifying other options params scheduleInspection(&quot;Type&quot;,5,null,null,&quot;Schedule Comment&quot;);&#xD;
	var inspectorObj = null;&#xD;
	var inspTime = null;&#xD;
	var inspComm = &quot;Scheduled via Script&quot;;&#xD;
	if (arguments.length &gt;= 3) &#xD;
		if (arguments[2] != null)&#xD;
		{&#xD;
		var inspRes = aa.person.getUser(arguments[2])&#xD;
		if (inspRes.getSuccess())&#xD;
			var inspectorObj = inspRes.getOutput();&#xD;
		}&#xD;
&#xD;
	if (arguments.length &gt;= 4)&#xD;
	    if (arguments[3] != null)&#xD;
		    inspTime = arguments[3];&#xD;
	&#xD;
	if (arguments.length == 5)&#xD;
	    if (arguments[4] != null)&#xD;
	        inspComm = arguments[4];&#xD;
&#xD;
	var schedRes = aa.inspection.scheduleInspection(capId, inspectorObj, aa.date.parseDate(dateAdd(null,DaysAhead)), inspTime, iType, inspComm)&#xD;
	&#xD;
	if (schedRes.getSuccess())&#xD;
		logDebug(&quot;Successfully scheduled inspection : &quot; + iType + &quot; for &quot; + dateAdd(null,DaysAhead));&#xD;
	else&#xD;
		logDebug( &quot;**ERROR: adding scheduling inspection (&quot; + iType + &quot;): &quot; + schedRes.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function searchProject(pProjType,pSearchType) &#xD;
{&#xD;
	// Searches Related Caps&#xD;
	// pProjType = Application type marking highest point to search.  Ex. Building/Project/NA/NA&#xD;
	// pSearchType = Application type to search for. Ex. Building/Permit/NA/NA &#xD;
	// Returns CapID array of all unique matching SearchTypes&#xD;
	&#xD;
    var i = 1;&#xD;
	var typeArray;&#xD;
	var duplicate = false;&#xD;
	var childArray = new Array();&#xD;
	var tempArray = new Array();&#xD;
	var temp2Array = new Array();&#xD;
	var searchArray = new Array();&#xD;
	var childrenFound = false;&#xD;
	var isMatch;&#xD;
        while (true)&#xD;
        {&#xD;
	 if (!(aa.cap.getProjectParents(capId,i).getSuccess()))&#xD;
             break;&#xD;
         i += 1;&#xD;
        }&#xD;
        i -= 1;&#xD;
&#xD;
	getCapResult = aa.cap.getProjectParents(capId,i);&#xD;
        myArray = new Array();&#xD;
	myOutArray = new Array();&#xD;
	&#xD;
	if(pProjType != null)&#xD;
	{&#xD;
		var typeArray = pProjType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pCapType);&#xD;
	}&#xD;
&#xD;
	if (getCapResult.getSuccess())&#xD;
	{&#xD;
		parentArray = getCapResult.getOutput();&#xD;
		if (parentArray.length)&#xD;
		{&#xD;
			for(x in parentArray)&#xD;
				childTypeArray = parentArray[x].getCapType().toString().split(&quot;/&quot;);&#xD;
				isMatch = true;&#xD;
				for (yy in childTypeArray) //looking for matching cap type&#xD;
				{&#xD;
				if (!typeArray[yy].equals(childTypeArray[yy]) &amp;&amp; !typeArray[yy].equals(&quot;*&quot;))&#xD;
					{&#xD;
						isMatch = false;&#xD;
						break;	 &#xD;
					}&#xD;
				}&#xD;
				if(isMatch)&#xD;
					myArray.push(parentArray[x].getCapID());&#xD;
		}&#xD;
	}&#xD;
&#xD;
	if (!myArray.length)&#xD;
		return childArray;&#xD;
&#xD;
	searchArray = myArray;&#xD;
	var temp = &quot;&quot;&#xD;
&#xD;
&#xD;
	if(pSearchType != null)&#xD;
	{&#xD;
		typeArray = pSearchType.split(&quot;/&quot;);&#xD;
		if (typeArray.length != 4)&#xD;
			logDebug(&quot;**ERROR in childGetByCapType function parameter.  The following cap type parameter is incorrectly formatted: &quot; + pSearchType);&#xD;
	}&#xD;
&#xD;
&#xD;
	while (true)&#xD;
		{&#xD;
			for(x in searchArray)&#xD;
				{&#xD;
					tempArray = getChildren(&quot;*/*/*/*&quot;,searchArray[x]);&#xD;
					if (tempArray == null)&#xD;
						continue;&#xD;
					for(y in tempArray)&#xD;
						{&#xD;
							duplicate = false;&#xD;
							for(z in childArray)&#xD;
							{&#xD;
								if ( childArray[z].getCustomID().equals(tempArray[y].getCustomID()) )&#xD;
									{duplicate = true; break;}&#xD;
							}			&#xD;
							if (!duplicate)&#xD;
							{&#xD;
								temp2Array.push(tempArray[y]);&#xD;
								if(!capId.getCustomID().equals(tempArray[y].getCustomID()))&#xD;
								{&#xD;
									var chkTypeArray = aa.cap.getCap(tempArray[y]).getOutput().getCapType().toString().split(&quot;/&quot;);&#xD;
									isMatch = true;&#xD;
									for (p in chkTypeArray) //looking for matching cap type&#xD;
									{&#xD;
										if (typeArray[p] != chkTypeArray[p] &amp;&amp; typeArray[p] != &quot;*&quot;)&#xD;
										{&#xD;
											isMatch = false;&#xD;
											break;&#xD;
										}&#xD;
									}&#xD;
									if(isMatch)&#xD;
										{childArray.push(tempArray[y]);}&#xD;
								}		 &#xD;
							}&#xD;
						}&#xD;
&#xD;
				}&#xD;
&#xD;
			if(temp2Array.length)&#xD;
				searchArray = temp2Array;&#xD;
			else&#xD;
				break;&#xD;
			temp2Array = new Array();&#xD;
		}&#xD;
	return childArray;&#xD;
}&#xD;
&#xD;
 &#xD;
function setIVR(ivrnum)&#xD;
	{&#xD;
	capModel = cap.getCapModel();&#xD;
	capIDModel = capModel.getCapID();&#xD;
	 &#xD;
	capModel.setCapID(capIDModel);&#xD;
	 &#xD;
	aa.cap.editCapByPK(capModel);&#xD;
	&#xD;
	// new a CapScriptModel &#xD;
	var scriptModel = aa.cap.newCapScriptModel().getOutput();&#xD;
&#xD;
	// get a new CapModel &#xD;
	var capModel = scriptModel.getCapModel(); &#xD;
	var capIDModel = capModel.getCapID(); &#xD;
&#xD;
	capIDModel.setServiceProviderCode(scriptModel.getServiceProviderCode()); &#xD;
	capIDModel.setID1(aa.env.getValue(&quot;PermitId1&quot;)); &#xD;
	capIDModel.setID2(aa.env.getValue(&quot;PermitId2&quot;)); &#xD;
	capIDModel.setID3(aa.env.getValue(&quot;PermitId3&quot;)); &#xD;
&#xD;
	capModel.setTrackingNbr(ivrnum);&#xD;
	capModel.setCapID(capIDModel); &#xD;
&#xD;
	// update tracking number &#xD;
	aa.cap.editCapByPK(capModel); &#xD;
	comment(&quot;IVR Tracking Number updated to &quot; + ivrnum);&#xD;
	}&#xD;
&#xD;
&#xD;
 &#xD;
function taskCloseAllExcept(pStatus,pComment) &#xD;
	{&#xD;
	// Closes all tasks in CAP with specified status and comment&#xD;
	// Optional task names to exclude&#xD;
	// 06SSP-00152&#xD;
	//&#xD;
	var taskArray = new Array();&#xD;
	var closeAll = false;&#xD;
	if (arguments.length &gt; 2) //Check for task names to exclude&#xD;
		{&#xD;
		for (var i=2; i&lt;arguments.length; i++)&#xD;
			taskArray.push(arguments[i]);&#xD;
		}&#xD;
	else&#xD;
		closeAll = true;&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  else&#xD;
  	{ &#xD;
		logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); &#xD;
		return false; &#xD;
		}&#xD;
	&#xD;
	var fTask;&#xD;
	var stepnumber;&#xD;
	var processID;&#xD;
	var dispositionDate = aa.date.getCurrentDate();&#xD;
	var wfnote = &quot; &quot;;&#xD;
	var wftask;&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   	fTask = wfObj[i];&#xD;
		wftask = fTask.getTaskDescription();&#xD;
		stepnumber = fTask.getStepNumber();&#xD;
		//processID = fTask.getProcessID();&#xD;
		if (closeAll)&#xD;
			{&#xD;
			aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
			logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
			}&#xD;
		else&#xD;
			{&#xD;
			if (!exists(wftask,taskArray))&#xD;
				{&#xD;
				aa.workflow.handleDisposition(capId,stepnumber,pStatus,dispositionDate,wfnote,pComment,systemUserObj,&quot;Y&quot;);&#xD;
				logMessage(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				logDebug(&quot;Closing Workflow Task &quot; + wftask + &quot; with status &quot; + pStatus);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatus(wfstr) // optional process name and capID&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length &gt;= 2)&#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		if (processName) useProcess = true;&#xD;
		}&#xD;
&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + workflowResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return fTask.getDisposition()&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function taskStatusDate(wfstr) // optional process name, capId&#xD;
	{&#xD;
    &#xD;
    var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 1 &amp;&amp; arguments[1] != null) &#xD;
		{&#xD;
		processName = arguments[1]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + wfObj.getErrorMessage()); return false; }&#xD;
	&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			return &quot;&quot;+(fTask.getStatusDate().getMonth()+1)+&quot;/&quot;+fTask.getStatusDate().getDate()+&quot;/&quot;+(parseInt(fTask.getStatusDate().getYear())+1900);&#xD;
		}&#xD;
	} &#xD;
function transferFunds(parentAppNum,dollarAmount) &#xD;
// does fund transfer from current app to parentAppNum, but only if current app has enough non-applied funds&#xD;
// needs function paymentGetNotAppliedTot()&#xD;
	{&#xD;
	//validate dollarAmount is number &#xD;
	var checkNum = parseFloat(dollarAmount);&#xD;
	if (isNaN(checkNum))&#xD;
		{&#xD;
		logDebug(&quot;dollarAmount parameter is not a number, no funds will be transferred&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//check that enough non-applied funds are available&#xD;
	var fundsAvail = paymentGetNotAppliedTot();&#xD;
	if (fundsAvail &lt; parseFloat(dollarAmount))&#xD;
		{&#xD;
		logDebug(&quot;Insufficient funds $&quot;+fundsAvail.toString()+ &quot; available. Fund transfer of $&quot;+dollarAmount.toString()+&quot; not done.&quot;);&#xD;
		logMessage(&quot;Insufficient funds available. No funds transferred.&quot;);&#xD;
		return false;&#xD;
		}&#xD;
&#xD;
	//enough funds - proceed with transfer&#xD;
	var getCapResult = aa.cap.getCapID(parentAppNum);&#xD;
	if (getCapResult.getSuccess())&#xD;
		{&#xD;
		var parentId = getCapResult.getOutput();&#xD;
		&#xD;
		var xferResult = aa.finance.makeFundTransfer(capId, parentId, currentUserID, &quot;&quot;, &quot;&quot;, sysDate, sysDate, &quot;&quot;, sysDate, dollarAmount, &quot;NA&quot;, &quot;Fund Transfer&quot;, &quot;NA&quot;, &quot;R&quot;, null, &quot;&quot;, &quot;NA&quot;, &quot;&quot;);&#xD;
&#xD;
		&#xD;
		if (xferResult.getSuccess())&#xD;
			logDebug(&quot;Successfully did fund transfer to : &quot; + parentAppNum);&#xD;
		else&#xD;
			logDebug( &quot;**ERROR: doing fund transfer to (&quot; + parentAppNum + &quot;): &quot; + xferResult.getErrorMessage());&#xD;
		}&#xD;
	else&#xD;
		{ &#xD;
		logDebug( &quot;**ERROR: getting parent cap id (&quot; + parentAppNum + &quot;): &quot; + getCapResult.getErrorMessage()) &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateAppStatus(stat,cmt) // optional cap id&#xD;
	{&#xD;
	&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 3) itemCap = arguments[2]; // use cap ID specified in args&#xD;
&#xD;
	var updateStatusResult = aa.cap.updateAppStatus(itemCap,&quot;APPLICATION&quot;,stat, sysDate, cmt ,systemUserObj);&#xD;
	if (updateStatusResult.getSuccess())&#xD;
		logDebug(&quot;Updated application status to &quot; + stat + &quot; successfully.&quot;);&#xD;
	else&#xD;
		logDebug(&quot;**ERROR: application status update to &quot; + stat + &quot; was unsuccessful.  The reason is &quot;  + updateStatusResult.getErrorType() + &quot;:&quot; + updateStatusResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
 &#xD;
function updateFee(fcode,fsched,fperiod,fqty,finvoice,pDuplicate,pFeeSeq) &#xD;
	{&#xD;
    // Updates an assessed fee with a new Qty.  If not found, adds it; else if invoiced fee found, adds another with adjusted qty.&#xD;
    // optional param pDuplicate -if &quot;N&quot;, won't add another if invoiced fee exists (SR5085)&#xD;
    // Script will return fee sequence number if new fee is added otherwise it will return null (SR5112)&#xD;
    // Optional param pSeqNumber, Will attempt to update the specified Fee Sequence Number or Add new (SR5112)&#xD;
        &#xD;
    // If optional argument is blank, use default logic (i.e. allow duplicate fee if invoiced fee is found)        &#xD;
    if ( pDuplicate==null || pDuplicate.length==0 )&#xD;
        pDuplicate = &quot;Y&quot;;&#xD;
    else&#xD;
        pDuplicate = pDuplicate.toUpperCase();&#xD;
        &#xD;
    var invFeeFound=false;    &#xD;
    var adjustedQty=fqty;&#xD;
    var feeSeq = null;&#xD;
	feeUpdated = false;&#xD;
&#xD;
	if(pFeeSeq == null)&#xD;
		getFeeResult = aa.finance.getFeeItemByFeeCode(capId,fcode,fperiod);&#xD;
	else&#xD;
		getFeeResult = aa.finance.getFeeItemByPK(capId,pFeeSeq);&#xD;
&#xD;
&#xD;
	if (getFeeResult.getSuccess())&#xD;
		{&#xD;
		if(pFeeSeq == null)&#xD;
			var feeList = getFeeResult.getOutput();&#xD;
		else&#xD;
		     {&#xD;
			var feeList = new Array();&#xD;
			feeList[0] = getFeeResult.getOutput();&#xD;
		     }&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;INVOICED&quot;))&#xD;
				{&#xD;
                    if (pDuplicate==&quot;Y&quot;)&#xD;
                        {&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found, subtracting invoiced amount from update qty.&quot;);&#xD;
        				adjustedQty = fqty - feeList[feeNum].getFeeUnit();&#xD;
                        invFeeFound=true;&#xD;
                        }&#xD;
                    else&#xD;
                        {&#xD;
                        invFeeFound=true;&#xD;
                        logDebug(&quot;Invoiced fee &quot;+fcode+&quot; found.  Not updating this fee. Not assessing new fee &quot;+fcode);&#xD;
                        }&#xD;
				}&#xD;
&#xD;
		for (feeNum in feeList)&#xD;
			if (feeList[feeNum].getFeeitemStatus().equals(&quot;NEW&quot;) &amp;&amp; !feeUpdated)  // update this fee item&#xD;
				{&#xD;
				var feeSeq = feeList[feeNum].getFeeSeqNbr();&#xD;
				var editResult = aa.finance.editFeeItemUnit(capId, fqty, feeSeq);&#xD;
				feeUpdated = true;&#xD;
				if (editResult.getSuccess())&#xD;
					{&#xD;
					logDebug(&quot;Updated Qty on Existing Fee Item: &quot; + fcode + &quot; to Qty: &quot; + fqty);&#xD;
					if (finvoice == &quot;Y&quot;)&#xD;
						{&#xD;
						feeSeqList.push(feeSeq);&#xD;
						paymentPeriodList.push(fperiod);&#xD;
						}&#xD;
					}&#xD;
				else&#xD;
					{ logDebug( &quot;**ERROR: updating qty on fee item (&quot; + fcode + &quot;): &quot; + editResult.getErrorMessage()); break }&#xD;
				}&#xD;
		}&#xD;
	else&#xD;
		{ logDebug( &quot;**ERROR: getting fee items (&quot; + fcode + &quot;): &quot; + getFeeResult.getErrorMessage())}&#xD;
&#xD;
    // Add fee if no fee has been updated OR invoiced fee already exists and duplicates are allowed&#xD;
	if ( !feeUpdated &amp;&amp; adjustedQty != 0 &amp;&amp; (!invFeeFound || invFeeFound &amp;&amp; pDuplicate==&quot;Y&quot;) ) &#xD;
		feeSeq = addFee(fcode,fsched,fperiod,adjustedQty,finvoice);&#xD;
	else&#xD;
		feeSeq = null;&#xD;
			&#xD;
	return feeSeq;&#xD;
	} &#xD;
&#xD;
function updateShortNotes(newSN) // option CapId&#xD;
	{&#xD;
	var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
&#xD;
	var cdScriptObjResult = aa.cap.getCapDetail(itemCap);&#xD;
	if (!cdScriptObjResult.getSuccess())&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object : &quot; + cdScriptObjResult.getErrorMessage()) ; return false; }&#xD;
&#xD;
	var cdScriptObj = cdScriptObjResult.getOutput();&#xD;
&#xD;
	if (!cdScriptObj)&#xD;
		{ logDebug(&quot;**ERROR: No cap detail script object&quot;) ; return false; }&#xD;
&#xD;
	cd = cdScriptObj.getCapDetailModel();&#xD;
&#xD;
	cd.setShortNotes(newSN);&#xD;
&#xD;
	cdWrite = aa.cap.editCapDetail(cd)&#xD;
&#xD;
	if (cdWrite.getSuccess())&#xD;
		{ logDebug(&quot;updated short notes to &quot; + newSN) }&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR writing capdetail : &quot; + cdWrite.getErrorMessage()) ; return false ; }&#xD;
	} &#xD;
function updateTask(wfstr,wfstat,wfcomment,wfnote) // optional process name, cap id&#xD;
	{&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length &gt; 4) &#xD;
		{&#xD;
		if (arguments[4] != &quot;&quot;)&#xD;
			{&#xD;
			processName = arguments[4]; // subprocess&#xD;
			useProcess = true;&#xD;
			}&#xD;
		}&#xD;
	var itemCap = capId;&#xD;
	if (arguments.length == 6) itemCap = arguments[5]; // use cap ID specified in args&#xD;
 &#xD;
	var workflowResult = aa.workflow.getTasks(itemCap);&#xD;
	if (workflowResult.getSuccess())&#xD;
		var wfObj = workflowResult.getOutput();&#xD;
	else&#xD;
	{ logMessage(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
            &#xD;
	if (!wfstat) wfstat = &quot;NA&quot;;&#xD;
            &#xD;
	for (i in wfObj)&#xD;
		{&#xD;
		var fTask = wfObj[i];&#xD;
		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
			var dispositionDate = aa.date.getCurrentDate();&#xD;
			var stepnumber = fTask.getStepNumber();&#xD;
			var processID = fTask.getProcessID();&#xD;
			if (useProcess)&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,processID,wfstat,dispositionDate, wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			else&#xD;
				aa.workflow.handleDisposition(itemCap,stepnumber,wfstat,dispositionDate,wfnote,wfcomment,systemUserObj,&quot;U&quot;);&#xD;
			logMessage(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			logDebug(&quot;Updating Workflow Task &quot; + wfstr + &quot; with status &quot; + wfstat);&#xD;
			}                                   &#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
&#xD;
function updateTaskAssignedDate(wfstr,wfAssignDate) // optional process name&#xD;
	{&#xD;
	// Update the task assignment date&#xD;
	//&#xD;
	var useProcess = false;&#xD;
	var processName = &quot;&quot;;&#xD;
	if (arguments.length == 3)&#xD;
		{&#xD;
		processName = arguments[2]; // subprocess&#xD;
		useProcess = true;&#xD;
		}&#xD;
&#xD;
&#xD;
&#xD;
	var workflowResult = aa.workflow.getTasks(capId);&#xD;
 	if (workflowResult.getSuccess())&#xD;
  	 	var wfObj = workflowResult.getOutput();&#xD;
  	else&#xD;
  	  	{ logDebug(&quot;**ERROR: Failed to get workflow object: &quot; + s_capResult.getErrorMessage()); return false; }&#xD;
&#xD;
	for (i in wfObj)&#xD;
		{&#xD;
   		var fTask = wfObj[i];&#xD;
 		if (fTask.getTaskDescription().toUpperCase().equals(wfstr.toUpperCase())  &amp;&amp; (!useProcess || fTask.getProcessCode().equals(processName)))&#xD;
			{&#xD;
                        var assignDate = aa.util.now();&#xD;
                        var tempDate = new Date(wfAssignDate);&#xD;
                        assignDate.setTime(tempDate.getTime())&#xD;
			if (assignDate)&#xD;
				{&#xD;
				var taskItem = fTask.getTaskItem();&#xD;
				taskItem.setAssignmentDate(assignDate);&#xD;
&#xD;
				var adjustResult = aa.workflow.adjustTaskWithNoAudit(taskItem);&#xD;
                                if (adjustResult.getSuccess())&#xD;
              				logDebug(&quot;Updated Workflow Task : &quot; + wfstr + &quot; Assigned Date to &quot; + wfAssignDate);&#xD;
                                else&#xD;
                                        logDebug(&quot;Error updating wfTask : &quot; + adjustResult.getErrorMessage());&#xD;
				}&#xD;
			else&#xD;
				logDebug(&quot;Couldn't update assigned date.  Invalid date : &quot; + wfAssignDate);&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
&#xD;
 &#xD;
	&#xD;
function updateWorkDesc(newWorkDes)  // optional CapId&#xD;
	{&#xD;
	 var itemCap = capId&#xD;
	if (arguments.length &gt; 1) itemCap = arguments[1]; // use cap ID specified in args&#xD;
	&#xD;
&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(itemCap);&#xD;
	var workDesObj;&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDesScriptObj = workDescResult.getOutput();&#xD;
	if (workDesScriptObj)&#xD;
		workDesObj = workDesScriptObj.getCapWorkDesModel() &#xD;
	else&#xD;
		{&#xD;
		aa.print(&quot;**ERROR: Failed to get workdes Obj: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
	&#xD;
	&#xD;
	workDesObj.setDescription(newWorkDes);&#xD;
	aa.cap.editCapWorkDes(workDesObj);&#xD;
	&#xD;
	aa.print(&quot;Updated Work Description to : &quot; + newWorkDes);&#xD;
		&#xD;
	}	&#xD;
 &#xD;
function validateGisObjects()&#xD;
	{&#xD;
	// returns true if the app has GIS objects that validate in GIS&#xD;
	//&#xD;
	var gisObjResult = aa.gis.getCapGISObjects(capId); // get gis objects on the cap&#xD;
	if (gisObjResult.getSuccess()) 	&#xD;
		var fGisObj = gisObjResult.getOutput();&#xD;
	else&#xD;
		{ logDebug(&quot;**ERROR: Getting GIS objects for Cap.  Reason is: &quot; + gisObjResult.getErrorType() + &quot;:&quot; + gisObjResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	for (a1 in fGisObj) // for each GIS object on the Cap&#xD;
		{&#xD;
		var gischk = aa.gis.getGISObjectAttributes(fGisObj[a1]);&#xD;
&#xD;
		if (gischk.getSuccess())&#xD;
			var gisres = gischk.getOutput();&#xD;
		else&#xD;
			{ logDebug(&quot;**ERROR: Retrieving GIS Attributes.  Reason is: &quot; + gischk.getErrorType() + &quot;:&quot; + gischk.getErrorMessage()) ; return false }	&#xD;
		&#xD;
		if (gisres != null)&#xD;
			return true;  // we have a gis object from GIS&#xD;
		}&#xD;
	}&#xD;
&#xD;
 &#xD;
function workDescGet(pCapId)&#xD;
	{&#xD;
	//Gets work description&#xD;
	//07SSP-00037/SP5017&#xD;
	//&#xD;
	var workDescResult = aa.cap.getCapWorkDesByPK(pCapId);&#xD;
	&#xD;
	if (!workDescResult.getSuccess())&#xD;
		{&#xD;
		logMessage(&quot;**ERROR: Failed to get work description: &quot; + workDescResult.getErrorMessage()); &#xD;
		return false;&#xD;
		}&#xD;
		&#xD;
	var workDescObj = workDescResult.getOutput();&#xD;
	var workDesc = workDescObj.getDescription();&#xD;
	&#xD;
	return workDesc;&#xD;
	}&#xD;
	 &#xD;
function zeroPad(num,count)&#xD;
{ &#xD;
var numZeropad = num + '';&#xD;
while(numZeropad.length &lt; count) {&#xD;
&#xD;
numZeropad = &quot;0&quot; + numZeropad; &#xD;
}&#xD;
return numZeropad;&#xD;
}&#xD;
&#xD;
function checkSiblingTasksComplete() // &#xD;
                {&#xD;
                var ignoreArray = new Array();&#xD;
                for (var i=1; i&lt;arguments.length;i++) &#xD;
                                ignoreArray.push(arguments[i])&#xD;
&#xD;
                // returns true if any of the subtasks are active&#xD;
&#xD;
		var itemCap = capId;&#xD;
		if (arguments.length == 1) itemCap = arguments[0]; // use cap ID specified in args&#xD;
&#xD;
                var taskResult = aa.workflow.getTasks(itemCap);&#xD;
                if (taskResult.getSuccess())&#xD;
                                { taskArr = taskResult.getOutput(); }&#xD;
                else&#xD;
                                { logDebug( &quot;**ERROR: CAP # &quot;+capId.getCustomID()+&quot; getting tasks : &quot; + taskResult.getErrorMessage()); return false }&#xD;
                                &#xD;
                for (xx in taskArr)&#xD;
                                if (taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
                                                return false;&#xD;
                return true;&#xD;
                }&#xD;
&#xD;
//Modified function allTasksComplete to check all task without passing the workflow process name and using the optional parameter itemCap if specified.&#xD;
//Original syntax listed below.&#xD;
//function allTasksComplete(stask)&#xD;
//if (taskArr[xx].getProcessCode().equals(stask) &amp;&amp; taskArr[xx].getActiveFlag().equals(&quot;Y&quot;) &amp;&amp; !exists(taskArr[xx].getTaskDescription(),ignoreArray))&#xD;
&#xD;
function compareDate(expDate)&#xD;
         {&#xD;
         var returnSysDate = new Date();&#xD;
         var returnAppDate = new Date(expDate);&#xD;
         var returnValue = true;&#xD;
&#xD;
            returnSysDate = startDate;&#xD;
&#xD;
            var returnAppMonth = returnAppDate.getMonth()+1;&#xD;
            var returnAppDay = returnAppDate.getDate();&#xD;
            var returnAppYear = returnAppDate.getYear()+ 1900;&#xD;
&#xD;
&#xD;
            var returnSysMonth = returnSysDate.getMonth()+1;&#xD;
            var returnSysDay = returnSysDate.getDate();&#xD;
            var returnSysYear = returnSysDate.getYear() + 1900;&#xD;
&#xD;
            if(returnAppYear == returnSysYear)&#xD;
            {&#xD;
                if(returnAppMonth &gt; returnSysMonth)&#xD;
                {&#xD;
                  returnValue = false;&#xD;
                }&#xD;
                else&#xD;
                {&#xD;
                   if(returnAppMonth == returnSysMonth)&#xD;
                   {&#xD;
                      if(returnAppDay &gt; returnSysDay)&#xD;
                      {&#xD;
                         returnValue = false;&#xD;
                      }&#xD;
                   }&#xD;
                }&#xD;
            }&#xD;
            else&#xD;
            {&#xD;
               if(returnAppYear &gt; returnSysYear)&#xD;
               {&#xD;
                   returnValue = false;&#xD;
               }&#xD;
            }&#xD;
         return returnValue;&#xD;
         }&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
// Added for the Renewal Process to update Status of license CAP when renewal is Approved&#xD;
&#xD;
function getParentCapIDForReview(capid)&#xD;
{&#xD;
	if (capid == null || aa.util.instanceOfString(capid))&#xD;
	{&#xD;
		return null;&#xD;
	}&#xD;
	//1. Get parent license for review&#xD;
	var result = aa.cap.getProjectByChildCapID(capid, &quot;Renewal&quot;, &quot;Incomplete&quot;);//&quot;Incomplete&quot; was&quot;Review&quot;&#xD;
    if(result.getSuccess())&#xD;
	{&#xD;
		projectScriptModels = result.getOutput();&#xD;
		if (projectScriptModels == null || projectScriptModels.length == 0)&#xD;
		{&#xD;
			logDebug(&quot;ERROR: Failed to get parent CAP with CAPID(&quot; + capid + &quot;) for review&quot;);&#xD;
			return null;&#xD;
		}&#xD;
		//2. return parent CAPID.&#xD;
		projectScriptModel = projectScriptModels[0];&#xD;
		return projectScriptModel.getProjectID();&#xD;
	}  &#xD;
    else &#xD;
    {&#xD;
      logDebug(&quot;ERROR: Failed to get parent CAP by child CAP(&quot; + capid + &quot;) for review: &quot; + result.getErrorMessage());&#xD;
      return null;&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
//new for licensing&#xD;
function copyASIT(sourceCapId,targetCapId) { //optional tablenames to ignore&#xD;
&#xD;
	var ignoreArray = new Array();&#xD;
	for (var i=2; i&lt;arguments.length;i++)&#xD;
		ignoreArray.push(arguments[i])&#xD;
&#xD;
	var gmRes = aa.appSpecificTableScript.getAppSpecificTableGroupModel(sourceCapId);&#xD;
	if (gmRes.getSuccess()) {&#xD;
		var gm = gmRes.getOutput();&#xD;
		var ta = gm.getTablesArray()&#xD;
		var tai = ta.iterator();&#xD;
		while (tai.hasNext()) {&#xD;
	  		var tsm = tai.next();&#xD;
			var tm = tsm.getAppSpecificTableModel();&#xD;
			var tName = tm.getTableName();&#xD;
			if (!exists(tName,ignoreArray)) {&#xD;
				var fieldArrList = tm.getTableField();&#xD;
                        	var fieldArr = fieldArrList.toArray();&#xD;
                        	var itemFound = false;&#xD;
                        	for (xx in fieldArr) {&#xD;
                             		fieldItem = fieldArr[xx];&#xD;
                             		if (!((fieldItem == null) || (fieldItem == undefined) || (fieldItem == &quot;&quot; ) || (fieldItem == &quot;undefined&quot;))) {&#xD;
                             			itemFound = true;&#xD;
						break;&#xD;
			     		}&#xD;
				}&#xD;
				if (itemFound) {&#xD;
					addTableFieldToASITable(tName, fieldArrList, targetCapId);&#xD;
				}&#xD;
			}&#xD;
		}&#xD;
	}&#xD;
}&#xD;
function addTableFieldToASITable(tableName,tableField) { // optional capId&#xD;
	if (arguments.length &gt; 2)&#xD;
		itemCap = arguments[2]; &#xD;
	else&#xD;
		return;&#xD;
&#xD;
	var tssmResult = aa.appSpecificTableScript.getAppSpecificTableModel(itemCap,tableName)&#xD;
&#xD;
	if (!tssmResult.getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error retrieving app specific table &quot; + tableName + &quot; &quot; + tssmResult.getErrorMessage()) ; return false }&#xD;
&#xD;
	var tssm = tssmResult.getOutput();&#xD;
	var tsm = tssm.getAppSpecificTableModel();&#xD;
	tsm.setTableField(tableField);&#xD;
	if (tsm.setReadonlyField) tsm.setReadonlyField(null);  // check for 6.6.1.   If so need to populate with null&#xD;
	addResult = aa.appSpecificTableScript.editAppSpecificTableInfos(tsm, itemCap, &quot;ADMIN&quot;);&#xD;
	if (!addResult .getSuccess())&#xD;
		{ logDebug(&quot;**WARNING: error adding record to ASI Table:  &quot; + tableName + &quot; &quot; + addResult.getErrorMessage()) ; return false }&#xD;
	else&#xD;
		logDebug(&quot;Successfully added record to ASI Table: &quot; + tableName);&#xD;
&#xD;
}&#xD;
&#xD;
function getCapWorkDesModel(capId)&#xD;
{&#xD;
	capWorkDesModel = null;&#xD;
	var s_result = aa.cap.getCapWorkDesByPK(capId);&#xD;
	if(s_result.getSuccess())&#xD;
	{&#xD;
		capWorkDesModel = s_result.getOutput();&#xD;
	}&#xD;
	else&#xD;
	{&#xD;
		aa.print(&quot;ERROR: Failed to get CapWorkDesModel: &quot; + s_result.getErrorMessage());&#xD;
		capWorkDesModel = null;	&#xD;
	}&#xD;
	return capWorkDesModel;&#xD;
}&#xD;
&#xD;
&#xD;
function copyDetailedDescription(srcCapId, targetCapId)&#xD;
{&#xD;
    //1. Get CapWorkDesModel with source CAPID.&#xD;
    var srcCapWorkDesModel = getCapWorkDesModel(srcCapId);&#xD;
    if (srcCapWorkDesModel == null)&#xD;
    {&#xD;
        return;&#xD;
    }&#xD;
    //2. Copy Detailed Description from source to target.&#xD;
    var targetCapWorkDesModel = srcCapWorkDesModel.getCapWorkDesModel();&#xD;
    targetCapWorkDesModel.setCapID(targetCapId);&#xD;
    aa.cap.createCapWorkDes(targetCapWorkDesModel);&#xD;
}&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
</content><initializer></initializer><title>WorkflowTaskUpdateAfter</title></script><scriptName>WorkflowTaskUpdateAfter</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
<agencyEvent><eventName>WorkflowTaskUpdateBefore</eventName><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2013-06-16T19:57:08.890-06:00</auditDate><auditID>GUTIERREZMA</auditID><auditStatus>A</auditStatus></auditModel><event><name>WorkflowTaskUpdateBefore</name><auditModel><auditDate>2002-03-15T14:09:30-07:00</auditDate><auditID>ACCELA</auditID><auditStatus>A</auditStatus></auditModel><description>This event occurs before a workflow task is updated.</description></event><script><name>WORKFLOWTASKUPDATEBEFORE</name><serviceProviderCode>ELPASO</serviceProviderCode><auditModel><auditDate>2015-11-23T16:26:48.347-07:00</auditDate><auditID>RIVERALD</auditID><auditStatus>A</auditStatus></auditModel><content> /*------------------------------------------------------------------------------------------------------/&#xD;
| Accela Automation&#xD;
| Accela, Inc.&#xD;
| Copyright (C): 2012&#xD;
|&#xD;
| SVN Id: WorkflowTaskUpdateBefore.js 6515 2012-03-16 18:15:38Z john.schomp &#xD;
| Program : WorkflowTaskUpdateBeforeV2.0.js&#xD;
| Event   : WorkflowTaskUpdateBefore&#xD;
|&#xD;
| Usage   : Master Script by Accela.  See accompanying documentation and release notes.&#xD;
|&#xD;
| Client  : N/A&#xD;
| Action# : N/A&#xD;
|&#xD;
| Notes   : Requires the TaskSpecificInfoModels parameter on this event.&#xD;
|&#xD;
|&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| START User Configurable Parameters&#xD;
|&#xD;
|     Only variables in the following section may be changed.  If any other section is modified, this&#xD;
|     will no longer be considered a &quot;Master&quot; script and will not be supported in future releases.  If&#xD;
|     changes are made, please add notes above.&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
var controlString = &quot;WorkflowTaskUpdateBefore&quot;; // Standard choice for control&#xD;
var preExecute = &quot;PreExecuteForAfterEvents&quot;;&#xD;
var documentOnly = true;		// Document Only -- displays hierarchy of std choice steps&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END User Configurable Parameters&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var SCRIPT_VERSION = 2.0&#xD;
&#xD;
eval(getScriptText(&quot;INCLUDES_ACCELA_FUNCTIONS&quot;));&#xD;
eval(getScriptText(&quot;INCLUDES_ACCELA_GLOBALS&quot;));&#xD;
eval(getScriptText(&quot;INCLUDES_CUSTOM&quot;));&#xD;
&#xD;
if (documentOnly) {&#xD;
	doStandardChoiceActions(controlString,false,0);&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;Documentation Successful.  No actions executed.&quot;);&#xD;
	aa.abortScript();&#xD;
	}&#xD;
	&#xD;
function getScriptText(vScriptName){&#xD;
	vScriptName = vScriptName.toUpperCase();&#xD;
	var emseBiz = aa.proxyInvoker.newInstance(&quot;com.accela.aa.emse.emse.EMSEBusiness&quot;).getOutput();&#xD;
	var emseScript = emseBiz.getMasterScript(aa.getServiceProviderCode(),vScriptName);&#xD;
	return emseScript.getScriptText() + &quot;&quot;;	&#xD;
}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| BEGIN Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
var wfTSI = aa.env.getValue(&quot;TaskSpecificInfoModels&quot;);	// Workflow Task Specific Info Array&#xD;
logDebug(&quot;TSIM = &quot; + wfTSI);&#xD;
var wfDate = aa.env.getValue(&quot;WorkflowStatusDate&quot;);	// Workflow Task Date&#xD;
var wfTask = aa.env.getValue(&quot;WorkflowTask&quot;);		// Workflow Task Triggered event&#xD;
var wfStatus = aa.env.getValue(&quot;WorkflowStatus&quot;);	// Status of workflow that triggered event&#xD;
var wfLastName = aa.env.getValue(&quot;StaffLastName&quot;);&#xD;
var wfFirstName = aa.env.getValue(&quot;StaffFirstName&quot;);&#xD;
var wfMiddleName = aa.env.getValue(&quot;StaffMiddleName&quot;);&#xD;
var wfProcessID = aa.env.getValue(&quot;ProcessID&quot;);&#xD;
if (wfMiddleName.length() == 0) wfMiddleName = null;&#xD;
var wfUserObj = aa.person.getUser(wfFirstName,wfMiddleName,wfLastName).getOutput();&#xD;
var wfUserId = &quot; &quot;;&#xD;
if (wfUserObj) wfUserId = wfUserObj.getUserID();&#xD;
var wfDateMMDDYYYY = wfDate.substr(5,2) + &quot;/&quot; + wfDate.substr(8,2) + &quot;/&quot; + wfDate.substr(0,4);	// date of status of workflow that triggered event in format MM/DD/YYYY&#xD;
var sysDate = aa.date.getCurrentDate();&#xD;
var sysDateMMDDYYYY = dateFormatted(sysDate.getMonth(),sysDate.getDayOfMonth(),sysDate.getYear(),&quot;&quot;);&#xD;
var wfStep ; var wfDue ; var wfProcess ; 		// Initialize&#xD;
&#xD;
var wfObj = aa.workflow.getTasks(capId).getOutput();&#xD;
for (i in wfObj)&#xD;
	{&#xD;
	fTask = wfObj[i];&#xD;
	if (fTask.getTaskDescription().equals(wfTask) &amp;&amp; (fTask.getProcessID() == wfProcessID))&#xD;
		{&#xD;
		wfStep = fTask.getStepNumber();&#xD;
		wfProcess = fTask.getProcessCode();&#xD;
		wfDue = fTask.getDueDate();&#xD;
		wfTaskObj = fTask&#xD;
		}&#xD;
	}&#xD;
&#xD;
if (wfTSI != &quot;&quot;)&#xD;
	{&#xD;
	for (TSIm in wfTSI)&#xD;
		{&#xD;
		if (useTaskSpecificGroupName)&#xD;
			AInfo[&quot;Updated.&quot; + wfProcess + &quot;.&quot; + wfTask + &quot;.&quot; + wfTSI[TSIm].getCheckboxDesc()] = wfTSI[TSIm].getChecklistComment();&#xD;
		else&#xD;
			AInfo[&quot;Updated.&quot; + wfTSI[TSIm].getCheckboxDesc()] = wfTSI[TSIm].getChecklistComment();&#xD;
		}&#xD;
	}&#xD;
&#xD;
&#xD;
logDebug(&quot;wfDate = &quot; + wfDate);&#xD;
logDebug(&quot;wfDateMMDDYYYY = &quot; + wfDateMMDDYYYY);&#xD;
logDebug(&quot;wfTask = &quot; + wfTask);&#xD;
logDebug(&quot;wfStep = &quot; + wfStep);&#xD;
logDebug(&quot;wfProcess = &quot; + wfProcess);&#xD;
logDebug(&quot;wfStatus = &quot; + wfStatus);&#xD;
logDebug(&quot;wfUserId = &quot; + wfUserId);&#xD;
logDebug(&quot;wfTaskObj = &quot; + wfTaskObj.getClass());&#xD;
&#xD;
/* Added for version 1.7 */&#xD;
var wfStaffUserID = aa.env.getValue(&quot;StaffUserID&quot;);&#xD;
var timeAccountingArray = new Array()&#xD;
if(aa.env.getValue(&quot;TimeAccountingArray&quot;) != &quot;&quot;)&#xD;
	timeAccountingArray =  aa.env.getValue(&quot;TimeAccountingArray&quot;);&#xD;
var wfTimeBillable = aa.env.getValue(&quot;Billable&quot;);&#xD;
var wfTimeOT = aa.env.getValue(&quot;Overtime&quot;);&#xD;
logDebug(&quot;wfStaffUserID = &quot; + wfStaffUserID);&#xD;
logDebug(&quot;wfTimeBillable = &quot; + wfTimeBillable);&#xD;
logDebug(&quot;wfTimeOT = &quot; + wfTimeOT);&#xD;
&#xD;
&#xD;
if (timeAccountingArray != null || timeAccountingArray !='')&#xD;
	{&#xD;
			for(var i=0;i&lt;timeAccountingArray.length;i++)&#xD;
			{&#xD;
			var timeLogModel = timeAccountingArray[i];&#xD;
			var timeLogSeq = timeLogModel.getTimeLogSeq();&#xD;
			var dateLogged = timeLogModel.getDateLogged();&#xD;
			var startTime = timeLogModel.getStartTime();&#xD;
			var endTime	= timeLogModel.getEndTime();&#xD;
			var timeElapsedHours = timeLogModel.getTimeElapsed().getHours();&#xD;
			var timeElapsedMin = timeLogModel.getTimeElapsed().getMinutes();&#xD;
&#xD;
			logDebug(&quot;TAtimeLogSeq = &quot; + timeLogSeq);&#xD;
			logDebug(&quot;TAdateLogged = &quot; + dateLogged);&#xD;
			logDebug(&quot;TAstartTime = &quot; + startTime);&#xD;
			logDebug(&quot;TAendTime = &quot; + endTime);&#xD;
			logDebug(&quot;TAtimeElapsedHours = &quot; + timeElapsedHours);&#xD;
			logDebug(&quot;TAtimeElapsedMin = &quot; + timeElapsedMin);&#xD;
			}&#xD;
	}&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| END Event Specific Variables&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (preExecute.length) doStandardChoiceActions(preExecute,true,0); 	// run Pre-execution code&#xD;
&#xD;
logGlobals(AInfo);&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========Main=Loop================&gt;&#xD;
|&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
//&#xD;
//  Get the Standard choices entry we'll use for this App type&#xD;
//  Then, get the action/criteria pairs for this app&#xD;
//&#xD;
&#xD;
doStandardChoiceActions(controlString,true,0);&#xD;
//&#xD;
// Check for invoicing of fees&#xD;
//&#xD;
if (feeSeqList.length)&#xD;
	{&#xD;
	invoiceResult = aa.finance.createInvoice(capId, feeSeqList, paymentPeriodList);&#xD;
	if (invoiceResult.getSuccess())&#xD;
		logMessage(&quot;Invoicing assessed fee items is successful.&quot;);&#xD;
	else&#xD;
		logMessage(&quot;**ERROR: Invoicing the fee items assessed to app # &quot; + appId + &quot; was not successful.  Reason: &quot; +  invoiceResult.getErrorMessage());&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========END=Main=Loop================&gt;&#xD;
/-----------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
if (debug.indexOf(&quot;**ERROR&quot;) &gt; 0)&#xD;
	{&#xD;
	aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
	}&#xD;
else&#xD;
	{&#xD;
	if (cancel)&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;1&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, &quot;&lt;font color=red&gt;&lt;b&gt;Action Cancelled&lt;/b&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&quot; + debug);&#xD;
		}&#xD;
	else&#xD;
		{&#xD;
		aa.env.setValue(&quot;ScriptReturnCode&quot;, &quot;0&quot;);&#xD;
		if (showMessage) aa.env.setValue(&quot;ScriptReturnMessage&quot;, message);&#xD;
		if (showDebug) 	aa.env.setValue(&quot;ScriptReturnMessage&quot;, debug);&#xD;
		}&#xD;
	}&#xD;
&#xD;
/*------------------------------------------------------------------------------------------------------/&#xD;
| &lt;===========External Functions (used by Action entries)&#xD;
/------------------------------------------------------------------------------------------------------*/&#xD;
&#xD;
</content><initializer></initializer><title>WorkflowTaskUpdateBefore</title></script><scriptName>WorkflowTaskUpdateBefore</scriptName><udf1>MASTER SCRIPT - 7.2.0</udf1></agencyEvent>
</list>